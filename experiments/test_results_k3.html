<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Filename</th>
      <th>Example</th>
      <th>UniXcoder #0</th>
      <th>UniXcoder #1</th>
      <th>UniXcoder #2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>serve_model_llm</td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from potassium import Potassium, Request, Response<br>from transformers import AutoTokenizer<br>from auto_gptq import AutoGPTQForCausalLM<br><br>MODEL_NAME_OR_PATH = "TheBloke/vicuna-33B-GPTQ"<br>MODEL_BASENAME = "vicuna-33b-GPTQ-4bit--1g.act.order"<br>DEVICE = "cuda:0"<br><br>app = Potassium("my_app") <br>[CURSOR]<br>@app.init<br>def init() -&gt; dict:<br>    """Initialize the application with the model and tokenizer."""<br>    tokenizer = AutoTokenizer.from_pretrained(MODEL_NAME_OR_PATH, use_fast=True)<br>    model = AutoGPTQForCausalLM.from_quantized(MODEL_NAME_OR_PATH,<br>        model_basename=MODEL_BASENAME,  <br>        use_safetensors=True,<br>        trust_remote_code=True,<br>        device=DEVICE,<br>        use_triton=False,<br>        quantize_config=None)<br>    return {<br>        "model": model,<br>        "tokenizer": tokenizer<br>    }<br>    <br>@app.handler()<br>def handler(context: dict, request: Request) -&gt; Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors='pt').input_ids.cuda()<br>    output = model.generate(inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens)<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)<br><br>if __name__ == "__main__":<br>    app.serve()</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333"># Copyright (c) Microsoft Corporation. All rights reserved.<br># Licensed under the MIT License.<br>from collections import defaultdict<br>import os<br>from dotenv import load_dotenv, find_dotenv<br>from fastapi import Body, FastAPI<br>from starlette.middleware.cors import CORSMiddleware<br>from starlette.responses import RedirectResponse<br>import spacy<br>import srsly<br>import uvicorn<br>from app.models import (<br>    ENT_PROP_MAP,<br>    RecordsRequest,<br>    RecordsResponse,<br>    RecordsEntitiesByTypeResponse,<br>)<br>from app.spacy_extractor import SpacyExtractor<br>app = FastAPI(<br>    title="{{cookiecutter.project_name}}",<br>    version="1.0",<br>    description="{{cookiecutter.short_description}}",<br>)<br>example_request = srsly.read_json("app/data/example_request.json")<br>nlp = spacy.load("{{cookiecutter.spacy_model}}")<br>extractor = SpacyExtractor(nlp)<br>@app.get("/", include_in_schema=False)<br>def docs_redirect():<br>    return RedirectResponse(f"/docs")<br>@app.post("/entities", response_model=RecordsResponse, tags=["NER"])</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">import logging<br>from typing import TYPE_CHECKING<br>from uuid import uuid4<br><br>import pytest<br>from fastapi import Request, Response<br>from httpx import AsyncClient<br>from starlette.testclient import TestClient<br><br>from asgi_correlation_id.middleware import FAILED_VALIDATION_MESSAGE, is_valid_uuid4<br>from tests.conftest import (<br>    TRANSFORMER_VALUE,<br>    default_app,<br>    generator_app,<br>    no_validator_or_transformer_app,<br>    transformer_app,<br>    update_request_header_app,<br>)</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from datetime import datetime, timedelta<br>from typing import List, Union<br>from fastapi import Depends, FastAPI, HTTPException, Security, status<br>from fastapi.security import (<br>    OAuth2PasswordBearer,<br>    OAuth2PasswordRequestForm,<br>    SecurityScopes,<br>)<br>from jose import JWTError, jwt<br>from passlib.context import CryptContext<br>from pydantic import BaseModel, ValidationError<br>from typing_extensions import Annotated<br># to get a string like this run:<br># openssl rand -hex 32<br>SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"<br>ALGORITHM = "HS256"<br>ACCESS_TOKEN_EXPIRE_MINUTES = 30<br>fake_users_db = {<br>    "johndoe": {<br>        "username": "johndoe",<br>        "full_name": "John Doe",<br>        "email": "johndoe@example.com",<br>        "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",<br>        "disabled": False,<br>    },<br>    "alice": {<br>        "username": "alice",<br>        "full_name": "Alice Chains",<br>        "email": "alicechains@example.com",</code></pre></div></td>
    </tr>
    <tr>
      <th>1</th>
      <td>auth_implemented</td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from fastapi import HTTPException, Request<br>from firebase_admin import auth as firebase_auth<br>from firebase_admin.auth import (<br>    CertificateFetchError,<br>    ExpiredIdTokenError,<br>    InvalidIdTokenError,<br>    RevokedIdTokenError,<br>    UserDisabledError,<br>)<br><br>from app import models<br><br>PUBLIC_ROUTES = [<br>    "/api/auth/signup", [CURSOR]<br>]<br><br><br>class FirebaseAuthMiddleware:<br>    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try: [CURSOR]<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from fastapi import APIRouter, Depends, HTTPException<br>from fastapi.security import OAuth2PasswordRequestForm<br>from sqlalchemy.ext.asyncio import AsyncSession<br>from app.api.deps import get_session<br>from app.core.security import authenticate, create_access_token<br>from app.schemas.token import Token<br>router = APIRouter(tags=["Login"])<br>@router.post("/login/", response_model=Token)<br>async def login(<br>    data: OAuth2PasswordRequestForm = Depends(),<br>    session: AsyncSession = Depends(get_session),<br>):<br>    user = await authenticate(session, email=data.username, password=data.password)<br>    if user is None:<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br>    if not user.is_active:<br>        raise HTTPException(status_code=400, detail="Inactive user")<br>    return {"access_token": create_access_token(user), "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">import time<br>import jwt<br>from fastapi import APIRouter, Depends, HTTPException, status<br>from fastapi.security import OAuth2PasswordRequestForm<br>from pydantic import ValidationError<br>from sqlalchemy import select<br>from sqlalchemy.ext.asyncio import AsyncSession<br>from app.api import deps<br>from app.core import config, security<br>from app.models import User<br>from app.schemas.requests import RefreshTokenRequest<br>from app.schemas.responses import AccessTokenResponse<br>router = APIRouter()<br>@router.post("/access-token", response_model=AccessTokenResponse)<br>async def login_access_token(<br>    session: AsyncSession = Depends(deps.get_session),<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>):<br>    """OAuth2 compatible token, get an access token for future requests using username and password"""<br>    result = await session.execute(select(User).where(User.email == form_data.username))<br>    user = result.scalars().first()<br>    if user is None:</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">response = client.get("/simple")<br>    assert response.json()["env"] == "FALSE"<br>    response = client.get("/asimple")<br>    assert response.json()["env"] == "FALSE"<br>    # confirm the Custom APIRoute class fix<br>    response = client.get("/future")<br>    assert response.json()["env"] == "FALSE"<br>    response = client.get("/afuture")<br>    assert response.json()["env"] == "FALSE"<br>def test_register_deps():<br>    """Test add_route_dependencies."""<br>    http_basic = security.HTTPBasic()<br>    def must_be_bob(credentials: security.HTTPBasicCredentials = Depends(http_basic)):<br>        if credentials.username == "bob":<br>            return True<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="You're not Bob",<br>            headers={"WWW-Authenticate": "Basic"},<br>        )<br>    app = FastAPI()<br>    @app.get("/one")<br>    def one():<br>        """one."""<br>        return "one"<br>    @app.get("/two")<br>    def two():<br>        """two."""<br>        return "two"</code></pre></div></td>
    </tr>
    <tr>
      <th>2</th>
      <td>uvicorn_main</td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app", port=5001, reload=True, workers=1, timeout_keep_alive=30<br>    )<br>[CURSOR]</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">):<br>    res = Schedule.get_job(job_id=job_id)<br>    if not res:<br>        return resp_fail(msg=f"not found job {job_id}")<br>    Schedule.remove_job(job_id)<br>    return resp_ok()<br># 暂停和恢复任务 暂时没看<br>if __name__ == "__main__":<br>    import uvicorn<br>    # 官方推荐是用命令后启动 uvicorn main:app --host=127.0.0.1 --port=8150 --reload<br>    uvicorn.run(app='main:app', host="127.0.0.1", port=8151, reload=False, debug=True)</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333"># 暂停和恢复任务 暂时没看<br><br><br>if __name__ == "__main__":<br>    import uvicorn<br><br>    # 官方推荐是用命令后启动 uvicorn main:app --host=127.0.0.1 --port=8150 --reload<br>    uvicorn.run(app='main:app', host="127.0.0.1", port=8151, reload=False, debug=True)</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333"># 暂停和恢复任务 暂时没看<br><br><br>if __name__ == "__main__":<br>    import uvicorn<br><br>    # 官方推荐是用命令后启动 uvicorn main:app --host=127.0.0.1 --port=8150 --reload<br>    uvicorn.run(app='main:app', host="127.0.0.1", port=8151, reload=False, debug=True)</code></pre></div></td>
    </tr>
    <tr>
      <th>3</th>
      <td>auth_outline</td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from fastapi import HTTPException, Request<br><br><br>class AuthMiddleware:<br>    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        <br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass [CURSOR]<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">async def __call__(<br>        self, request: Request<br>    ) -&gt; Optional[HTTPAuthorizationCredentials]:<br>        authorization = request.headers.get("Authorization")<br>        scheme, credentials = get_authorization_scheme_param(authorization)<br>        if not (authorization and scheme and credentials):<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        if scheme.lower() != "bearer":<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN,<br>                    detail="Invalid authentication credentials",<br>                )<br>            else:<br>                return None<br>        return HTTPAuthorizationCredentials(scheme=scheme, credentials=credentials)</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">else:<br>                return None<br>        invalid_user_credentials_exc = HTTPException(<br>            status_code=HTTP_401_UNAUTHORIZED,<br>            detail="Invalid authentication credentials",<br>            headers=unauthorized_headers,<br>        )<br>        try:<br>            data = b64decode(param).decode("ascii")<br>        except (ValueError, UnicodeDecodeError, binascii.Error):<br>            raise invalid_user_credentials_exc  # noqa: B904<br>        username, separator, password = data.partition(":")<br>        if not separator:<br>            raise invalid_user_credentials_exc<br>        return HTTPBasicCredentials(username=username, password=password)<br>class HTTPBearer(HTTPBase):<br>    """<br>    HTTP Bearer token authentication.<br>    ## Usage<br>    Create an instance object and use that object as the dependency in `Depends()`.<br>    The dependency result will be an `HTTPAuthorizationCredentials` object containing<br>    the `scheme` and the `credentials`.<br>    ## Example<br>    ```python</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">async def __call__(<br>        self, request: Request<br>    ) -&gt; Optional[HTTPAuthorizationCredentials]:<br>        authorization = request.headers.get("Authorization")<br>        scheme, credentials = get_authorization_scheme_param(authorization)<br>        if not (authorization and scheme and credentials):<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        return HTTPAuthorizationCredentials(scheme=scheme, credentials=credentials)</code></pre></div></td>
    </tr>
    <tr>
      <th>4</th>
      <td>generate_openapi</td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from fluento import config<br><br>config.PARTIAL_INIT = True<br><br>import json<br>import sys<br><br>from fastapi.routing import APIRoute<br><br>from fluento import main<br><br>output_file = sys.argv[1]<br><br># Set operation IDs to route names<br>app = main.app<br>for route in app.routes:<br>    if isinstance(route, APIRoute):<br>        route.operation_id = route.name<br>        route.tags = route.endpoint.__module__.split(".")[2:]<br><br># Generate OpenAPI schema<br>openapi_def = app.openapi()<br>[CURSOR]<br># Write to file<br>with open(output_file, "w") as f:<br>    f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from docs_src.app_testing.test_main import client, test_read_main<br>def test_main():<br>    test_read_main()<br>def test_openapi_schema():<br>    response = client.get("/openapi.json")<br>    assert response.status_code == 200, response.text<br>    assert response.json() == {<br>        "openapi": "3.1.0",<br>        "info": {"title": "FastAPI", "version": "0.1.0"},<br>        "paths": {<br>            "/": {<br>                "get": {<br>                    "responses": {<br>                        "200": {<br>                            "description": "Successful Response",<br>                            "content": {"application/json": {"schema": {}}},<br>                        }<br>                    },<br>                    "summary": "Read Main",<br>                    "operationId": "read_main__get",<br>                }<br>            }<br>        },<br>    }</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from docs_src.app_testing.tutorial001 import client, test_read_main<br>def test_main():<br>    test_read_main()<br>def test_openapi_schema():<br>    response = client.get("/openapi.json")<br>    assert response.status_code == 200, response.text<br>    assert response.json() == {<br>        "openapi": "3.1.0",<br>        "info": {"title": "FastAPI", "version": "0.1.0"},<br>        "paths": {<br>            "/": {<br>                "get": {<br>                    "responses": {<br>                        "200": {<br>                            "description": "Successful Response",<br>                            "content": {"application/json": {"schema": {}}},<br>                        }<br>                    },<br>                    "summary": "Read Main",<br>                    "operationId": "read_main__get",<br>                }<br>            }<br>        },<br>    }</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">def test_openapi():<br>    response = client.get("/openapi.json")<br>    assert response.status_code == 200<br>    assert response.json() == {<br>        "openapi": "3.1.0",<br>        "info": {"title": "FastAPI", "version": "0.1.0"},<br>        "paths": {<br>            "/app": {<br>                "get": {<br>                    "summary": "Read Main",<br>                    "operationId": "read_main_app_get",<br>                    "responses": {<br>                        "200": {<br>                            "description": "Successful Response",<br>                            "content": {"application/json": {"schema": {}}},<br>                        }<br>                    },<br>                }<br>            }<br>        },<br>        "servers": [{"url": "/api/v1"}],<br>    }</code></pre></div></td>
    </tr>
    <tr>
      <th>5</th>
      <td>healthcheck</td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from fastapi import APIRouter<br><br>router = APIRouter(tags=["health"])<br><br><br>@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}[CURSOR]</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">@app.get("/healthcheck", include_in_schema=False)<br>async def healthcheck() -&gt; dict[str, str]:<br>    return {"status": "ok"}<br><br><br>app.include_router(auth_router, prefix="/auth", tags=["Auth"])<br>app.include_router(<br>    external_service_router, prefix="/external-service", tags=["External Service Calls"]<br>)</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">router = APIRouter(prefix="/health", tags=["Health"])<br><br><br>@router.get("/", status_code=204)<br>async def health(session: AsyncSession = Depends(get_session)):<br>    try:<br>        await asyncio.wait_for(session.execute("SELECT 1"), timeout=1)<br>    except (asyncio.TimeoutError, socket.gaierror):<br>        return Response(status_code=503)<br>    return Response(status_code=204)</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from app.api.deps import get_session<br><br>router = APIRouter(prefix="/health", tags=["Health"])<br><br><br>@router.get("/", status_code=204)<br>async def health(session: AsyncSession = Depends(get_session)):<br>    try:<br>        await asyncio.wait_for(session.execute("SELECT 1"), timeout=1)<br>    except (asyncio.TimeoutError, socket.gaierror):<br>        return Response(status_code=503)<br>    return Response(status_code=204)</code></pre></div></td>
    </tr>
    <tr>
      <th>6</th>
      <td>dependency_injection2</td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from http import client<br>from fastapi import APIRouter, HTTPException, status<br>from typing import Annotated<br>from urllib.parse import urlencode, urlparse<br>import uuid<br>from fastapi import Cookie, Depends<br>from fastapi.responses import RedirectResponse<br>from pydantic import BaseModel<br>import requests<br>from jwt import decode<br>import datetime<br>import logging as log<br>from dependency_injector.wiring import Provide, inject<br>from prompto_server.db.session import Session<br>from prompto_server import Container<br>from starlette.responses import FileResponse<br><br>router = APIRouter(<br>    tags=["authentication"],<br>)<br><br><br>@inject<br>async def current_user(<br>    prompto_id: Annotated[str, Cookie()] = None,<br>    auth_service=Depends(Provide[Container.auth_service]),<br>) -&gt; Session:<br>    if not prompto_id:<br>        raise HTTPException(status_code=401, detail="Unauthorized")<br><br>    session = await auth_service.lookup(prompto_id)<br><br>    if not session:<br>        raise HTTPException(status_code=401, detail="Unauthorized")<br><br>    return session<br><br><br>@router.get(<br>    "/auth/login",<br>    status_code=307,<br>    responses={307: {"description": "Redirect to Keycloak"}},<br>)<br>@inject<br>def login(state: str, config=Depends(Provide[Container.config])) -&gt; RedirectResponse:<br>    # TODO Use the state variable of the client<br>    # TODO export URLS<br>    params = {<br>        "response_type": "code",<br>        "scope": "openid email profile",<br>        "client_id": "prompto",<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "state": state,<br>        "nonce": "123123",  # TODO implement using nonce [CURSOR]<br>    }<br>    auth_server_url = config["oidc"]["auth_url"] + "?" + urlencode(params)<br>    return RedirectResponse(url=auth_server_url)<br><br><br>@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )<br><br><br>class WhoamiResponse(BaseModel):<br>    username: str<br>    expires: int<br><br><br>@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -&gt; WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)<br><br><br>class LogoutResponse(BaseModel):<br>    message: str = "Logout successful"<br><br><br>@router.post(<br>    path="/auth/logout",<br>    responses={401: {"description": "Unauthorized"}},<br>)<br>@inject<br>async def logout(<br>    session: Annotated[Session, Depends(current_user)],<br>    auth_service=Depends(Provide[Container.auth_service]),<br>) -&gt; LogoutResponse:<br>    await auth_service.clear(session)<br>    return LogoutResponse()<br><br><br>@router.get(<br>    path="/auth/success",<br>    responses={401: {"description": "Unauthorized"}},<br>)<br>@inject<br>async def success_page(<br>    session: Annotated[Session, Depends(current_user)],<br>    auth_service=Depends(Provide[Container.auth_service]),<br>) -&gt; FileResponse:<br>    return FileResponse("templates/redirect_page.html")</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from datetime import timedelta<br>from typing import Any<br>from fastapi import APIRouter, Body, Depends, HTTPException<br>from fastapi.security import OAuth2PasswordRequestForm<br>from sqlalchemy.orm import Session<br>from app import crud, models, schemas<br>from app.api import deps<br>from app.core import security<br>from app.core.config import settings<br>from app.core.security import get_password_hash<br>from app.utils import (<br>    generate_password_reset_token,<br>    send_reset_password_email,<br>    verify_password_reset_token,<br>)<br>router = APIRouter()<br>@router.post("/login/access-token", response_model=schemas.Token)<br>def login_access_token(<br>    db: Session = Depends(deps.get_db), form_data: OAuth2PasswordRequestForm = Depends()<br>) -&gt; Any:<br>    """<br>    OAuth2 compatible token login, get an access token for future requests<br>    """<br>    user = crud.user.authenticate(<br>        db, email=form_data.username, password=form_data.password<br>    )<br>    if not user:</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">@router.post("/login/access-token", response_model=schemas.Token)<br>def login_access_token(<br>    db: Session = Depends(deps.get_db), form_data: OAuth2PasswordRequestForm = Depends()<br>) -&gt; Any:<br>    """<br>    OAuth2 compatible token login, get an access token for future requests<br>    """<br>    user = crud.user.authenticate(<br>        db, email=form_data.username, password=form_data.password<br>    )<br>    if not user:<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br>    elif not crud.user.is_active(user):<br>        raise HTTPException(status_code=400, detail="Inactive user")<br>    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)<br>    return {<br>        "access_token": security.create_access_token(<br>            user.id, expires_delta=access_token_expires<br>        ),<br>        "token_type": "bearer",<br>    }</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from fastapi import APIRouter, Depends, HTTPException<br>from fastapi.security import OAuth2PasswordRequestForm<br>from sqlalchemy.ext.asyncio import AsyncSession<br>from app.api.deps import get_session<br>from app.core.security import authenticate, create_access_token<br>from app.schemas.token import Token<br>router = APIRouter(tags=["Login"])<br>@router.post("/login/", response_model=Token)<br>async def login(<br>    data: OAuth2PasswordRequestForm = Depends(),<br>    session: AsyncSession = Depends(get_session),<br>):<br>    user = await authenticate(session, email=data.username, password=data.password)<br>    if user is None:<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br>    if not user.is_active:<br>        raise HTTPException(status_code=400, detail="Inactive user")<br>    return {"access_token": create_access_token(user), "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <th>7</th>
      <td>translation_api</td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">import logging<br><br>import langcodes<br>from fastapi import APIRouter, Request<br>from fastapi_camelcase import CamelModel<br>from google.cloud import translate_v3 as translate<br><br>from fluento import config, models, schemas<br>from fluento.wrapper import mixpanel<br><br>router = APIRouter(prefix="/api/translation")<br>logger = logging.getLogger(__name__)<br><br><br>translation_client = translate.TranslationServiceClient.from_service_account_file(<br>    config.GC_TRANSLATION_CREDENTIALS<br>)<br><br><br>@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -&gt; schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) &gt; 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation) [CURSOR]</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">"detail": [<br>                {<br>                    "type": "model_attributes_type",<br>                    "loc": ["body"],<br>                    "msg": "Input should be a valid dictionary or object to extract fields from",<br>                    "input": '{"name": "Foo", "price": 50.5}',<br>                    "url": match_pydantic_error_url(<br>                        "model_attributes_type"<br>                    ),  # "https://errors.pydantic.dev/0.38.0/v/dict_attributes_type",<br>                }<br>            ]<br>        }<br>    ) | IsDict(<br>        # TODO: remove when deprecating Pydantic v1<br>        {<br>            "detail": [<br>                {<br>                    "loc": ["body"],<br>                    "msg": "value is not a valid dict",<br>                    "type": "type_error.dict",<br>                }<br>            ]<br>        }<br>    )<br>    response = client.post(<br>        "/items/", content=data, headers={"Content-Type": "application/geo+json-seq"}<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">async def get_form_item(self, request: Request):<br>        url = self.display_admin.router_path + self.display_admin.page_path<br>        picker = Picker(<br>            name=self.display_admin.model.__table__.name,<br>            label=self.display_admin.page_schema.label,<br>            labelField="name",<br>            valueField="id",<br>            multiple=True,<br>            required=False,<br>            modalMode="dialog",<br>            size="full",<br>            pickerSchema={"&amp;": "${body}"},<br>            source={<br>                "method": "post",<br>                "data": "${body.api.data}",<br>                "url": "${body.api.url}&amp;link_model=" + self.pk_admin.model.__table__.name + "&amp;op=in_&amp;link_item_id=${"<br>                "api.qsOptions.id}",<br>            },<br>        )<br>        adaptor = None<br>        if await self.pk_admin.has_update_permission(request, None, None):<br>            button_create = ActionType.Ajax(<br>                actionType="ajax",<br>                label=_("Add Association"),<br>                level=LevelEnum.danger,<br>                confirmText=_("Are you sure you want to add the association?"),<br>                api=f"post:{self.pk_admin.app.router_path}{self.pk_admin.router.prefix}{self.path}"<br>                + '/${REPLACE(query.link_item_id, "!", "")}?link_id=${IF(ids, ids, id)}',<br>            )  # query.link_item_id<br>            adaptor = (<br>                'if(!payload.hasOwnProperty("_payload")){payload._payload=JSON.stringify(payload);}'<br>                "payload=JSON.parse(payload._payload);button_create=" + button_create.amis_json() + ";"<br>                "payload.data.body.bulkActions.push(button_create);"<br>                "payload.data.body.itemActions.push(button_create);"<br>                "return payload;".replace("action_id", "create" + self.path.replace("/", "_"))<br>            )<br>            button_create_dialog = ActionType.Dialog(<br>                icon="fa fa-plus pull-left",<br>                label=_("Add Association"),<br>                level=LevelEnum.danger,<br>               </code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">def test_create_item_list():<br>    client = get_app_client()<br>    client_no = get_app_client(separate_input_output_schemas=False)<br>    data = [<br>        {"name": "Plumbus"},<br>        {<br>            "name": "Portal Gun",<br>            "description": "Device to travel through the multi-rick-verse",<br>        },<br>    ]<br>    response = client.post("/items-list/", json=data)<br>    response2 = client_no.post("/items-list/", json=data)<br>    assert response.status_code == response2.status_code == 200, response.text<br>    assert (<br>        response.json()<br>        == response2.json()<br>        == [<br>            {"name": "Plumbus", "description": None, "sub": None},<br>            {<br>                "name": "Portal Gun",<br>                "description": "Device to travel through the multi-rick-verse",<br>                "sub": None,<br>            },<br>        ]<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <th>8</th>
      <td>snippet_schema</td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from pydantic import BaseModel<br>import datetime<br><br><br>class SchedulingTimeRequest(BaseModel):<br>    # Battery charge in percentage [0-1] once the drive starts <br>    battery_charge: float<br><br>    # When the car will start to drive<br>    drive_start_time: datetime.datetime<br><br>[CURSOR]<br>class SchedulingTimeResponse(BaseModel):<br>    # When the car should charge<br>    recommended_starting_time: datetime.datetime</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">id = models.BigAutoField(primary_key=True)<br>    checkpoint = models.CharField(max_length=100)<br>    template_slug = models.CharField(max_length=100)<br>    prompt = models.TextField()<br>    n_prompt = models.TextField()<br>    sampler = models.CharField(max_length=50)<br>    cfg_scale = models.IntegerField(default=7)<br>    steps = models.IntegerField(default=30)<br>    seed = models.BigIntegerField(default=-1)<br>    sort_num = models.IntegerField(db_index=True, default=999)<br>    created_at = models.DateTimeField(auto_now_add=True, db_index=True)<br>    updated_at = models.DateTimeField(auto_now=True)</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">app = FastAPI(<br>    title="ChimichangApp",<br>    description=description,<br>    summary="Deadpool's favorite app. Nuff said.",<br>    version="0.0.1",<br>    terms_of_service="http://example.com/terms/",<br>    contact={<br>        "name": "Deadpoolio the Amazing",<br>        "url": "http://x-force.example.com/contact/",<br>        "email": "dp@x-force.example.com",<br>    },<br>    license_info={<br>        "name": "Apache 2.0",<br>        "identifier": "MIT",<br>    },<br>)</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from fastapi import FastAPI<br>description = """<br>ChimichangApp API helps you do awesome stuff. 🚀<br>## Items<br>You can **read items**.<br>## Users<br>You will be able to:<br>* **Create users** (_not implemented_).<br>* **Read users** (_not implemented_).<br>"""<br>app = FastAPI(<br>    title="ChimichangApp",<br>    description=description,<br>    summary="Deadpool's favorite app. Nuff said.",<br>    version="0.0.1",<br>    terms_of_service="http://example.com/terms/",<br>    contact={<br>        "name": "Deadpoolio the Amazing",<br>        "url": "http://x-force.example.com/contact/",<br>        "email": "dp@x-force.example.com",<br>    },<br>    license_info={<br>        "name": "Apache 2.0",<br>        "identifier": "MIT",<br>    },<br>)<br>@app.get("/items/")<br>async def read_items():<br>    return [{"name": "Katana"}]</code></pre></div></td>
    </tr>
    <tr>
      <th>9</th>
      <td>get_rooms_api</td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -&gt; schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(    [CURSOR]<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">import pytest<br>from dirty_equals import IsDict<br>from fastapi.testclient import TestClient<br>from ...utils import needs_py39<br>@pytest.fixture(name="client")<br>def get_client():<br>    from docs_src.extra_data_types.tutorial001_an_py39 import app<br>    client = TestClient(app)<br>    return client<br>@needs_py39<br>def test_extra_types(client: TestClient):<br>    item_id = "ff97dd87-a4a5-4a12-b412-cde99f33e00e"<br>    data = {<br>        "start_datetime": "2018-12-22T14:00:00+00:00",<br>        "end_datetime": "2018-12-24T15:00:00+00:00",<br>        "repeat_at": "15:30:00",<br>        "process_after": 300,<br>    }<br>    expected_response = data.copy()<br>    expected_response.update(<br>        {<br>            "start_process": "2018-12-22T14:05:00+00:00",<br>            "duration": 176_100,<br>            "item_id": item_id,<br>        }<br>    )<br>    response = client.put(f"/items/{item_id}", json=data)<br>    assert response.status_code == 200, response.text<br>    assert response.json() == expected_response<br>@needs_py39</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">break<br>@pytest.mark.asyncio<br>async def test_chat_completion_resource_call():<br>    mocked_completion = ChatCompletion(<br>        id="chat-completion-id",<br>        created=1700936386,<br>        model="gpt-3.5-turbo-0613",<br>        object="chat.completion",<br>        choices=[<br>            chat_completion.Choice(<br>                finish_reason="stop",<br>                index=0,<br>                message=chat_completion.ChatCompletionMessage(<br>                    content="Hello! How can I assist you today?", role="assistant"<br>                ),<br>            )<br>        ],<br>    )<br>    chat_completion_resource = ChatCompletionResource(<br>        client=MagicMock(spec=AsyncOpenAI)<br>    )<br>    chat_completion_resource._client.chat = MagicMock()<br>    chat_completion_resource._client.chat.completions = MagicMock()<br>    chat_completion_resource._client.chat.completions.create = AsyncMock(<br>        return_value=mocked_completion<br>    )<br>    messages = [Message(role="user", content="Hello")]</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from dirty_equals import IsDict<br>from fastapi.testclient import TestClient<br>from docs_src.extra_data_types.tutorial001_an import app<br>client = TestClient(app)<br>def test_extra_types():<br>    item_id = "ff97dd87-a4a5-4a12-b412-cde99f33e00e"<br>    data = {<br>        "start_datetime": "2018-12-22T14:00:00+00:00",<br>        "end_datetime": "2018-12-24T15:00:00+00:00",<br>        "repeat_at": "15:30:00",<br>        "process_after": 300,<br>    }<br>    expected_response = data.copy()<br>    expected_response.update(<br>        {<br>            "start_process": "2018-12-22T14:05:00+00:00",<br>            "duration": 176_100,<br>            "item_id": item_id,<br>        }<br>    )<br>    response = client.put(f"/items/{item_id}", json=data)<br>    assert response.status_code == 200, response.text<br>    assert response.json() == expected_response<br>def test_openapi_schema():<br>    response = client.get("/openapi.json")<br>    assert response.status_code == 200, response.text<br>    assert response.json() == {<br>        "openapi": "3.1.0",</code></pre></div></td>
    </tr>
    <tr>
      <th>10</th>
      <td>dependency_injection</td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from typing import Annotated<br>from fastapi import APIRouter, Depends, HTTPException, status<br>from pydantic import BaseModel<br>from prompto_server.agent.base_agent import BaseAgent<br>from prompto_server.db import PersistedMessage<br>from uuid import UUID<br>from dependency_injector.wiring import Provide, inject<br>from prompto_server.db.chat_history import FeedbackType<br>from prompto_server.db.session import Session<br>from prompto_server.routers.auth import current_user<br>from prompto_server import Container<br>from prompto_server.services.chat_service import AgentType, ChatService<br>from prompto_server.services.exceptions import NotFoundException<br><br>router = APIRouter(tags=["chat"])<br><br><br>class ChatRequest(BaseModel):<br>    id: str | None = None<br>    message: str<br><br><br>class ChatResponse(BaseModel):<br>    history_id: UUID<br>    messages: list[PersistedMessage]<br><br><br>@router.post("/chat/create")<br>@inject<br>async def create_chat(<br>    chat_rq: ChatRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service: ChatService = Depends(Provide[Container.chat_service]),<br>) -&gt; ChatResponse:<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    if chat_rq.id:<br>        raise HTTPException(<br>            status_code=status.HTTP_400_BAD_REQUEST,<br>            detail="ID should not be provided when creating new chat",<br>        )<br><br>    agent: BaseAgent = chat_service.receive_agent(AgentType.DEBUG)<br><br>    if chat_rq.message.startswith("llm"):<br>        agent = chat_service.receive_agent(AgentType.PROMPTO)<br>        chat_rq.message = chat_rq.message[3:]<br><br>    try:<br>        history = await agent.create_chat(session, chat_rq.message)  # TODO Remove cut<br>    except Exception:<br>        raise HTTPException(<br>            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,<br>            detail="Error while generating response.",<br>        )<br><br>    return ChatResponse(<br>        history_id=history.history_id,<br>        messages=history.messages,<br>    )<br><br><br>class ChatRequest(BaseModel):<br>    id: str | None = None<br>    message: str<br><br><br>@router.post("/chat/continue")<br>@inject<br>async def continue_chat(<br>    chat_rq: ChatRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Depends(Provide[Container.chat_service]),<br>) -&gt; ChatResponse:<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    if not chat_rq.id:<br>        raise HTTPException(<br>            status_code=status.HTTP_400_BAD_REQUEST,<br>            detail="ID should be provided when continuing chat",<br>        )<br><br>    agent: BaseAgent = chat_service.receive_agent(AgentType.DEBUG)<br>    history = await agent.continue_chat(session, chat_rq.id, chat_rq.message)<br><br>    # Create response<br>    return ChatResponse( [CURSOR]<br>        history_id=history.history_id,<br>        messages=history.messages,<br>    )<br><br><br>class FeedbackRequest(BaseModel):<br>    history_id: UUID<br>    message_id: UUID<br>    feedback_type: FeedbackType<br><br><br>class FeedbackResponse(BaseModel):<br>    history_id: UUID<br>    message_id: UUID<br>    feedback_type: FeedbackType<br><br><br>@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">from unittest.mock import AsyncMock, MagicMock<br>import pytest<br>from openai.types.chat import chat_completion, chat_completion_chunk<br>from lanarky.adapters.openai.resources import (<br>    AsyncOpenAI,<br>    ChatCompletion,<br>    ChatCompletionChunk,<br>    ChatCompletionResource,<br>    Message,<br>)<br>@pytest.mark.asyncio<br>async def test_chat_completion_resource_stream_response():<br>    async def mock_completion_chunk_stream():<br>        yield ChatCompletionChunk(<br>            id="chat-completion-id",<br>            created=1700936386,<br>            model="gpt-3.5-turbo-0613",<br>            object="chat.completion.chunk",<br>            choices=[<br>                chat_completion_chunk.Choice(<br>                    index=0,<br>                    finish_reason=None,<br>                    delta=chat_completion_chunk.ChoiceDelta(<br>                        content="Hello! How can I assist you today?"<br>                    ),<br>                )<br>            ],<br>        )<br>    chat_completion_resource = ChatCompletionResource(</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">break<br>@pytest.mark.asyncio<br>async def test_chat_completion_resource_call():<br>    mocked_completion = ChatCompletion(<br>        id="chat-completion-id",<br>        created=1700936386,<br>        model="gpt-3.5-turbo-0613",<br>        object="chat.completion",<br>        choices=[<br>            chat_completion.Choice(<br>                finish_reason="stop",<br>                index=0,<br>                message=chat_completion.ChatCompletionMessage(<br>                    content="Hello! How can I assist you today?", role="assistant"<br>                ),<br>            )<br>        ],<br>    )<br>    chat_completion_resource = ChatCompletionResource(<br>        client=MagicMock(spec=AsyncOpenAI)<br>    )<br>    chat_completion_resource._client.chat = MagicMock()<br>    chat_completion_resource._client.chat.completions = MagicMock()<br>    chat_completion_resource._client.chat.completions.create = AsyncMock(<br>        return_value=mocked_completion<br>    )<br>    messages = [Message(role="user", content="Hello")]</code></pre></div></td>
      <td><div style="text-align: left; width: 500px; word-wrap: break-word; white-space: normal; overflow-x: scroll; background-color:#333"><pre><code style="background-color: #333">history[-1][1] = ""<br>            for event in StreamingClient().stream_response(<br>                "POST", "/chat", json={"messages": messages}, params={"system": system}<br>            ):<br>                history[-1][1] += event.data<br>                yield history<br>        user_input.submit(<br>            lambda user_input, chatbot: ("", chatbot + [[user_input, None]]),<br>            [user_input, chatbot],<br>            [user_input, chatbot],<br>            queue=False,<br>        ).then(chat, [chatbot, system_message], chatbot)<br>        clear_btn.click(lambda: None, None, chatbot, queue=False)<br>    return gr.mount_gradio_app(app, blocks.queue(), "/")<br>app = mount_playground(app)<br>if __name__ == "__main__":<br>    import uvicorn<br>    uvicorn.run(app)</code></pre></div></td>
    </tr>
  </tbody>
</table>