from http import client
from fastapi import APIRouter, HTTPException, status
from typing import Annotated
from urllib.parse import urlencode, urlparse
import uuid
from fastapi import Cookie, Depends
from fastapi.responses import RedirectResponse
from pydantic import BaseModel
import requests
from jwt import decode
import datetime
import logging as log
from dependency_injector.wiring import Provide, inject
from prompto_server.db.session import Session
from prompto_server import Container
from starlette.responses import FileResponse

router = APIRouter(
    tags=["authentication"],
)


@inject
async def current_user(
    prompto_id: Annotated[str, Cookie()] = None,
    auth_service=Depends(Provide[Container.auth_service]),
) -> Session:
    if not prompto_id:
        raise HTTPException(status_code=401, detail="Unauthorized")

    session = await auth_service.lookup(prompto_id)

    if not session:
        raise HTTPException(status_code=401, detail="Unauthorized")

    return session


@router.get(
    "/auth/login",
    status_code=307,
    responses={307: {"description": "Redirect to Keycloak"}},
)
@inject
def login(state: str, config=Depends(Provide[Container.config])) -> RedirectResponse:
    # TODO Use the state variable of the client
    # TODO export URLS
    params = {
        "response_type": "code",
        "scope": "openid email profile",
        "client_id": "prompto",
        "redirect_uri": config["oidc"]["redirect_url"],
        "state": state,
        "nonce": "123123",  # TODO implement using nonce [CURSOR]
    }
    auth_server_url = config["oidc"]["auth_url"] + "?" + urlencode(params)
    return RedirectResponse(url=auth_server_url)


@router.get(
    "/callback"
)  # Required for localhost testing since keycloak has /callback for localhost
@router.get(
    "/auth/callback",
    status_code=302,
    responses={
        307: {"description": "Redirect to Prompto"},
        400: {"description": "Bad request"},
    },
)
@inject
async def callback(
    code: str,
    config=Depends(Provide[Container.config]),
    auth_service=Depends(Provide[Container.auth_service]),
    signing_key=Depends(Provide[Container.signing_key]),
):
    headers = {"Content-Type": "application/x-www-form-urlencoded"}
    body = {
        "code": code,
        "client_id": config["oidc"]["client_id"],
        "client_secret": config["oidc"]["client_secret"],
        "redirect_uri": config["oidc"]["redirect_url"],
        "grant_type": "authorization_code",
    }

    idp_response = requests.post(
        url=config["oidc"]["token_url"],
        data=body,
        headers=headers,
    )
    idp_response.raise_for_status()

    tokens = idp_response.json()
    id_token = tokens["id_token"]

    # TODO add try catch
    token_information = decode(
        id_token,
        signing_key,
        algorithms=["RS512"],
        audience="prompto",
        issuer=config["oidc"]["url"].rstrip("/"),
    )
    log.info("Successful login for user %s", token_information["preferred_username"])
    session = Session(
        uuid=uuid.uuid4(),
        username=token_information["preferred_username"],
        email=token_information["email"],
        expires=int(
            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()
        ),
    )
    await auth_service.save(session)
    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie
    client_redirect_url = config["oidc"]["client_redirect_url"]
    hostname = urlparse(config["app"]["host_url"]).hostname
    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}
    return RedirectResponse(
        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers
    )


class WhoamiResponse(BaseModel):
    username: str
    expires: int


@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})
def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:
    return WhoamiResponse(username=session.username, expires=session.expires)


class LogoutResponse(BaseModel):
    message: str = "Logout successful"


@router.post(
    path="/auth/logout",
    responses={401: {"description": "Unauthorized"}},
)
@inject
async def logout(
    session: Annotated[Session, Depends(current_user)],
    auth_service=Depends(Provide[Container.auth_service]),
) -> LogoutResponse:
    await auth_service.clear(session)
    return LogoutResponse()


@router.get(
    path="/auth/success",
    responses={401: {"description": "Unauthorized"}},
)
@inject
async def success_page(
    session: Annotated[Session, Depends(current_user)],
    auth_service=Depends(Provide[Container.auth_service]),
) -> FileResponse:
    return FileResponse("templates/redirect_page.html")