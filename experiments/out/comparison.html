<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>filename</th>
      <th>model_name</th>
      <th>index</th>
      <th>query</th>
      <th>found_snippet</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>translation_api</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def app(request: Request) -> Response:<br>        try:<br>            body: Any = None<br>            if body_field:<br>                if is_body_form:<br>                    body = await request.form()<br>                    stack = request.scope.get("fastapi_astack")<br>                    assert isinstance(stack, AsyncExitStack)<br>                    stack.push_async_callback(body.close)<br>                else:<br>                    body_bytes = await request.body()<br>                    if body_bytes:<br>                        json_body: Any = Undefined<br>                        content_type_value = request.headers.get("content-type")<br>                        if not content_type_value:<br>                            json_body = await request.json()<br>                        else:<br>                            message = email.message.Message()<br>                            message["content-type"] = content_type_value<br>                            if message.get_content_maintype() == "application":<br>                                subtype = message.get_content_subtype()<br>                                if subtype == "json" or subtype.endswith("+json"):<br>                                    json_body = await request.json()<br>                        if json_body != Undefined:<br>                            body = json_body<br>                        else:<br>                            body = body_bytes<br>        except json.JSONDecodeError as e:<br>            raise RequestValidationError(<br>                [<br>                    {<br>                        "type": "json_invalid",<br>                        "loc": ("body", e.pos),<br>                        "msg": "JSON decode error",<br>                        "input": {},<br>                        "ctx": {"error": e.msg},<br>                    }<br>                ],<br>                body=e.doc,<br>            ) from e<br>        except HTTPException:<br>            raise<br>        except Exception as e:<br>            raise HTTPException(<br>                status_code=400, detail="There was an error pa</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">        async def route(request: Request, data: self.schema):  # type:ignore<br>            return await self.handle(request, data)  # type:ignore</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.where import tutorial010 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(mod.sqlite_url)<br>    calls = []<br><br>    new_print = get_testing_print_function(calls)<br><br>    with patch("builtins.print", new=new_print):<br>        mod.main()<br>    assert calls == [<br>        [{"name": "Tarantula", "secret_name": "Natalia Roman-on", "age": 32, "id": 4}],<br>        [{"name": "Black Lion", "secret_name": "Trevor Challa", "age": 35, "id": 5}],<br>        [<br>            {<br>                "name": "Captain North America",<br>                "secret_name": "Esteban Rogelios",<br>                "age": 93,<br>                "id": 7,<br>            }<br>        ],<br>    ]</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def index(request: Request):<br>    return templates.TemplateResponse(<br>        "/whiteboard/index.html", {"request": request, "id": 1}<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get(<br>    "/items/{item_id}",<br>    response_model=Item,<br>    responses={<br>        404: {"model": Message, "description": "The item was not found"},<br>        200: {<br>            "description": "Item requested by ID",<br>            "content": {<br>                "application/json": {<br>                    "example": {"id": "bar", "value": "The bar tenders"}<br>                }<br>            },<br>        },<br>    },<br>)<br>async def read_item(item_id: str):<br>    if item_id == "foo":<br>        return {"id": "foo", "value": "there goes my hero"}<br>    else:<br>        return JSONResponse(status_code=404, content={"message": "Item not found"})</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/heroes/", response_model=HeroRead)<br>def create_hero(*, session: Session = Depends(get_session), hero: HeroCreate):<br>    db_hero = Hero.model_validate(hero)<br>    session.add(db_hero)<br>    session.commit()<br>    session.refresh(db_hero)<br>    return db_hero</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@pytest.mark.parametrize(<br>    "path,expected_status,expected_response",<br>    [<br>        ("/health/test_1_plus_1/2", 200, {"result": True}),<br>        ("/health/test/1_plus_1_2", 200, {"result": True}),<br>        ("/health/test/1_plus/_1_2", 404, None),<br>    ],<br>)<br>def test_get_path(health_client, path, expected_status, expected_response):<br>    resp = health_client.get(path)<br>    assert resp.status_code == expected_status<br>    if resp.status_code == 200:<br>        assert resp.json() == expected_response</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/healthcheck", include_in_schema=False)<br>async def healthcheck() -> dict[str, str]:<br>    return {"status": "ok"}</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:  # CURSOR<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def test_schema_list(app: FastAPI, async_client: AsyncClient, fake_users, models):<br>    class UserList(BaseModel):<br>        id: int<br>        username: str<br><br>    class UserCrud(SqlalchemyCrud):<br>        router_prefix = "/user"<br>        schema_list = UserList<br><br>    ins = UserCrud(models.User, db.engine).register_crud()<br><br>    app.include_router(ins.router)<br><br>    # test schemas<br>    openapi = app.openapi()<br>    schemas = openapi["components"]["schemas"]<br>    assert "password" not in schemas["UserList"]["properties"]<br>    assert "username" in schemas["UserList"]["properties"]<br><br>    # test api<br>    res = await async_client.post("/user/list", json={"id": 1})<br>    items = res.json()["data"]["items"]<br>    assert items[0]["id"] == 1<br>    assert "username" in items[0]<br>    assert "password" not in items[0]</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:  # CURSOR<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users/{user_id}", response_model=schemas.User)<br>def read_user(user_id: int, db: Session = Depends(get_db)):<br>    db_user = crud.get_user(db, user_id=user_id)<br>    if db_user is None:<br>        raise HTTPException(status_code=404, detail="User not found")<br>    return db_user</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/refresh-token", response_model=AccessTokenResponse)<br>async def refresh_token(<br>    input: RefreshTokenRequest,<br>    session: AsyncSession = Depends(deps.get_session),<br>):<br>    """OAuth2 compatible token, get an access token for future requests using refresh token"""<br>    try:<br>        payload = jwt.decode(<br>            input.refresh_token,<br>            config.settings.SECRET_KEY,<br>            algorithms=[security.JWT_ALGORITHM],<br>        )<br>    except (jwt.DecodeError, ValidationError):<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, unknown error",<br>        )<br><br>    # JWT guarantees payload will be unchanged (and thus valid), no errors here<br>    token_data = security.JWTTokenPayload(**payload)<br><br>    if not token_data.refresh:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, cannot use access token",<br>        )<br>    now = int(time.time())<br>    if now < token_data.issued_at or now > token_data.expires_at:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, token expired or not yet valid",<br>        )<br><br>    result = await session.execute(select(User).where(User.id == token_data.sub))<br>    user = result.scalars().first()<br><br>    if user is None:<br>        raise HTTPException(status_code=404, detail="User not found")<br><br>    return security.generate_access_token_response(str(user.id))</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        authorization = request.headers.get("Authorization")<br>        if not authorization:<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        return authorization</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.fastapi.simple_hero_api import tutorial001_py310 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(<br>        mod.sqlite_url, connect_args=mod.connect_args, poolclass=StaticPool<br>    )<br><br>    with TestClient(mod.app) as client:<br>        hero1_data = {"name": "Deadpond", "secret_name": "Dive Wilson"}<br>        hero2_data = {<br>            "name": "Spider-Boy",<br>            "secret_name": "Pedro Parqueador",<br>            "id": 9000,<br>        }<br>        response = client.post("/heroes/", json=hero1_data)<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert data["name"] == hero1_data["name"]<br>        assert data["secret_name"] == hero1_data["secret_name"]<br>        assert data["id"] is not None<br>        assert data["age"] is None<br><br>        response = client.post("/heroes/", json=hero2_data)<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert data["name"] == hero2_data["name"]<br>        assert data["secret_name"] == hero2_data["secret_name"]<br>        assert data["id"] == hero2_data["id"], (<br>            "Up to this point it's still possible to "<br>            "set the ID of the hero in the request"<br>        )<br>        assert data["age"] is None<br><br>        response = client.get("/heroes/")<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert len(data) == 2<br>        assert data[0]["name"] == hero1_data["name"]<br>        assert data[0]["secret_name"] == hero1_data["secret_name"]<br>        assert data[1]["name"] == hero2_data["name"]<br>        assert data[1]["secret_name"] == hero2_data["secret_name"]<br>        assert data[1]["id"] == hero2_data["id"]<br><br>        response = client.get("/openapi.json")<br><br>        assert response.status_code == 200, response.text<br><br>        assert response.json() == {<br>            "openapi": "3.1.0",<br>            "info": {"title": "FastAPI", "version": </code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/", callbacks=callback_router.routes)<br>def main_route(callback_url: HttpUrl):<br>    pass  # pragma: no cover</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@group_web.command("whiteboard")<br>def start_whiteboard():<br>    uvicorn.run(<br>        "tifa.app:create_app",<br>        factory=True,<br>        reload=True,<br>        host="0.0.0.0",<br>        port=8001,<br>        log_level="info",<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    create_db_and_tables()<br>    create_heroes()</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/refresh-token", response_model=AccessTokenResponse)<br>async def refresh_token(<br>    input: RefreshTokenRequest,<br>    session: AsyncSession = Depends(deps.get_session),<br>):<br>    """OAuth2 compatible token, get an access token for future requests using refresh token"""<br>    try:<br>        payload = jwt.decode(<br>            input.refresh_token,<br>            config.settings.SECRET_KEY,<br>            algorithms=[security.JWT_ALGORITHM],<br>        )<br>    except (jwt.DecodeError, ValidationError):<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, unknown error",<br>        )<br><br>    # JWT guarantees payload will be unchanged (and thus valid), no errors here<br>    token_data = security.JWTTokenPayload(**payload)<br><br>    if not token_data.refresh:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, cannot use access token",<br>        )<br>    now = int(time.time())<br>    if now < token_data.issued_at or now > token_data.expires_at:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, token expired or not yet valid",<br>        )<br><br>    result = await session.execute(select(User).where(User.id == token_data.sub))<br>    user = result.scalars().first()<br><br>    if user is None:<br>        raise HTTPException(status_code=404, detail="User not found")<br><br>    return security.generate_access_token_response(str(user.id))</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        authorization = request.headers.get("Authorization")<br>        if not authorization:<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        return authorization</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    def openapi(self) -> Dict[str, Any]:<br>        """<br>        Generate the OpenAPI schema of the application. This is called by FastAPI<br>        internally.<br><br>        The first time it is called it stores the result in the attribute<br>        `app.openapi_schema`, and next times it is called, it just returns that same<br>        result. To avoid the cost of generating the schema every time.<br><br>        If you need to modify the generated OpenAPI schema, you could modify it.<br><br>        Read more in the<br>        [FastAPI docs for OpenAPI](https://fastapi.tiangolo.com/how-to/extending-openapi/).<br>        """<br>        if not self.openapi_schema:<br>            self.openapi_schema = get_openapi(<br>                title=self.title,<br>                version=self.version,<br>                openapi_version=self.openapi_version,<br>                summary=self.summary,<br>                description=self.description,<br>                terms_of_service=self.terms_of_service,<br>                contact=self.contact,<br>                license_info=self.license_info,<br>                routes=self.routes,<br>                webhooks=self.webhooks.routes,<br>                tags=self.openapi_tags,<br>                servers=self.servers,<br>                separate_input_output_schemas=self.separate_input_output_schemas,<br>            )<br>        return self.openapi_schema</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    create_db_and_tables()<br>    create_heroes()<br>    update_heroes()</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    def must_be_bob(credentials: security.HTTPBasicCredentials = Depends(http_basic)):<br>        if credentials.username == "bob":<br>            return True<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="You're not Bob",<br>            headers={"WWW-Authenticate": "Basic"},<br>        )</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users/me")<br>def read_current_user(username: Annotated[str, Depends(get_current_username)]):<br>    return {"username": username}</code></pre></div></td>
    </tr>
  </tbody>
</table>