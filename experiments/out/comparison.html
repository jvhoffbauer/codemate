<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>filename</th>
      <th>model_name</th>
      <th>index</th>
      <th>query</th>
      <th>found_snippet</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>translation_api</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def app(request: Request) -> Response:<br>        try:<br>            body: Any = None<br>            if body_field:<br>                if is_body_form:<br>                    body = await request.form()<br>                    stack = request.scope.get("fastapi_astack")<br>                    assert isinstance(stack, AsyncExitStack)<br>                    stack.push_async_callback(body.close)<br>                else:<br>                    body_bytes = await request.body()<br>                    if body_bytes:<br>                        json_body: Any = Undefined<br>                        content_type_value = request.headers.get("content-type")<br>                        if not content_type_value:<br>                            json_body = await request.json()<br>                        else:<br>                            message = email.message.Message()<br>                            message["content-type"] = content_type_value<br>                            if message.get_content_maintype() == "application":<br>                                subtype = message.get_content_subtype()<br>                                if subtype == "json" or subtype.endswith("+json"):<br>                                    json_body = await request.json()<br>                        if json_body != Undefined:<br>                            body = json_body<br>                        else:<br>                            body = body_bytes<br>        except json.JSONDecodeError as e:<br>            raise RequestValidationError(<br>                [<br>                    {<br>                        "type": "json_invalid",<br>                        "loc": ("body", e.pos),<br>                        "msg": "JSON decode error",<br>                        "input": {},<br>                        "ctx": {"error": e.msg},<br>                    }<br>                ],<br>                body=e.doc,<br>            ) from e<br>        except HTTPException:<br>            raise<br>        except Exception as e:<br>            raise HTTPException(<br>                status_code=400, detail="There was an error pa</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">        async def route(request: Request, data: self.schema):  # type:ignore<br>            return await self.handle(request, data)  # type:ignore</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>e5_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    def extract_entities(self, records: List[Dict[str, str]]):<br>        """Apply the pre-trained model to a batch of records<br><br>        records (list): The list of "document" dictionaries each with an<br>            `id` and `text` property<br><br>        RETURNS (list): List of responses containing the id of<br>            the correlating document and a list of entities.<br>        """<br>        ids = (doc[self.input_id_col] for doc in records)<br>        texts = (doc[self.input_text_col] for doc in records)<br><br>        res = []<br><br>        for doc_id, spacy_doc in zip(ids, self.nlp.pipe(texts)):<br>            entities = {}<br>            for ent in spacy_doc.ents:<br>                ent_id = ent.kb_id<br>                if not ent_id:<br>                    ent_id = ent.ent_id<br>                if not ent_id:<br>                    ent_id = self._name_to_id(ent.text)<br><br>                if ent_id not in entities:<br>                    if ent.text.lower() == ent.text:<br>                        ent_name = ent.text.capitalize()<br>                    else:<br>                        ent_name = ent.text<br>                    entities[ent_id] = {<br>                        "name": ent_name,<br>                        "label": ent.label_,<br>                        "matches": [],<br>                    }<br>                entities[ent_id]["matches"].append(<br>                    {"start": ent.start_char, "end": ent.end_char, "text": ent.text}<br>                )<br><br>            res.append({"id": doc_id, "entities": list(entities.values())})<br>        return res</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.where import tutorial010 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(mod.sqlite_url)<br>    calls = []<br><br>    new_print = get_testing_print_function(calls)<br><br>    with patch("builtins.print", new=new_print):<br>        mod.main()<br>    assert calls == [<br>        [{"name": "Tarantula", "secret_name": "Natalia Roman-on", "age": 32, "id": 4}],<br>        [{"name": "Black Lion", "secret_name": "Trevor Challa", "age": 35, "id": 5}],<br>        [<br>            {<br>                "name": "Captain North America",<br>                "secret_name": "Esteban Rogelios",<br>                "age": 93,<br>                "id": 7,<br>            }<br>        ],<br>    ]</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def index(request: Request):<br>    return templates.TemplateResponse(<br>        "/whiteboard/index.html", {"request": request, "id": 1}<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>e5_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_call_api():<br>    app = create_app()<br>    client = TestClient(app)<br>    response = client.post("/schema_extra/", json={"data": "Foo"})<br>    assert response.status_code == 200, response.text<br>    response = client.post("/example/", json={"data": "Foo"})<br>    assert response.status_code == 200, response.text<br>    response = client.post("/examples/", json={"data": "Foo"})<br>    assert response.status_code == 200, response.text<br>    response = client.post("/example_examples/", json={"data": "Foo"})<br>    assert response.status_code == 200, response.text<br>    response = client.get("/path_example/foo")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/path_examples/foo")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/path_example_examples/foo")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/query_example/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/query_examples/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/query_example_examples/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/header_example/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/header_examples/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/header_example_examples/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/cookie_example/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/cookie_examples/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/cookie_example_examples/")<br>    assert response.status_code == 200, response.text</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get(<br>    "/items/{item_id}",<br>    response_model=Item,<br>    responses={<br>        404: {"model": Message, "description": "The item was not found"},<br>        200: {<br>            "description": "Item requested by ID",<br>            "content": {<br>                "application/json": {<br>                    "example": {"id": "bar", "value": "The bar tenders"}<br>                }<br>            },<br>        },<br>    },<br>)<br>async def read_item(item_id: str):<br>    if item_id == "foo":<br>        return {"id": "foo", "value": "there goes my hero"}<br>    else:<br>        return JSONResponse(status_code=404, content={"message": "Item not found"})</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.put("/{user_id}/", response_model=UserOut, dependencies=[Depends(on_superuser)])<br>async def update_user(<br>    user_id: int, user_in: UserUpdate, session: AsyncSession = Depends(get_session)<br>):<br>    user = await crud_user.get(session, id=user_id)<br>    if user is None:<br>        raise HTTPException(<br>            status_code=404,<br>            detail="The user with this username does not exist in the system",<br>        )<br>    try:<br>        user = await crud_user.update(<br>            session,<br>            db_obj=user,<br>            obj_in={<br>                **user_in.dict(exclude={"password"}, exclude_none=True),<br>                "hashed_password": get_password_hash(user_in.password),<br>            },<br>        )<br>    except IntegrityError:<br>        raise HTTPException(<br>            status_code=409, detail="User with this username already exits"<br>        )<br>    return user</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>e5_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    def create(self, db: Session, *, obj_in: CreateSchemaType) -> ModelType:<br>        obj_in_data = jsonable_encoder(obj_in)<br>        db_obj = self.model(**obj_in_data)  # type: ignore<br>        db.add(db_obj)<br>        db.commit()<br>        db.refresh(db_obj)<br>        return db_obj</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@pytest.mark.parametrize(<br>    "path,expected_status,expected_response",<br>    [<br>        ("/health/test_1_plus_1/2", 200, {"result": True}),<br>        ("/health/test/1_plus_1_2", 200, {"result": True}),<br>        ("/health/test/1_plus/_1_2", 404, None),<br>    ],<br>)<br>def test_get_path(health_client, path, expected_status, expected_response):<br>    resp = health_client.get(path)<br>    assert resp.status_code == expected_status<br>    if resp.status_code == 200:<br>        assert resp.json() == expected_response</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/healthcheck", include_in_schema=False)<br>async def healthcheck() -> dict[str, str]:<br>    return {"status": "ok"}</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>e5_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/access-token", response_model=schemas.Token)<br>def login_access_token(<br>    db: Session = Depends(deps.get_db), form_data: OAuth2PasswordRequestForm = Depends()<br>):<br>    """OAuth2 compatible token login, get an access token for future requests."""<br>    user = crud.user.authenticate(<br>        db, email=form_data.username, password=form_data.password<br>    )<br>    if not user:<br>        raise HTTPException(<br>            status_code=status.HTTP_400_BAD_REQUEST,<br>            detail="Incorrect email or password.",<br>        )<br>    elif not crud.user.is_active(user):<br>        raise HTTPException(<br>            status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user."<br>        )<br>    return {<br>        "access_token": security.create_access_token(str(user.id)),<br>        "token_type": "bearer",<br>    }</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:  # CURSOR<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def test_schema_list(app: FastAPI, async_client: AsyncClient, fake_users, models):<br>    class UserList(BaseModel):<br>        id: int<br>        username: str<br><br>    class UserCrud(SqlalchemyCrud):<br>        router_prefix = "/user"<br>        schema_list = UserList<br><br>    ins = UserCrud(models.User, db.engine).register_crud()<br><br>    app.include_router(ins.router)<br><br>    # test schemas<br>    openapi = app.openapi()<br>    schemas = openapi["components"]["schemas"]<br>    assert "password" not in schemas["UserList"]["properties"]<br>    assert "username" in schemas["UserList"]["properties"]<br><br>    # test api<br>    res = await async_client.post("/user/list", json={"id": 1})<br>    items = res.json()["data"]["items"]<br>    assert items[0]["id"] == 1<br>    assert "username" in items[0]<br>    assert "password" not in items[0]</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:  # CURSOR<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users/{user_id}", response_model=schemas.User)<br>def read_user(user_id: int, db: Session = Depends(get_db)):<br>    db_user = crud.get_user(db, user_id=user_id)<br>    if db_user is None:<br>        raise HTTPException(status_code=404, detail="User not found")<br>    return db_user</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>e5_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:  # CURSOR<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/jobs/once", summary="获取指定的job信息", name="获取指定定时任务")<br>async def get_target_sync(job_id: str = Query(..., title="任务id")):<br>    job = schedule.get_job(job_id=job_id)<br><br>    if not job:<br>        return resp.fail(resp.DataNotFound.set_msg(f"not found job {job_id}"))<br><br>    return resp.ok(<br>        data={<br>            "job_id": job.id,<br>            "func_name": job.func_ref,<br>            "func_args": job.args,<br>            "cron_model": str(job.trigger),<br>            "next_run": str(job.next_run_time),<br>        }<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/refresh-token", response_model=AccessTokenResponse)<br>async def refresh_token(<br>    input: RefreshTokenRequest,<br>    session: AsyncSession = Depends(deps.get_session),<br>):<br>    """OAuth2 compatible token, get an access token for future requests using refresh token"""<br>    try:<br>        payload = jwt.decode(<br>            input.refresh_token,<br>            config.settings.SECRET_KEY,<br>            algorithms=[security.JWT_ALGORITHM],<br>        )<br>    except (jwt.DecodeError, ValidationError):<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, unknown error",<br>        )<br><br>    # JWT guarantees payload will be unchanged (and thus valid), no errors here<br>    token_data = security.JWTTokenPayload(**payload)<br><br>    if not token_data.refresh:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, cannot use access token",<br>        )<br>    now = int(time.time())<br>    if now < token_data.issued_at or now > token_data.expires_at:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, token expired or not yet valid",<br>        )<br><br>    result = await session.execute(select(User).where(User.id == token_data.sub))<br>    user = result.scalars().first()<br><br>    if user is None:<br>        raise HTTPException(status_code=404, detail="User not found")<br><br>    return security.generate_access_token_response(str(user.id))</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        authorization = request.headers.get("Authorization")<br>        if not authorization:<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        return authorization</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>e5_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def read_current_user(current_user: User = Depends(get_current_user)):<br>    return current_user</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.fastapi.simple_hero_api import tutorial001_py310 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(<br>        mod.sqlite_url, connect_args=mod.connect_args, poolclass=StaticPool<br>    )<br><br>    with TestClient(mod.app) as client:<br>        hero1_data = {"name": "Deadpond", "secret_name": "Dive Wilson"}<br>        hero2_data = {<br>            "name": "Spider-Boy",<br>            "secret_name": "Pedro Parqueador",<br>            "id": 9000,<br>        }<br>        response = client.post("/heroes/", json=hero1_data)<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert data["name"] == hero1_data["name"]<br>        assert data["secret_name"] == hero1_data["secret_name"]<br>        assert data["id"] is not None<br>        assert data["age"] is None<br><br>        response = client.post("/heroes/", json=hero2_data)<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert data["name"] == hero2_data["name"]<br>        assert data["secret_name"] == hero2_data["secret_name"]<br>        assert data["id"] == hero2_data["id"], (<br>            "Up to this point it's still possible to "<br>            "set the ID of the hero in the request"<br>        )<br>        assert data["age"] is None<br><br>        response = client.get("/heroes/")<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert len(data) == 2<br>        assert data[0]["name"] == hero1_data["name"]<br>        assert data[0]["secret_name"] == hero1_data["secret_name"]<br>        assert data[1]["name"] == hero2_data["name"]<br>        assert data[1]["secret_name"] == hero2_data["secret_name"]<br>        assert data[1]["id"] == hero2_data["id"]<br><br>        response = client.get("/openapi.json")<br><br>        assert response.status_code == 200, response.text<br><br>        assert response.json() == {<br>            "openapi": "3.1.0",<br>            "info": {"title": "FastAPI", "version": </code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/", callbacks=callback_router.routes)<br>def main_route(callback_url: HttpUrl):<br>    pass  # pragma: no cover</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>e5_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_call_api():<br>    app = create_app()<br>    client = TestClient(app)<br>    response = client.post("/schema_extra/", json={"data": "Foo"})<br>    assert response.status_code == 200, response.text<br>    response = client.post("/example/", json={"data": "Foo"})<br>    assert response.status_code == 200, response.text<br>    response = client.post("/examples/", json={"data": "Foo"})<br>    assert response.status_code == 200, response.text<br>    response = client.post("/example_examples/", json={"data": "Foo"})<br>    assert response.status_code == 200, response.text<br>    response = client.get("/path_example/foo")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/path_examples/foo")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/path_example_examples/foo")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/query_example/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/query_examples/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/query_example_examples/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/header_example/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/header_examples/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/header_example_examples/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/cookie_example/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/cookie_examples/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/cookie_example_examples/")<br>    assert response.status_code == 200, response.text</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@group_web.command("whiteboard")<br>def start_whiteboard():<br>    uvicorn.run(<br>        "tifa.app:create_app",<br>        factory=True,<br>        reload=True,<br>        host="0.0.0.0",<br>        port=8001,<br>        log_level="info",<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    create_db_and_tables()<br>    create_heroes()</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>e5_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.command()<br>def serve() -> None:<br>    """<br>    A quick server to preview a built site with translations.<br><br>    For development, prefer the command live (or just mkdocs serve).<br><br>    This is here only to preview a site with translations already built.<br><br>    Make sure you run the build-all command first.<br>    """<br>    typer.echo("Warning: this is a very simple server.")<br>    typer.echo("For development, use the command live instead.")<br>    typer.echo("This is here only to preview a site with translations already built.")<br>    typer.echo("Make sure you run the build-all command first.")<br>    os.chdir("site")<br>    server_address = ("", 8008)<br>    server = HTTPServer(server_address, SimpleHTTPRequestHandler)<br>    typer.echo("Serving at: http://127.0.0.1:8008")<br>    server.serve_forever()</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/refresh-token", response_model=AccessTokenResponse)<br>async def refresh_token(<br>    input: RefreshTokenRequest,<br>    session: AsyncSession = Depends(deps.get_session),<br>):<br>    """OAuth2 compatible token, get an access token for future requests using refresh token"""<br>    try:<br>        payload = jwt.decode(<br>            input.refresh_token,<br>            config.settings.SECRET_KEY,<br>            algorithms=[security.JWT_ALGORITHM],<br>        )<br>    except (jwt.DecodeError, ValidationError):<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, unknown error",<br>        )<br><br>    # JWT guarantees payload will be unchanged (and thus valid), no errors here<br>    token_data = security.JWTTokenPayload(**payload)<br><br>    if not token_data.refresh:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, cannot use access token",<br>        )<br>    now = int(time.time())<br>    if now < token_data.issued_at or now > token_data.expires_at:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, token expired or not yet valid",<br>        )<br><br>    result = await session.execute(select(User).where(User.id == token_data.sub))<br>    user = result.scalars().first()<br><br>    if user is None:<br>        raise HTTPException(status_code=404, detail="User not found")<br><br>    return security.generate_access_token_response(str(user.id))</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        authorization = request.headers.get("Authorization")<br>        if not authorization:<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        return authorization</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>e5_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    def register_router(self):<br>        if not self.__register_lock:<br>            super(AdminApp, self).register_router()<br>            self._create_admin_instance_all()<br>            self._register_admin_router_all_pre()<br>            self._register_admin_router_all()<br>            self.__register_lock = True<br>        return self</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    def openapi(self) -> Dict[str, Any]:<br>        """<br>        Generate the OpenAPI schema of the application. This is called by FastAPI<br>        internally.<br><br>        The first time it is called it stores the result in the attribute<br>        `app.openapi_schema`, and next times it is called, it just returns that same<br>        result. To avoid the cost of generating the schema every time.<br><br>        If you need to modify the generated OpenAPI schema, you could modify it.<br><br>        Read more in the<br>        [FastAPI docs for OpenAPI](https://fastapi.tiangolo.com/how-to/extending-openapi/).<br>        """<br>        if not self.openapi_schema:<br>            self.openapi_schema = get_openapi(<br>                title=self.title,<br>                version=self.version,<br>                openapi_version=self.openapi_version,<br>                summary=self.summary,<br>                description=self.description,<br>                terms_of_service=self.terms_of_service,<br>                contact=self.contact,<br>                license_info=self.license_info,<br>                routes=self.routes,<br>                webhooks=self.webhooks.routes,<br>                tags=self.openapi_tags,<br>                servers=self.servers,<br>                separate_input_output_schemas=self.separate_input_output_schemas,<br>            )<br>        return self.openapi_schema</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    create_db_and_tables()<br>    create_heroes()<br>    update_heroes()</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>e5_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_call_api():<br>    app = create_app()<br>    client = TestClient(app)<br>    response = client.post("/schema_extra/", json={"data": "Foo"})<br>    assert response.status_code == 200, response.text<br>    response = client.post("/example/", json={"data": "Foo"})<br>    assert response.status_code == 200, response.text<br>    response = client.post("/examples/", json={"data": "Foo"})<br>    assert response.status_code == 200, response.text<br>    response = client.post("/example_examples/", json={"data": "Foo"})<br>    assert response.status_code == 200, response.text<br>    response = client.get("/path_example/foo")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/path_examples/foo")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/path_example_examples/foo")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/query_example/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/query_examples/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/query_example_examples/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/header_example/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/header_examples/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/header_example_examples/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/cookie_example/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/cookie_examples/")<br>    assert response.status_code == 200, response.text<br>    response = client.get("/cookie_example_examples/")<br>    assert response.status_code == 200, response.text</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>unixcoder_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def login(<br>    data: OAuth2PasswordRequestForm = Depends(),<br>    session: AsyncSession = Depends(get_session),<br>):<br>    user = await authenticate(session, email=data.username, password=data.password)<br>    if user is None:<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br>    if not user.is_active:<br>        raise HTTPException(status_code=400, detail="Inactive user")<br>    return {"access_token": create_access_token(user), "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>openai_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users/me")<br>def read_current_user(username: Annotated[str, Depends(get_current_username)]):<br>    return {"username": username}</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>e5_code_splitter</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users/{user_id}", response_model=schemas.User)<br>def read_user(user_id: int, db: Session = Depends(get_db)):<br>    db_user = crud.get_user(db, user_id=user_id)<br>    if db_user is None:<br>        raise HTTPException(status_code=404, detail="User not found")<br>    return db_user</code></pre></div></td>
    </tr>
  </tbody>
</table>