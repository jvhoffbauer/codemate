<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>filename</th>
      <th>model_name</th>
      <th>index</th>
      <th>query_description</th>
      <th>query</th>
      <th>found_snippet</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>add_post</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function is a FastAPI route with an HTTP GET request method and a path parameter `{post_id:int}`. - It retrieves a specific blog post from a database using the `fetch_post()` asynchronous function and passes it to the view context. - The view context is created by calling `get_context()`, which takes in the current request object (`Request`) and the fetched blog post (`post`). - Finally, the function returns an HTML response generated by rendering the "post.html" template using the `templates.TemplateResponse()` function.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/post/{post_id:int}", response_class=HTMLResponse)<br>async def post(request: Request, post_id: int):<br>    post = await fetch_post(post_id)<br>    context = get_context(request, post=post)<br>    return templates.TemplateResponse("post.html", context)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/items/{id}", response_class=HTMLResponse)<br>async def read_item(request: Request, id: str):<br>    return templates.TemplateResponse("item.html", {"request": request, "id": id})</code></pre></div></td>
    </tr>
    <tr>
      <td>add_post</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function is a FastAPI route with an HTTP GET request method and a path parameter `{post_id:int}`. - It retrieves a specific blog post from a database using the `fetch_post()` asynchronous function and passes it to the view context. - The view context is created by calling `get_context()`, which takes in the current request object (`Request`) and the fetched blog post (`post`). - Finally, the function returns an HTML response generated by rendering the "post.html" template using the `templates.TemplateResponse()` function.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/post/{post_id:int}", response_class=HTMLResponse)<br>async def post(request: Request, post_id: int):<br>    post = await fetch_post(post_id)<br>    context = get_context(request, post=post)<br>    return templates.TemplateResponse("post.html", context)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@bp.get("/", response_class=HTMLResponse)<br>async def index(request: Request):<br>    return templates.TemplateResponse(<br>        "/whiteboard/index.html", {"request": request, "id": 1}<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>add_post</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function is a FastAPI route with an HTTP GET request method and a path parameter `{post_id:int}`. - It retrieves a specific blog post from a database using the `fetch_post()` asynchronous function and passes it to the view context. - The view context is created by calling `get_context()`, which takes in the current request object (`Request`) and the fetched blog post (`post`). - Finally, the function returns an HTML response generated by rendering the "post.html" template using the `templates.TemplateResponse()` function.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/post/{post_id:int}", response_class=HTMLResponse)<br>async def post(request: Request, post_id: int):<br>    post = await fetch_post(post_id)<br>    context = get_context(request, post=post)<br>    return templates.TemplateResponse("post.html", context)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def read_item(request: Request, id: str):<br>    return templates.TemplateResponse("item.html", {"request": request, "id": id})</code></pre></div></td>
    </tr>
    <tr>
      <td>add_post</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function is a FastAPI route with an HTTP GET request method and a path parameter `{post_id:int}`. - It retrieves a specific blog post from a database using the `fetch_post()` asynchronous function and passes it to the view context. - The view context is created by calling `get_context()`, which takes in the current request object (`Request`) and the fetched blog post (`post`). - Finally, the function returns an HTML response generated by rendering the "post.html" template using the `templates.TemplateResponse()` function.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/post/{post_id:int}", response_class=HTMLResponse)<br>async def post(request: Request, post_id: int):<br>    post = await fetch_post(post_id)<br>    context = get_context(request, post=post)<br>    return templates.TemplateResponse("post.html", context)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/users/{id}", tags=["Users"], response_model=User)<br>async def retrieve_user(id: int):<br>    user: ORMUser = await ORMUser.get(id)<br>    return User.from_orm(user)</code></pre></div></td>
    </tr>
    <tr>
      <td>add_post</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function is a FastAPI route with an HTTP GET request method and a path parameter `{post_id:int}`. - It retrieves a specific blog post from a database using the `fetch_post()` asynchronous function and passes it to the view context. - The view context is created by calling `get_context()`, which takes in the current request object (`Request`) and the fetched blog post (`post`). - Finally, the function returns an HTML response generated by rendering the "post.html" template using the `templates.TemplateResponse()` function.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/post/{post_id:int}", response_class=HTMLResponse)<br>async def post(request: Request, post_id: int):<br>    post = await fetch_post(post_id)<br>    context = get_context(request, post=post)<br>    return templates.TemplateResponse("post.html", context)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def handle_http_request(self, http_request: Request):<br>        background_tasks = BackgroundTasks()<br><br>        sub_response = Response()<br>        del sub_response.headers["content-length"]<br>        sub_response.status_code = None  # type: ignore<br><br>        try:<br>            body = await self.parse_body(http_request)<br>        except Exception as exc:<br>            resp = await self.entrypoint.handle_exception_to_resp(exc)<br>            response = self.response_class(content=resp, background=background_tasks)<br>        else:<br>            try:<br>                resp = await self.handle_body(<br>                    http_request, background_tasks, sub_response, body<br>                )<br>            except NoContent:<br>                # no content for successful notifications<br>                response = Response(<br>                    media_type="application/json", background=background_tasks<br>                )<br>            else:<br>                response = self.response_class(<br>                    content=resp, background=background_tasks<br>                )<br><br>        response.headers.raw.extend(sub_response.headers.raw)<br>        if sub_response.status_code:<br>            response.status_code = sub_response.status_code<br><br>        return response</code></pre></div></td>
    </tr>
    <tr>
      <td>add_post</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function is a FastAPI route with an HTTP GET request method and a path parameter `{post_id:int}`. - It retrieves a specific blog post from a database using the `fetch_post()` asynchronous function and passes it to the view context. - The view context is created by calling `get_context()`, which takes in the current request object (`Request`) and the fetched blog post (`post`). - Finally, the function returns an HTML response generated by rendering the "post.html" template using the `templates.TemplateResponse()` function.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/post/{post_id:int}", response_class=HTMLResponse)<br>async def post(request: Request, post_id: int):<br>    post = await fetch_post(post_id)<br>    context = get_context(request, post=post)<br>    return templates.TemplateResponse("post.html", context)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users/{user_id}")<br>async def get_user(user_id: str, request: Request):<br>    route: APIRoute = request.scope["route"]<br>    return {"user_id": user_id, "path": route.path}</code></pre></div></td>
    </tr>
    <tr>
      <td>add_post</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function is a FastAPI route with an HTTP GET request method and a path parameter `{post_id:int}`. - It retrieves a specific blog post from a database using the `fetch_post()` asynchronous function and passes it to the view context. - The view context is created by calling `get_context()`, which takes in the current request object (`Request`) and the fetched blog post (`post`). - Finally, the function returns an HTML response generated by rendering the "post.html" template using the `templates.TemplateResponse()` function.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/post/{post_id:int}", response_class=HTMLResponse)<br>async def post(request: Request, post_id: int):<br>    post = await fetch_post(post_id)<br>    context = get_context(request, post=post)<br>    return templates.TemplateResponse("post.html", context)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/items/{id}", response_class=HTMLResponse)<br>async def read_item(request: Request, id: str):<br>    return templates.TemplateResponse("item.html", {"request": request, "id": id})</code></pre></div></td>
    </tr>
    <tr>
      <td>add_post</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function is a FastAPI route with an HTTP GET request method and a path parameter `{post_id:int}`. - It retrieves a specific blog post from a database using the `fetch_post()` asynchronous function and passes it to the view context. - The view context is created by calling `get_context()`, which takes in the current request object (`Request`) and the fetched blog post (`post`). - Finally, the function returns an HTML response generated by rendering the "post.html" template using the `templates.TemplateResponse()` function.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/post/{post_id:int}", response_class=HTMLResponse)<br>async def post(request: Request, post_id: int):<br>    post = await fetch_post(post_id)<br>    context = get_context(request, post=post)<br>    return templates.TemplateResponse("post.html", context)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@bp.get("/", response_class=HTMLResponse)<br>async def index(request: Request):<br>    return templates.TemplateResponse(<br>        "/whiteboard/index.html", {"request": request, "id": 1}<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>add_post</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function is a FastAPI route with an HTTP GET request method and a path parameter `{post_id:int}`. - It retrieves a specific blog post from a database using the `fetch_post()` asynchronous function and passes it to the view context. - The view context is created by calling `get_context()`, which takes in the current request object (`Request`) and the fetched blog post (`post`). - Finally, the function returns an HTML response generated by rendering the "post.html" template using the `templates.TemplateResponse()` function.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/post/{post_id:int}", response_class=HTMLResponse)<br>async def post(request: Request, post_id: int):<br>    post = await fetch_post(post_id)<br>    context = get_context(request, post=post)<br>    return templates.TemplateResponse("post.html", context)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/heroes/{hero_id}", response_model=HeroRead)<br>def read_hero(hero_id: int):<br>    with Session(engine) as session:<br>        hero = session.get(Hero, hero_id)<br>        if not hero:<br>            raise HTTPException(status_code=404, detail="Hero not found")<br>        return hero</code></pre></div></td>
    </tr>
    <tr>
      <td>startup</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a function called `startup` that is triggered when the application starts up using FastAPI's event system (`@app.on_event`) with the "startup" event as an argument. - Inside this function, it connects to the database using the `database.connect()` method provided by SQLAlchemy. - It checks whether the environment variable `INIT_DB` exists and has a value of true. If so, it calls two other functions `teardown_db()` and `init_db()`. These functions are not defined in this snippet but they might be used for initializing or resetting the database schema during development or testing phases.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.on_event("startup")<br>async def startup():<br>    await database.connect()<br>    if os.environ.get("INIT_DB"):<br>        await teardown_db()<br>        await init_db()</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.on_event("startup")<br>async def startup():<br>    await database.connect()</code></pre></div></td>
    </tr>
    <tr>
      <td>startup</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a function called `startup` that is triggered when the application starts up using FastAPI's event system (`@app.on_event`) with the "startup" event as an argument. - Inside this function, it connects to the database using the `database.connect()` method provided by SQLAlchemy. - It checks whether the environment variable `INIT_DB` exists and has a value of true. If so, it calls two other functions `teardown_db()` and `init_db()`. These functions are not defined in this snippet but they might be used for initializing or resetting the database schema during development or testing phases.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.on_event("startup")<br>async def startup():<br>    await database.connect()<br>    if os.environ.get("INIT_DB"):<br>        await teardown_db()<br>        await init_db()</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def startup():<br>    await database.connect()</code></pre></div></td>
    </tr>
    <tr>
      <td>startup</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a function called `startup` that is triggered when the application starts up using FastAPI's event system (`@app.on_event`) with the "startup" event as an argument. - Inside this function, it connects to the database using the `database.connect()` method provided by SQLAlchemy. - It checks whether the environment variable `INIT_DB` exists and has a value of true. If so, it calls two other functions `teardown_db()` and `init_db()`. These functions are not defined in this snippet but they might be used for initializing or resetting the database schema during development or testing phases.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.on_event("startup")<br>async def startup():<br>    await database.connect()<br>    if os.environ.get("INIT_DB"):<br>        await teardown_db()<br>        await init_db()</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.on_event("startup")<br>def on_startup():<br>    create_db_and_tables()</code></pre></div></td>
    </tr>
    <tr>
      <td>startup</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a function called `startup` that is triggered when the application starts up using FastAPI's event system (`@app.on_event`) with the "startup" event as an argument. - Inside this function, it connects to the database using the `database.connect()` method provided by SQLAlchemy. - It checks whether the environment variable `INIT_DB` exists and has a value of true. If so, it calls two other functions `teardown_db()` and `init_db()`. These functions are not defined in this snippet but they might be used for initializing or resetting the database schema during development or testing phases.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.on_event("startup")<br>async def startup():<br>    await database.connect()<br>    if os.environ.get("INIT_DB"):<br>        await teardown_db()<br>        await init_db()</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.on_event("startup")<br>async def startup():<br>    await database.connect()</code></pre></div></td>
    </tr>
    <tr>
      <td>startup</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a function called `startup` that is triggered when the application starts up using FastAPI's event system (`@app.on_event`) with the "startup" event as an argument. - Inside this function, it connects to the database using the `database.connect()` method provided by SQLAlchemy. - It checks whether the environment variable `INIT_DB` exists and has a value of true. If so, it calls two other functions `teardown_db()` and `init_db()`. These functions are not defined in this snippet but they might be used for initializing or resetting the database schema during development or testing phases.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.on_event("startup")<br>async def startup():<br>    await database.connect()<br>    if os.environ.get("INIT_DB"):<br>        await teardown_db()<br>        await init_db()</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.on_event("startup")<br>def on_startup():<br>    create_db_and_tables()</code></pre></div></td>
    </tr>
    <tr>
      <td>startup</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a function called `startup` that is triggered when the application starts up using FastAPI's event system (`@app.on_event`) with the "startup" event as an argument. - Inside this function, it connects to the database using the `database.connect()` method provided by SQLAlchemy. - It checks whether the environment variable `INIT_DB` exists and has a value of true. If so, it calls two other functions `teardown_db()` and `init_db()`. These functions are not defined in this snippet but they might be used for initializing or resetting the database schema during development or testing phases.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.on_event("startup")<br>async def startup():<br>    await database.connect()<br>    if os.environ.get("INIT_DB"):<br>        await teardown_db()<br>        await init_db()</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def startup():<br>    await database.connect()</code></pre></div></td>
    </tr>
    <tr>
      <td>startup</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a function called `startup` that is triggered when the application starts up using FastAPI's event system (`@app.on_event`) with the "startup" event as an argument. - Inside this function, it connects to the database using the `database.connect()` method provided by SQLAlchemy. - It checks whether the environment variable `INIT_DB` exists and has a value of true. If so, it calls two other functions `teardown_db()` and `init_db()`. These functions are not defined in this snippet but they might be used for initializing or resetting the database schema during development or testing phases.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.on_event("startup")<br>async def startup():<br>    await database.connect()<br>    if os.environ.get("INIT_DB"):<br>        await teardown_db()<br>        await init_db()</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.on_event("startup")<br>async def startup():<br>    await site.db.async_run_sync(SQLModel.metadata.create_all, is_session=False)</code></pre></div></td>
    </tr>
    <tr>
      <td>startup</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a function called `startup` that is triggered when the application starts up using FastAPI's event system (`@app.on_event`) with the "startup" event as an argument. - Inside this function, it connects to the database using the `database.connect()` method provided by SQLAlchemy. - It checks whether the environment variable `INIT_DB` exists and has a value of true. If so, it calls two other functions `teardown_db()` and `init_db()`. These functions are not defined in this snippet but they might be used for initializing or resetting the database schema during development or testing phases.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.on_event("startup")<br>async def startup():<br>    await database.connect()<br>    if os.environ.get("INIT_DB"):<br>        await teardown_db()<br>        await init_db()</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.on_event("startup")<br>async def startup():<br>    await database.connect()</code></pre></div></td>
    </tr>
    <tr>
      <td>startup</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a function called `startup` that is triggered when the application starts up using FastAPI's event system (`@app.on_event`) with the "startup" event as an argument. - Inside this function, it connects to the database using the `database.connect()` method provided by SQLAlchemy. - It checks whether the environment variable `INIT_DB` exists and has a value of true. If so, it calls two other functions `teardown_db()` and `init_db()`. These functions are not defined in this snippet but they might be used for initializing or resetting the database schema during development or testing phases.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.on_event("startup")<br>async def startup():<br>    await database.connect()<br>    if os.environ.get("INIT_DB"):<br>        await teardown_db()<br>        await init_db()</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def register_init(app: FastAPI) -> None:<br>    """<br>    初始化连接<br>    :param app:<br>    :return:<br>    """<br><br>    @app.on_event("startup")<br>    async def init_connect():<br>        # 连接redis<br>        redis_client.init_redis_connect()<br><br>        # 初始化 apscheduler<br>        schedule.init_scheduler()<br><br>        db.connect()<br><br>    @app.on_event("shutdown")<br>    async def shutdown_connect():<br>        """<br>        关闭<br>        :return:<br>        """<br>        schedule.shutdown()<br><br>        if not db.is_closed():<br>            db.close()</code></pre></div></td>
    </tr>
    <tr>
      <td>get_app</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `get_app` that returns an instance of FastAPI application. - Mounts a directory named "fastapi_blog/static" as static files under the URL path "/static". - Sets the name attribute to "static" for easy reference in templates and other views.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def get_app() -> FastAPI:<br>    app = FastAPI()<br>    app.mount("/static", StaticFiles(directory="fastapi_blog/static"), name="static")<br>    return app</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def setup_static_files(app: FastAPI):<br>    static_files_app = StaticFiles(directory=settings.STATIC_DIR)<br>    app.mount(path=settings.STATIC_PATH, app=static_files_app, name="static")</code></pre></div></td>
    </tr>
    <tr>
      <td>get_app</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `get_app` that returns an instance of FastAPI application. - Mounts a directory named "fastapi_blog/static" as static files under the URL path "/static". - Sets the name attribute to "static" for easy reference in templates and other views.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def get_app() -> FastAPI:<br>    app = FastAPI()<br>    app.mount("/static", StaticFiles(directory="fastapi_blog/static"), name="static")<br>    return app</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def get_app() -> FastAPI:<br>    fast_app = FastAPI(title=APP_NAME, version=APP_VERSION, debug=IS_DEBUG)<br>    fast_app.include_router(api_router, prefix=API_PREFIX)<br><br>    fast_app.add_event_handler("startup", start_app_handler(fast_app))<br>    fast_app.add_event_handler("shutdown", stop_app_handler(fast_app))<br><br>    return fast_app</code></pre></div></td>
    </tr>
    <tr>
      <td>get_app</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `get_app` that returns an instance of FastAPI application. - Mounts a directory named "fastapi_blog/static" as static files under the URL path "/static". - Sets the name attribute to "static" for easy reference in templates and other views.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def get_app() -> FastAPI:<br>    app = FastAPI()<br>    app.mount("/static", StaticFiles(directory="fastapi_blog/static"), name="static")<br>    return app</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def create_app():<br>    app = FastAPI(<br>        debug=settings.DEBUG,<br>        title=settings.TITLE,<br>        description=settings.DESCRIPTION,<br>    )<br>    # thread local just flask like g<br>    app.add_middleware(GlobalsMiddleware)<br>    # 注册 db models<br>    setup_db_models(app)<br>    # 初始化路由<br>    setup_routers(app)<br>    # 初始化静态资源路径<br>    setup_static_files(app)<br>    # 初始化全局 middleware<br>    setup_middleware(app)<br>    # 初始化全局 middleware<br>    setup_logging(app)<br>    # 初始化 sentry<br>    if settings.SENTRY_DSN:<br>        setup_sentry(app)<br><br>    return app</code></pre></div></td>
    </tr>
    <tr>
      <td>get_app</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `get_app` that returns an instance of FastAPI application. - Mounts a directory named "fastapi_blog/static" as static files under the URL path "/static". - Sets the name attribute to "static" for easy reference in templates and other views.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def get_app() -> FastAPI:<br>    app = FastAPI()<br>    app.mount("/static", StaticFiles(directory="fastapi_blog/static"), name="static")<br>    return app</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def setup_static_files(app: FastAPI):<br>    static_files_app = StaticFiles(directory=settings.STATIC_DIR)<br>    app.mount(path=settings.STATIC_PATH, app=static_files_app, name="static")</code></pre></div></td>
    </tr>
    <tr>
      <td>get_app</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `get_app` that returns an instance of FastAPI application. - Mounts a directory named "fastapi_blog/static" as static files under the URL path "/static". - Sets the name attribute to "static" for easy reference in templates and other views.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def get_app() -> FastAPI:<br>    app = FastAPI()<br>    app.mount("/static", StaticFiles(directory="fastapi_blog/static"), name="static")<br>    return app</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    def mount_staticfile(self) -> str:<br>        self.site.fastapi.mount(<br>            self.file_path,<br>            StaticFiles(directory=self.file_directory),<br>            self.file_directory,<br>        )<br>        return self.site.router_path + self.file_path</code></pre></div></td>
    </tr>
    <tr>
      <td>get_app</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `get_app` that returns an instance of FastAPI application. - Mounts a directory named "fastapi_blog/static" as static files under the URL path "/static". - Sets the name attribute to "static" for easy reference in templates and other views.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def get_app() -> FastAPI:<br>    app = FastAPI()<br>    app.mount("/static", StaticFiles(directory="fastapi_blog/static"), name="static")<br>    return app</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def get_app() -> FastAPI:<br>    fast_app = FastAPI(title=APP_NAME, version=APP_VERSION, debug=IS_DEBUG)<br>    fast_app.include_router(api_router, prefix=API_PREFIX)<br><br>    fast_app.add_event_handler("startup", start_app_handler(fast_app))<br>    fast_app.add_event_handler("shutdown", stop_app_handler(fast_app))<br><br>    return fast_app</code></pre></div></td>
    </tr>
    <tr>
      <td>get_app</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `get_app` that returns an instance of FastAPI application. - Mounts a directory named "fastapi_blog/static" as static files under the URL path "/static". - Sets the name attribute to "static" for easy reference in templates and other views.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def get_app() -> FastAPI:<br>    app = FastAPI()<br>    app.mount("/static", StaticFiles(directory="fastapi_blog/static"), name="static")<br>    return app</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def get_app() -> FastAPI:<br>    fast_app = FastAPI(title=APP_NAME, version=APP_VERSION, debug=IS_DEBUG)<br>    fast_app.include_router(api_router, prefix=API_PREFIX)<br><br>    fast_app.add_event_handler("startup", start_app_handler(fast_app))<br>    fast_app.add_event_handler("shutdown", stop_app_handler(fast_app))<br><br>    return fast_app</code></pre></div></td>
    </tr>
    <tr>
      <td>get_app</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `get_app` that returns an instance of FastAPI application. - Mounts a directory named "fastapi_blog/static" as static files under the URL path "/static". - Sets the name attribute to "static" for easy reference in templates and other views.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def get_app() -> FastAPI:<br>    app = FastAPI()<br>    app.mount("/static", StaticFiles(directory="fastapi_blog/static"), name="static")<br>    return app</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def setup_static_files(app: FastAPI):<br>    static_files_app = StaticFiles(directory=settings.STATIC_DIR)<br>    app.mount(path=settings.STATIC_PATH, app=static_files_app, name="static")</code></pre></div></td>
    </tr>
    <tr>
      <td>get_app</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `get_app` that returns an instance of FastAPI application. - Mounts a directory named "fastapi_blog/static" as static files under the URL path "/static". - Sets the name attribute to "static" for easy reference in templates and other views.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def get_app() -> FastAPI:<br>    app = FastAPI()<br>    app.mount("/static", StaticFiles(directory="fastapi_blog/static"), name="static")<br>    return app</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def get_app():<br>    from docs_src.request_files.tutorial002_an_py39 import app<br><br>    return app</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Limits text input length to prevent abuse and returns an error message with status code 400 for inputs exceeding 100 characters. - Retrieves user's native language from session state and converts it into a Google Cloud Translation API compatible format using `langcodes`. - Makes a translation request to the Google Cloud Translation API using the provided text, target language (English), and source language based on the user's native language. - Tracks the translation event in Mixpanel by passing relevant details such as original text, translated text, native language, and native language code along with the request object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">        async def route(request: Request, data: self.schema):  # type:ignore<br>            return await self.handle(request, data)  # type:ignore</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Limits text input length to prevent abuse and returns an error message with status code 400 for inputs exceeding 100 characters. - Retrieves user's native language from session state and converts it into a Google Cloud Translation API compatible format using `langcodes`. - Makes a translation request to the Google Cloud Translation API using the provided text, target language (English), and source language based on the user's native language. - Tracks the translation event in Mixpanel by passing relevant details such as original text, translated text, native language, and native language code along with the request object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">        async def route(<br>            request: Request,<br>            data: Annotated[Union[List[self.schema_create], self.schema_create], Body()],  # type: ignore<br>        ) -> BaseApiOut[Union[int, self.schema_model]]:  # type: ignore<br>            if not await self.has_create_permission(request, data):<br>                return self.error_no_router_permission(request)<br>            if not isinstance(data, list):<br>                data = [data]<br>            try:<br>                items = await self.create_items(request, data)<br>            except Exception as error:<br>                await self.db.async_rollback()<br>                return self.error_execute_sql(request=request, error=error)<br>            result = len(items)<br>            if result == 1:  # if only one item, return the first item<br>                result = await self.db.async_run_sync(<br>                    lambda _: parse_obj_to_schema(<br>                        items[0], self.schema_model, refresh=True<br>                    )<br>                )<br>            return BaseApiOut(data=result)</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Limits text input length to prevent abuse and returns an error message with status code 400 for inputs exceeding 100 characters. - Retrieves user's native language from session state and converts it into a Google Cloud Translation API compatible format using `langcodes`. - Makes a translation request to the Google Cloud Translation API using the provided text, target language (English), and source language based on the user's native language. - Tracks the translation event in Mixpanel by passing relevant details such as original text, translated text, native language, and native language code along with the request object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    def route_submit(self):<br>        async def route(request: Request, data: self.schema):  # type:ignore<br>            return await self.handle(request, data)  # type:ignore<br><br>        return route</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Limits text input length to prevent abuse and returns an error message with status code 400 for inputs exceeding 100 characters. - Retrieves user's native language from session state and converts it into a Google Cloud Translation API compatible format using `langcodes`. - Makes a translation request to the Google Cloud Translation API using the provided text, target language (English), and source language based on the user's native language. - Tracks the translation event in Mixpanel by passing relevant details such as original text, translated text, native language, and native language code along with the request object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.where import tutorial009_py310 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(mod.sqlite_url)<br>    calls = []<br><br>    new_print = get_testing_print_function(calls)<br><br>    with patch("builtins.print", new=new_print):<br>        mod.main()<br>    assert calls == [<br>        [{"name": "Tarantula", "secret_name": "Natalia Roman-on", "age": 32, "id": 4}],<br>        [{"name": "Black Lion", "secret_name": "Trevor Challa", "age": 35, "id": 5}],<br>        [<br>            {<br>                "name": "Captain North America",<br>                "secret_name": "Esteban Rogelios",<br>                "age": 93,<br>                "id": 7,<br>            }<br>        ],<br>    ]</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Limits text input length to prevent abuse and returns an error message with status code 400 for inputs exceeding 100 characters. - Retrieves user's native language from session state and converts it into a Google Cloud Translation API compatible format using `langcodes`. - Makes a translation request to the Google Cloud Translation API using the provided text, target language (English), and source language based on the user's native language. - Tracks the translation event in Mixpanel by passing relevant details such as original text, translated text, native language, and native language code along with the request object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">        @self.router.get("/map", response_class=HTMLResponse)<br>        @self.router.get("/{TileMatrixSetId}/map", response_class=HTMLResponse)<br>        def map_viewer(<br>            request: Request,<br>            src_path=Depends(self.path_dependency),<br>            TileMatrixSetId: Literal[tuple(self.supported_tms.list())] = Query(<br>                self.default_tms,<br>                description=f"TileMatrixSet Name (default: '{self.default_tms}')",<br>            ),<br>            tile_format: Optional[ImageType] = Query(<br>                None, description="Output image type. Default is auto."<br>            ),<br>            tile_scale: int = Query(<br>                1, gt=0, lt=4, description="Tile size scale. 1=256x256, 2=512x512..."<br>            ),<br>            minzoom: Optional[int] = Query(<br>                None, description="Overwrite default minzoom."<br>            ),<br>            maxzoom: Optional[int] = Query(<br>                None, description="Overwrite default maxzoom."<br>            ),<br>            layer_params=Depends(self.layer_dependency),  # noqa<br>            dataset_params=Depends(self.dataset_dependency),  # noqa<br>            pixel_selection=Depends(self.pixel_selection_dependency),  # noqa<br>            buffer: Optional[float] = Query(  # noqa<br>                None,<br>                gt=0,<br>                title="Tile buffer.",<br>                description="Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * tile_buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).",<br>            ),<br>            rescale: Optional[List[Tuple[float, ...]]] = Depends(<br>                RescalingParams<br>            ),  # noqa<br>            color_formula: Optional[str] = Query(  # noqa<br>                None,<br>                title="Color Formula",<br>                description="rio-color formula (info: https://github.com/mapbox/rio-color)",<br>            ),<br>            colormap=Depends(self.colormap_dependency),  # noqa<br>            render_params=Depends(se</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Limits text input length to prevent abuse and returns an error message with status code 400 for inputs exceeding 100 characters. - Retrieves user's native language from session state and converts it into a Google Cloud Translation API compatible format using `langcodes`. - Makes a translation request to the Google Cloud Translation API using the provided text, target language (English), and source language based on the user's native language. - Tracks the translation event in Mixpanel by passing relevant details such as original text, translated text, native language, and native language code along with the request object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@dataclass<br>class TMSFactory:<br>    """TileMatrixSet endpoints Factory."""<br><br>    supported_tms: TileMatrixSets = morecantile_tms<br><br>    # FastAPI router<br>    router: APIRouter = field(default_factory=APIRouter)<br><br>    # Router Prefix is needed to find the path for /tile if the TilerFactory.router is mounted<br>    # with other router (multiple `.../tile` routes).<br>    # e.g if you mount the route with `/cog` prefix, set router_prefix to cog and<br>    router_prefix: str = ""<br><br>    def __post_init__(self):<br>        """Post Init: register route and configure specific options."""<br>        self.register_routes()<br><br>    def url_for(self, request: Request, name: str, **path_params: Any) -> str:<br>        """Return full url (with prefix) for a specific endpoint."""<br>        url_path = self.router.url_path_for(name, **path_params)<br>        base_url = str(request.base_url)<br>        if self.router_prefix:<br>            base_url += self.router_prefix.lstrip("/")<br>        return url_path.make_absolute_url(base_url=base_url)<br><br>    def register_routes(self):<br>        """Register TMS endpoint routes."""<br><br>        @self.router.get(<br>            r"/tileMatrixSets",<br>            response_model=TileMatrixSetList,<br>            response_model_exclude_none=True,<br>            summary="Retrieve the list of available tiling schemes (tile matrix sets).",<br>            operation_id="getTileMatrixSetsList",<br>        )<br>        async def TileMatrixSet_list(request: Request):<br>            """<br>            OGC Specification: http://docs.opengeospatial.org/per/19-069.html#_tilematrixsets<br>            """<br>            return {<br>                "tileMatrixSets": [<br>                    {<br>                        "id": tms,<br>                        "title": tms,<br>                        "links": [<br>                            {<br>                                "href": self.url_for(<br>                                    request,<br>                                    "TileMatrixSet_info",<br>                                    TileMatrixSetId=tms,<br>            </code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Limits text input length to prevent abuse and returns an error message with status code 400 for inputs exceeding 100 characters. - Retrieves user's native language from session state and converts it into a Google Cloud Translation API compatible format using `langcodes`. - Makes a translation request to the Google Cloud Translation API using the provided text, target language (English), and source language based on the user's native language. - Tracks the translation event in Mixpanel by passing relevant details such as original text, translated text, native language, and native language code along with the request object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_path_param_maxlength_foobar():<br>    response = client.get("/path/param-maxlength/foobar")<br>    assert response.status_code == 422<br>    assert response.json() == IsDict(<br>        {<br>            "detail": [<br>                {<br>                    "type": "string_too_long",<br>                    "loc": ["path", "item_id"],<br>                    "msg": "String should have at most 3 characters",<br>                    "input": "foobar",<br>                    "ctx": {"max_length": 3},<br>                    "url": match_pydantic_error_url("string_too_long"),<br>                }<br>            ]<br>        }<br>    ) | IsDict(<br>        # TODO: remove when deprecating Pydantic v1<br>        {<br>            "detail": [<br>                {<br>                    "loc": ["path", "item_id"],<br>                    "msg": "ensure this value has at most 3 characters",<br>                    "type": "value_error.any_str.max_length",<br>                    "ctx": {"limit_value": 3},<br>                }<br>            ]<br>        }<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Limits text input length to prevent abuse and returns an error message with status code 400 for inputs exceeding 100 characters. - Retrieves user's native language from session state and converts it into a Google Cloud Translation API compatible format using `langcodes`. - Makes a translation request to the Google Cloud Translation API using the provided text, target language (English), and source language based on the user's native language. - Tracks the translation event in Mixpanel by passing relevant details such as original text, translated text, native language, and native language code along with the request object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_prediction(test_client) -> None:<br>    response = test_client.post(<br>        "/api/model/predict",<br>        json={<br>            "median_income_in_block": 8.3252,<br>            "median_house_age_in_block": 41,<br>            "average_rooms": 6,<br>            "average_bedrooms": 1,<br>            "population_per_block": 322,<br>            "average_house_occupancy": 2.55,<br>            "block_latitude": 37.88,<br>            "block_longitude": -122.23,<br>        },<br>        headers={"token": str(config.API_KEY)},<br>    )<br>    assert response.status_code == 200<br>    assert "median_house_value" in response.json()<br>    assert "currency" in response.json()</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Limits text input length to prevent abuse and returns an error message with status code 400 for inputs exceeding 100 characters. - Retrieves user's native language from session state and converts it into a Google Cloud Translation API compatible format using `langcodes`. - Makes a translation request to the Google Cloud Translation API using the provided text, target language (English), and source language based on the user's native language. - Tracks the translation event in Mixpanel by passing relevant details such as original text, translated text, native language, and native language code along with the request object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@needs_pydanticv1<br>def test_create_user(client):<br>    test_user = {"email": "johndoe@example.com", "password": "secret"}<br>    response = client.post("/users/", json=test_user)<br>    assert response.status_code == 200, response.text<br>    data = response.json()<br>    assert test_user["email"] == data["email"]<br>    assert "id" in data<br>    response = client.post("/users/", json=test_user)<br>    assert response.status_code == 400, response.text</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `handler` that handles requests for generating text based on prompts using GPT-3 API in FastAPI framework.<br>- Retrieves the system description and user prompt from the request body.<br>- Sets default values for optional parameters such as temperature and maximum number of new tokens generated by the model.<br>- Uses the provided context object to access the GPT-3 model and its associated tokenizer.<br>- Prepares the input data for the model by converting the template string into a PyTorch tensor with the appropriate device (in this case, CUDA).<br>- Generates the response text using the `generate` method of the model, passing in the prepared input and desired settings.<br>- Decodes the resulting sequence of integers back into human-readable text using the tokenizer.<br>- Returns a JSON response containing the decoded text.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/text")<br>def get_text():<br>    return "Hello World"</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `handler` that handles requests for generating text based on prompts using GPT-3 API in FastAPI framework.<br>- Retrieves the system description and user prompt from the request body.<br>- Sets default values for optional parameters such as temperature and maximum number of new tokens generated by the model.<br>- Uses the provided context object to access the GPT-3 model and its associated tokenizer.<br>- Prepares the input data for the model by converting the template string into a PyTorch tensor with the appropriate device (in this case, CUDA).<br>- Generates the response text using the `generate` method of the model, passing in the prepared input and desired settings.<br>- Decodes the resulting sequence of integers back into human-readable text using the tokenizer.<br>- Returns a JSON response containing the decoded text.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def read_main(request: Request):<br>    return {"message": "Hello World", "root_path": request.scope.get("root_path")}</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `handler` that handles requests for generating text based on prompts using GPT-3 API in FastAPI framework.<br>- Retrieves the system description and user prompt from the request body.<br>- Sets default values for optional parameters such as temperature and maximum number of new tokens generated by the model.<br>- Uses the provided context object to access the GPT-3 model and its associated tokenizer.<br>- Prepares the input data for the model by converting the template string into a PyTorch tensor with the appropriate device (in this case, CUDA).<br>- Generates the response text using the `generate` method of the model, passing in the prepared input and desired settings.<br>- Decodes the resulting sequence of integers back into human-readable text using the tokenizer.<br>- Returns a JSON response containing the decoded text.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def handle_http_request(self, http_request: Request):<br>        background_tasks = BackgroundTasks()<br><br>        sub_response = Response()<br>        del sub_response.headers["content-length"]<br>        sub_response.status_code = None  # type: ignore<br><br>        try:<br>            body = await self.parse_body(http_request)<br>        except Exception as exc:<br>            resp = await self.entrypoint.handle_exception_to_resp(exc)<br>            response = self.response_class(content=resp, background=background_tasks)<br>        else:<br>            try:<br>                resp = await self.handle_body(<br>                    http_request, background_tasks, sub_response, body<br>                )<br>            except NoContent:<br>                # no content for successful notifications<br>                response = Response(<br>                    media_type="application/json", background=background_tasks<br>                )<br>            else:<br>                response = self.response_class(<br>                    content=resp, background=background_tasks<br>                )<br><br>        response.headers.raw.extend(sub_response.headers.raw)<br>        if sub_response.status_code:<br>            response.status_code = sub_response.status_code<br><br>        return response</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `handler` that handles requests for generating text based on prompts using GPT-3 API in FastAPI framework.<br>- Retrieves the system description and user prompt from the request body.<br>- Sets default values for optional parameters such as temperature and maximum number of new tokens generated by the model.<br>- Uses the provided context object to access the GPT-3 model and its associated tokenizer.<br>- Prepares the input data for the model by converting the template string into a PyTorch tensor with the appropriate device (in this case, CUDA).<br>- Generates the response text using the `generate` method of the model, passing in the prepared input and desired settings.<br>- Decodes the resulting sequence of integers back into human-readable text using the tokenizer.<br>- Returns a JSON response containing the decoded text.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.where import tutorial010 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(mod.sqlite_url)<br>    calls = []<br><br>    new_print = get_testing_print_function(calls)<br><br>    with patch("builtins.print", new=new_print):<br>        mod.main()<br>    assert calls == [<br>        [{"name": "Tarantula", "secret_name": "Natalia Roman-on", "age": 32, "id": 4}],<br>        [{"name": "Black Lion", "secret_name": "Trevor Challa", "age": 35, "id": 5}],<br>        [<br>            {<br>                "name": "Captain North America",<br>                "secret_name": "Esteban Rogelios",<br>                "age": 93,<br>                "id": 7,<br>            }<br>        ],<br>    ]</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `handler` that handles requests for generating text based on prompts using GPT-3 API in FastAPI framework.<br>- Retrieves the system description and user prompt from the request body.<br>- Sets default values for optional parameters such as temperature and maximum number of new tokens generated by the model.<br>- Uses the provided context object to access the GPT-3 model and its associated tokenizer.<br>- Prepares the input data for the model by converting the template string into a PyTorch tensor with the appropriate device (in this case, CUDA).<br>- Generates the response text using the `generate` method of the model, passing in the prepared input and desired settings.<br>- Decodes the resulting sequence of integers back into human-readable text using the tokenizer.<br>- Returns a JSON response containing the decoded text.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.where import tutorial010_py310 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(mod.sqlite_url)<br>    calls = []<br><br>    new_print = get_testing_print_function(calls)<br><br>    with patch("builtins.print", new=new_print):<br>        mod.main()<br>    assert calls == [<br>        [{"name": "Tarantula", "secret_name": "Natalia Roman-on", "age": 32, "id": 4}],<br>        [{"name": "Black Lion", "secret_name": "Trevor Challa", "age": 35, "id": 5}],<br>        [<br>            {<br>                "name": "Captain North America",<br>                "secret_name": "Esteban Rogelios",<br>                "age": 93,<br>                "id": 7,<br>            }<br>        ],<br>    ]</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `handler` that handles requests for generating text based on prompts using GPT-3 API in FastAPI framework.<br>- Retrieves the system description and user prompt from the request body.<br>- Sets default values for optional parameters such as temperature and maximum number of new tokens generated by the model.<br>- Uses the provided context object to access the GPT-3 model and its associated tokenizer.<br>- Prepares the input data for the model by converting the template string into a PyTorch tensor with the appropriate device (in this case, CUDA).<br>- Generates the response text using the `generate` method of the model, passing in the prepared input and desired settings.<br>- Decodes the resulting sequence of integers back into human-readable text using the tokenizer.<br>- Returns a JSON response containing the decoded text.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.where import tutorial009 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(mod.sqlite_url)<br>    calls = []<br><br>    new_print = get_testing_print_function(calls)<br><br>    with patch("builtins.print", new=new_print):<br>        mod.main()<br>    assert calls == [<br>        [{"name": "Tarantula", "secret_name": "Natalia Roman-on", "age": 32, "id": 4}],<br>        [{"name": "Black Lion", "secret_name": "Trevor Challa", "age": 35, "id": 5}],<br>        [<br>            {<br>                "name": "Captain North America",<br>                "secret_name": "Esteban Rogelios",<br>                "age": 93,<br>                "id": 7,<br>            }<br>        ],<br>    ]</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `handler` that handles requests for generating text based on prompts using GPT-3 API in FastAPI framework.<br>- Retrieves the system description and user prompt from the request body.<br>- Sets default values for optional parameters such as temperature and maximum number of new tokens generated by the model.<br>- Uses the provided context object to access the GPT-3 model and its associated tokenizer.<br>- Prepares the input data for the model by converting the template string into a PyTorch tensor with the appropriate device (in this case, CUDA).<br>- Generates the response text using the `generate` method of the model, passing in the prepared input and desired settings.<br>- Decodes the resulting sequence of integers back into human-readable text using the tokenizer.<br>- Returns a JSON response containing the decoded text.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def handle_http_request(self, http_request: Request):<br>        background_tasks = BackgroundTasks()<br><br>        sub_response = Response()<br>        del sub_response.headers["content-length"]<br>        sub_response.status_code = None  # type: ignore<br><br>        try:<br>            body = await self.parse_body(http_request)<br>        except Exception as exc:<br>            resp = await self.entrypoint.handle_exception_to_resp(exc)<br>            response = self.response_class(content=resp, background=background_tasks)<br>        else:<br>            try:<br>                resp = await self.handle_body(<br>                    http_request, background_tasks, sub_response, body<br>                )<br>            except NoContent:<br>                # no content for successful notifications<br>                response = Response(<br>                    media_type="application/json", background=background_tasks<br>                )<br>            else:<br>                response = self.response_class(<br>                    content=resp, background=background_tasks<br>                )<br><br>        response.headers.raw.extend(sub_response.headers.raw)<br>        if sub_response.status_code:<br>            response.status_code = sub_response.status_code<br><br>        return response</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `handler` that handles requests for generating text based on prompts using GPT-3 API in FastAPI framework.<br>- Retrieves the system description and user prompt from the request body.<br>- Sets default values for optional parameters such as temperature and maximum number of new tokens generated by the model.<br>- Uses the provided context object to access the GPT-3 model and its associated tokenizer.<br>- Prepares the input data for the model by converting the template string into a PyTorch tensor with the appropriate device (in this case, CUDA).<br>- Generates the response text using the `generate` method of the model, passing in the prepared input and desired settings.<br>- Decodes the resulting sequence of integers back into human-readable text using the tokenizer.<br>- Returns a JSON response containing the decoded text.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@my_awesome_api.get("/")<br>async def root():<br>    return {"message": "Hello World"}</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `handler` that handles requests for generating text based on prompts using GPT-3 API in FastAPI framework.<br>- Retrieves the system description and user prompt from the request body.<br>- Sets default values for optional parameters such as temperature and maximum number of new tokens generated by the model.<br>- Uses the provided context object to access the GPT-3 model and its associated tokenizer.<br>- Prepares the input data for the model by converting the template string into a PyTorch tensor with the appropriate device (in this case, CUDA).<br>- Generates the response text using the `generate` method of the model, passing in the prepared input and desired settings.<br>- Decodes the resulting sequence of integers back into human-readable text using the tokenizer.<br>- Returns a JSON response containing the decoded text.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def handle_req_to_resp(<br>        self,<br>        http_request: Request,<br>        background_tasks: BackgroundTasks,<br>        sub_response: Response,<br>        req: Any,<br>        dependency_cache: dict = None,<br>        shared_dependencies_error: BaseError = None,<br>    ) -> dict:<br>        async with JsonRpcContext(<br>            entrypoint=self.entrypoint,<br>            raw_request=req,<br>            http_request=http_request,<br>            background_tasks=background_tasks,<br>            http_response=sub_response,<br>            json_rpc_request_class=self.request_class,<br>        ) as ctx:<br>            await ctx.enter_middlewares(self.entrypoint.middlewares)<br><br>            resp = await self.handle_req(<br>                http_request,<br>                background_tasks,<br>                sub_response,<br>                ctx,<br>                dependency_cache=dependency_cache,<br>                shared_dependencies_error=shared_dependencies_error,<br>            )<br>            ctx.on_raw_response(resp)<br><br>        return ctx.raw_response</code></pre></div></td>
    </tr>
    <tr>
      <td>html_report</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a GET request to `/conversation_report`.<br>- It takes several optional query parameters for filtering and sorting feedback data.<br>- The function parses these parameters and passes them to a helper function `get_feedbacks()`, which returns a list of feedback objects.<br>- The resulting feedback list is passed to Pandas DataFrame, which generates an HTML table with formatted output using custom format functions provided by the `formatters` parameter.<br>- Finally, the generated HTML response is returned as a FastAPI HTTP response object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/conversation_report")<br>def get_feedback_dashboard(<br>    is_admin: Annotated[bool, Depends(ensure_admin_account)],<br>    start: str | None = None,<br>    end: str | None = None,<br>    user_email: str | None = None,<br>    has_text: bool | None = None,<br>    did_join: bool | None = None,<br>):<br>    # Parse arguments<br>    if start:<br>        start = datetime.datetime.strptime(start, "%Y-%m-%d")<br>    if end:<br>        end = datetime.datetime.strptime(end, "%Y-%m-%d")<br>    if has_text:<br>        has_text = has_text in ["true", "True", "1"]<br>    if did_join:<br>        did_join = did_join in ["true", "True", "1"]<br><br>    # Defaults<br>    if not start:<br>        start = last_monday(last_week_if_today=False)<br><br>    feedbacks = get_feedbacks(<br>        start=start,<br>        end=end,<br>        user_email=user_email,<br>        has_text=has_text,<br>        did_join=did_join,<br>    )<br><br>    format_dict = (<br>        lambda d: f'<div style="white-space:pre-wrap">{html.escape(json.dumps(d, indent=4, default=str))}</div>'<br>    )<br>    return HTMLResponse(<br>        pd.DataFrame(feedbacks).to_html(<br>            escape=False,<br>            formatters={<br>                "type_counts": format_dict,<br>                "examples": format_dict,<br>            },<br>        )<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@item_router.get("/")<br>def get_items(user_id: Optional[str] = None):<br>    if user_id is None:<br>        return [{"item_id": "i1", "user_id": "u1"}, {"item_id": "i2", "user_id": "u2"}]<br>    else:<br>        return [{"item_id": "i2", "user_id": user_id}]</code></pre></div></td>
    </tr>
    <tr>
      <td>html_report</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a GET request to `/conversation_report`.<br>- It takes several optional query parameters for filtering and sorting feedback data.<br>- The function parses these parameters and passes them to a helper function `get_feedbacks()`, which returns a list of feedback objects.<br>- The resulting feedback list is passed to Pandas DataFrame, which generates an HTML table with formatted output using custom format functions provided by the `formatters` parameter.<br>- Finally, the generated HTML response is returned as a FastAPI HTTP response object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/conversation_report")<br>def get_feedback_dashboard(<br>    is_admin: Annotated[bool, Depends(ensure_admin_account)],<br>    start: str | None = None,<br>    end: str | None = None,<br>    user_email: str | None = None,<br>    has_text: bool | None = None,<br>    did_join: bool | None = None,<br>):<br>    # Parse arguments<br>    if start:<br>        start = datetime.datetime.strptime(start, "%Y-%m-%d")<br>    if end:<br>        end = datetime.datetime.strptime(end, "%Y-%m-%d")<br>    if has_text:<br>        has_text = has_text in ["true", "True", "1"]<br>    if did_join:<br>        did_join = did_join in ["true", "True", "1"]<br><br>    # Defaults<br>    if not start:<br>        start = last_monday(last_week_if_today=False)<br><br>    feedbacks = get_feedbacks(<br>        start=start,<br>        end=end,<br>        user_email=user_email,<br>        has_text=has_text,<br>        did_join=did_join,<br>    )<br><br>    format_dict = (<br>        lambda d: f'<div style="white-space:pre-wrap">{html.escape(json.dumps(d, indent=4, default=str))}</div>'<br>    )<br>    return HTMLResponse(<br>        pd.DataFrame(feedbacks).to_html(<br>            escape=False,<br>            formatters={<br>                "type_counts": format_dict,<br>                "examples": format_dict,<br>            },<br>        )<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get(<br>    "/response_model_none-annotation-return_dict_with_extra_data", response_model=None<br>)<br>def response_model_none_annotation_return_dict_with_extra_data() -> User:<br>    return {"name": "John", "surname": "Doe", "password_hash": "secret"}</code></pre></div></td>
    </tr>
    <tr>
      <td>html_report</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a GET request to `/conversation_report`.<br>- It takes several optional query parameters for filtering and sorting feedback data.<br>- The function parses these parameters and passes them to a helper function `get_feedbacks()`, which returns a list of feedback objects.<br>- The resulting feedback list is passed to Pandas DataFrame, which generates an HTML table with formatted output using custom format functions provided by the `formatters` parameter.<br>- Finally, the generated HTML response is returned as a FastAPI HTTP response object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/conversation_report")<br>def get_feedback_dashboard(<br>    is_admin: Annotated[bool, Depends(ensure_admin_account)],<br>    start: str | None = None,<br>    end: str | None = None,<br>    user_email: str | None = None,<br>    has_text: bool | None = None,<br>    did_join: bool | None = None,<br>):<br>    # Parse arguments<br>    if start:<br>        start = datetime.datetime.strptime(start, "%Y-%m-%d")<br>    if end:<br>        end = datetime.datetime.strptime(end, "%Y-%m-%d")<br>    if has_text:<br>        has_text = has_text in ["true", "True", "1"]<br>    if did_join:<br>        did_join = did_join in ["true", "True", "1"]<br><br>    # Defaults<br>    if not start:<br>        start = last_monday(last_week_if_today=False)<br><br>    feedbacks = get_feedbacks(<br>        start=start,<br>        end=end,<br>        user_email=user_email,<br>        has_text=has_text,<br>        did_join=did_join,<br>    )<br><br>    format_dict = (<br>        lambda d: f'<div style="white-space:pre-wrap">{html.escape(json.dumps(d, indent=4, default=str))}</div>'<br>    )<br>    return HTMLResponse(<br>        pd.DataFrame(feedbacks).to_html(<br>            escape=False,<br>            formatters={<br>                "type_counts": format_dict,<br>                "examples": format_dict,<br>            },<br>        )<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get(<br>    "/response_model-no_annotation-return_dict_with_extra_data", response_model=User<br>)<br>def response_model_no_annotation_return_dict_with_extra_data():<br>    return {"name": "John", "surname": "Doe", "password_hash": "secret"}</code></pre></div></td>
    </tr>
    <tr>
      <td>html_report</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a GET request to `/conversation_report`.<br>- It takes several optional query parameters for filtering and sorting feedback data.<br>- The function parses these parameters and passes them to a helper function `get_feedbacks()`, which returns a list of feedback objects.<br>- The resulting feedback list is passed to Pandas DataFrame, which generates an HTML table with formatted output using custom format functions provided by the `formatters` parameter.<br>- Finally, the generated HTML response is returned as a FastAPI HTTP response object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/conversation_report")<br>def get_feedback_dashboard(<br>    is_admin: Annotated[bool, Depends(ensure_admin_account)],<br>    start: str | None = None,<br>    end: str | None = None,<br>    user_email: str | None = None,<br>    has_text: bool | None = None,<br>    did_join: bool | None = None,<br>):<br>    # Parse arguments<br>    if start:<br>        start = datetime.datetime.strptime(start, "%Y-%m-%d")<br>    if end:<br>        end = datetime.datetime.strptime(end, "%Y-%m-%d")<br>    if has_text:<br>        has_text = has_text in ["true", "True", "1"]<br>    if did_join:<br>        did_join = did_join in ["true", "True", "1"]<br><br>    # Defaults<br>    if not start:<br>        start = last_monday(last_week_if_today=False)<br><br>    feedbacks = get_feedbacks(<br>        start=start,<br>        end=end,<br>        user_email=user_email,<br>        has_text=has_text,<br>        did_join=did_join,<br>    )<br><br>    format_dict = (<br>        lambda d: f'<div style="white-space:pre-wrap">{html.escape(json.dumps(d, indent=4, default=str))}</div>'<br>    )<br>    return HTMLResponse(<br>        pd.DataFrame(feedbacks).to_html(<br>            escape=False,<br>            formatters={<br>                "type_counts": format_dict,<br>                "examples": format_dict,<br>            },<br>        )<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def get_graphql_response(<br>    *,<br>    settings: Settings,<br>    query: str,<br>    after: Union[str, None] = None,<br>    category_id: Union[str, None] = None,<br>    discussion_number: Union[int, None] = None,<br>    discussion_id: Union[str, None] = None,<br>    comment_id: Union[str, None] = None,<br>    body: Union[str, None] = None,<br>) -> Dict[str, Any]:<br>    headers = {"Authorization": f"token {settings.input_token.get_secret_value()}"}<br>    # some fields are only used by one query, but GraphQL allows unused variables, so<br>    # keep them here for simplicity<br>    variables = {<br>        "after": after,<br>        "category_id": category_id,<br>        "discussion_number": discussion_number,<br>        "discussion_id": discussion_id,<br>        "comment_id": comment_id,<br>        "body": body,<br>    }<br>    response = httpx.post(<br>        github_graphql_url,<br>        headers=headers,<br>        timeout=settings.httpx_timeout,<br>        json={"query": query, "variables": variables, "operationName": "Q"},<br>    )<br>    if response.status_code != 200:<br>        logging.error(<br>            f"Response was not 200, after: {after}, category_id: {category_id}"<br>        )<br>        logging.error(response.text)<br>        raise RuntimeError(response.text)<br>    data = response.json()<br>    if "errors" in data:<br>        logging.error(f"Errors in response, after: {after}, category_id: {category_id}")<br>        logging.error(response.text)<br>        raise RuntimeError(response.text)<br>    return cast(Dict[str, Any], data)</code></pre></div></td>
    </tr>
    <tr>
      <td>html_report</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a GET request to `/conversation_report`.<br>- It takes several optional query parameters for filtering and sorting feedback data.<br>- The function parses these parameters and passes them to a helper function `get_feedbacks()`, which returns a list of feedback objects.<br>- The resulting feedback list is passed to Pandas DataFrame, which generates an HTML table with formatted output using custom format functions provided by the `formatters` parameter.<br>- Finally, the generated HTML response is returned as a FastAPI HTTP response object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/conversation_report")<br>def get_feedback_dashboard(<br>    is_admin: Annotated[bool, Depends(ensure_admin_account)],<br>    start: str | None = None,<br>    end: str | None = None,<br>    user_email: str | None = None,<br>    has_text: bool | None = None,<br>    did_join: bool | None = None,<br>):<br>    # Parse arguments<br>    if start:<br>        start = datetime.datetime.strptime(start, "%Y-%m-%d")<br>    if end:<br>        end = datetime.datetime.strptime(end, "%Y-%m-%d")<br>    if has_text:<br>        has_text = has_text in ["true", "True", "1"]<br>    if did_join:<br>        did_join = did_join in ["true", "True", "1"]<br><br>    # Defaults<br>    if not start:<br>        start = last_monday(last_week_if_today=False)<br><br>    feedbacks = get_feedbacks(<br>        start=start,<br>        end=end,<br>        user_email=user_email,<br>        has_text=has_text,<br>        did_join=did_join,<br>    )<br><br>    format_dict = (<br>        lambda d: f'<div style="white-space:pre-wrap">{html.escape(json.dumps(d, indent=4, default=str))}</div>'<br>    )<br>    return HTMLResponse(<br>        pd.DataFrame(feedbacks).to_html(<br>            escape=False,<br>            formatters={<br>                "type_counts": format_dict,<br>                "examples": format_dict,<br>            },<br>        )<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def get_request_handler(<br>    dependant: Dependant,<br>    body_field: Optional[ModelField] = None,<br>    status_code: Optional[int] = None,<br>    response_class: Union[Type[Response], DefaultPlaceholder] = Default(JSONResponse),<br>    response_field: Optional[ModelField] = None,<br>    response_model_include: Optional[IncEx] = None,<br>    response_model_exclude: Optional[IncEx] = None,<br>    response_model_by_alias: bool = True,<br>    response_model_exclude_unset: bool = False,<br>    response_model_exclude_defaults: bool = False,<br>    response_model_exclude_none: bool = False,<br>    dependency_overrides_provider: Optional[Any] = None,<br>) -> Callable[[Request], Coroutine[Any, Any, Response]]:<br>    assert dependant.call is not None, "dependant.call must be a function"<br>    is_coroutine = asyncio.iscoroutinefunction(dependant.call)<br>    is_body_form = body_field and isinstance(body_field.field_info, params.Form)<br>    if isinstance(response_class, DefaultPlaceholder):<br>        actual_response_class: Type[Response] = response_class.value<br>    else:<br>        actual_response_class = response_class<br><br>    async def app(request: Request) -> Response:<br>        try:<br>            body: Any = None<br>            if body_field:<br>                if is_body_form:<br>                    body = await request.form()<br>                    stack = request.scope.get("fastapi_astack")<br>                    assert isinstance(stack, AsyncExitStack)<br>                    stack.push_async_callback(body.close)<br>                else:<br>                    body_bytes = await request.body()<br>                    if body_bytes:<br>                        json_body: Any = Undefined<br>                        content_type_value = request.headers.get("content-type")<br>                        if not content_type_value:<br>                            json_body = await request.json()<br>                        else:<br>                            message = email.message.Message()<br>                            message["content-type"] = content_type_value<br>                    </code></pre></div></td>
    </tr>
    <tr>
      <td>html_report</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a GET request to `/conversation_report`.<br>- It takes several optional query parameters for filtering and sorting feedback data.<br>- The function parses these parameters and passes them to a helper function `get_feedbacks()`, which returns a list of feedback objects.<br>- The resulting feedback list is passed to Pandas DataFrame, which generates an HTML table with formatted output using custom format functions provided by the `formatters` parameter.<br>- Finally, the generated HTML response is returned as a FastAPI HTTP response object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/conversation_report")<br>def get_feedback_dashboard(<br>    is_admin: Annotated[bool, Depends(ensure_admin_account)],<br>    start: str | None = None,<br>    end: str | None = None,<br>    user_email: str | None = None,<br>    has_text: bool | None = None,<br>    did_join: bool | None = None,<br>):<br>    # Parse arguments<br>    if start:<br>        start = datetime.datetime.strptime(start, "%Y-%m-%d")<br>    if end:<br>        end = datetime.datetime.strptime(end, "%Y-%m-%d")<br>    if has_text:<br>        has_text = has_text in ["true", "True", "1"]<br>    if did_join:<br>        did_join = did_join in ["true", "True", "1"]<br><br>    # Defaults<br>    if not start:<br>        start = last_monday(last_week_if_today=False)<br><br>    feedbacks = get_feedbacks(<br>        start=start,<br>        end=end,<br>        user_email=user_email,<br>        has_text=has_text,<br>        did_join=did_join,<br>    )<br><br>    format_dict = (<br>        lambda d: f'<div style="white-space:pre-wrap">{html.escape(json.dumps(d, indent=4, default=str))}</div>'<br>    )<br>    return HTMLResponse(<br>        pd.DataFrame(feedbacks).to_html(<br>            escape=False,<br>            formatters={<br>                "type_counts": format_dict,<br>                "examples": format_dict,<br>            },<br>        )<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    def get_field_amis_form_item_type(<br>        self, type_: Any, is_filter: bool, required: bool = False<br>    ) -> dict:<br>        """Get amis form item type from pydantic model field type."""<br>        kwargs = {}<br>        type_ = annotation_outer_type(type_)<br>        if type_ in {str, Any}:<br>            kwargs["type"] = "input-text"<br>        elif issubclass(type_, Enum):<br>            items = (<br>                type_.choices<br>                if issubclass(type_, Choices)<br>                else [(m.value, m.value) for m in type_]<br>            )<br>            kwargs.update(<br>                {<br>                    "type": "select",<br>                    "options": [{"label": label, "value": v} for v, label in items],<br>                    "extractValue": True,<br>                    "joinValues": False,<br>                }<br>            )<br>            if not required or is_filter:<br>                kwargs["clearable"] = True<br>        elif issubclass(type_, bool):<br>            kwargs["type"] = "switch"<br>        elif is_filter:<br>            if issubclass(type_, datetime.datetime):<br>                kwargs["type"] = "input-datetime-range"<br>                kwargs["format"] = "YYYY-MM-DD HH:mm:ss"<br>                # 给筛选的 DateTimeRange 添加 today 标签<br>                kwargs[<br>                    "ranges"<br>                ] = "today,yesterday,7daysago,prevweek,thismonth,prevmonth,prevquarter"<br>            elif issubclass(type_, datetime.date):<br>                kwargs["type"] = "input-date-range"<br>                kwargs["format"] = "YYYY-MM-DD"<br>            elif issubclass(type_, datetime.time):<br>                kwargs["type"] = "input-time-range"<br>                kwargs["format"] = "HH:mm:ss"<br>            else:<br>                kwargs["type"] = "input-text"<br>        elif issubclass(type_, int):<br>            kwargs["type"] = "input-number"<br>            kwargs["precision"] = 0<br>            kwargs["validations"] = Validation(isInt=True).amis_dict()<br>        elif issubclass(type_, float):<br>            kwargs["type"] = "input-number"<br>     </code></pre></div></td>
    </tr>
    <tr>
      <td>html_report</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a GET request to `/conversation_report`.<br>- It takes several optional query parameters for filtering and sorting feedback data.<br>- The function parses these parameters and passes them to a helper function `get_feedbacks()`, which returns a list of feedback objects.<br>- The resulting feedback list is passed to Pandas DataFrame, which generates an HTML table with formatted output using custom format functions provided by the `formatters` parameter.<br>- Finally, the generated HTML response is returned as a FastAPI HTTP response object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/conversation_report")<br>def get_feedback_dashboard(<br>    is_admin: Annotated[bool, Depends(ensure_admin_account)],<br>    start: str | None = None,<br>    end: str | None = None,<br>    user_email: str | None = None,<br>    has_text: bool | None = None,<br>    did_join: bool | None = None,<br>):<br>    # Parse arguments<br>    if start:<br>        start = datetime.datetime.strptime(start, "%Y-%m-%d")<br>    if end:<br>        end = datetime.datetime.strptime(end, "%Y-%m-%d")<br>    if has_text:<br>        has_text = has_text in ["true", "True", "1"]<br>    if did_join:<br>        did_join = did_join in ["true", "True", "1"]<br><br>    # Defaults<br>    if not start:<br>        start = last_monday(last_week_if_today=False)<br><br>    feedbacks = get_feedbacks(<br>        start=start,<br>        end=end,<br>        user_email=user_email,<br>        has_text=has_text,<br>        did_join=did_join,<br>    )<br><br>    format_dict = (<br>        lambda d: f'<div style="white-space:pre-wrap">{html.escape(json.dumps(d, indent=4, default=str))}</div>'<br>    )<br>    return HTMLResponse(<br>        pd.DataFrame(feedbacks).to_html(<br>            escape=False,<br>            formatters={<br>                "type_counts": format_dict,<br>                "examples": format_dict,<br>            },<br>        )<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/items/{id}", response_class=HTMLResponse)<br>async def read_item(request: Request, id: str):<br>    return templates.TemplateResponse("item.html", {"request": request, "id": id})</code></pre></div></td>
    </tr>
    <tr>
      <td>html_report</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a GET request to `/conversation_report`.<br>- It takes several optional query parameters for filtering and sorting feedback data.<br>- The function parses these parameters and passes them to a helper function `get_feedbacks()`, which returns a list of feedback objects.<br>- The resulting feedback list is passed to Pandas DataFrame, which generates an HTML table with formatted output using custom format functions provided by the `formatters` parameter.<br>- Finally, the generated HTML response is returned as a FastAPI HTTP response object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/conversation_report")<br>def get_feedback_dashboard(<br>    is_admin: Annotated[bool, Depends(ensure_admin_account)],<br>    start: str | None = None,<br>    end: str | None = None,<br>    user_email: str | None = None,<br>    has_text: bool | None = None,<br>    did_join: bool | None = None,<br>):<br>    # Parse arguments<br>    if start:<br>        start = datetime.datetime.strptime(start, "%Y-%m-%d")<br>    if end:<br>        end = datetime.datetime.strptime(end, "%Y-%m-%d")<br>    if has_text:<br>        has_text = has_text in ["true", "True", "1"]<br>    if did_join:<br>        did_join = did_join in ["true", "True", "1"]<br><br>    # Defaults<br>    if not start:<br>        start = last_monday(last_week_if_today=False)<br><br>    feedbacks = get_feedbacks(<br>        start=start,<br>        end=end,<br>        user_email=user_email,<br>        has_text=has_text,<br>        did_join=did_join,<br>    )<br><br>    format_dict = (<br>        lambda d: f'<div style="white-space:pre-wrap">{html.escape(json.dumps(d, indent=4, default=str))}</div>'<br>    )<br>    return HTMLResponse(<br>        pd.DataFrame(feedbacks).to_html(<br>            escape=False,<br>            formatters={<br>                "type_counts": format_dict,<br>                "examples": format_dict,<br>            },<br>        )<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/items/", response_class=HTMLResponse)<br>async def read_items():<br>    return generate_html_response()</code></pre></div></td>
    </tr>
    <tr>
      <td>html_report</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a GET request to `/conversation_report`.<br>- It takes several optional query parameters for filtering and sorting feedback data.<br>- The function parses these parameters and passes them to a helper function `get_feedbacks()`, which returns a list of feedback objects.<br>- The resulting feedback list is passed to Pandas DataFrame, which generates an HTML table with formatted output using custom format functions provided by the `formatters` parameter.<br>- Finally, the generated HTML response is returned as a FastAPI HTTP response object.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/conversation_report")<br>def get_feedback_dashboard(<br>    is_admin: Annotated[bool, Depends(ensure_admin_account)],<br>    start: str | None = None,<br>    end: str | None = None,<br>    user_email: str | None = None,<br>    has_text: bool | None = None,<br>    did_join: bool | None = None,<br>):<br>    # Parse arguments<br>    if start:<br>        start = datetime.datetime.strptime(start, "%Y-%m-%d")<br>    if end:<br>        end = datetime.datetime.strptime(end, "%Y-%m-%d")<br>    if has_text:<br>        has_text = has_text in ["true", "True", "1"]<br>    if did_join:<br>        did_join = did_join in ["true", "True", "1"]<br><br>    # Defaults<br>    if not start:<br>        start = last_monday(last_week_if_today=False)<br><br>    feedbacks = get_feedbacks(<br>        start=start,<br>        end=end,<br>        user_email=user_email,<br>        has_text=has_text,<br>        did_join=did_join,<br>    )<br><br>    format_dict = (<br>        lambda d: f'<div style="white-space:pre-wrap">{html.escape(json.dumps(d, indent=4, default=str))}</div>'<br>    )<br>    return HTMLResponse(<br>        pd.DataFrame(feedbacks).to_html(<br>            escape=False,<br>            formatters={<br>                "type_counts": format_dict,<br>                "examples": format_dict,<br>            },<br>        )<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/items/")<br>async def read_items():<br>    html_content = """<br>    <html><br>        <head><br>            <title>Some HTML in here</title><br>        </head><br>        <body><br>            <h1>Look ma! HTML!</h1><br>        </body><br>    </html><br>    """<br>    return HTMLResponse(content=html_content, status_code=200)</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET request endpoint for logging in at `/login`.<br>- Returns no response (None).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def login():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>def login(form_data: OAuth2PasswordRequestFormStrict = Depends()):<br>    return form_data</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET request endpoint for logging in at `/login`.<br>- Returns no response (None).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def login():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">            @self.router.get("/hello")<br>            def hello():<br>                return {"username": "hello"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET request endpoint for logging in at `/login`.<br>- Returns no response (None).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def login():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login/")<br>async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]):<br>    return {"username": username}</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET request endpoint for logging in at `/login`.<br>- Returns no response (None).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def login():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_login(client: TestClient) -> None:<br>    """<br>    测试登录<br>    自行使用 /app/create_user.py 创建任意测试用户<br>    test@test.com<br>    test<br>    :return:<br>    """<br>    response = client.post(<br>        "/admin/auth/login/access-token",<br>        json={"username": "test@test.com", "password": "test"},<br>    )<br>    assert response.status_code == 200<br>    assert response.json()["code"] == 200<br>    assert response.json()["data"]["token"]</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET request endpoint for logging in at `/login`.<br>- Returns no response (None).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def login():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/login/test-token", response_model=User)<br>def test_token(current_user: UserInDB = Depends(get_current_user)):<br>    """<br>    Test access token.<br>    """<br>    return current_user</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET request endpoint for logging in at `/login`.<br>- Returns no response (None).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def login():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/login/", response_model=Token)<br>async def login(<br>    data: OAuth2PasswordRequestForm = Depends(),<br>    session: AsyncSession = Depends(get_session),<br>):<br>    user = await authenticate(session, email=data.username, password=data.password)<br>    if user is None:<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br>    if not user.is_active:<br>        raise HTTPException(status_code=400, detail="Inactive user")<br>    return {"access_token": create_access_token(user), "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET request endpoint for logging in at `/login`.<br>- Returns no response (None).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def login():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@callback_router0.get("/")<br>async def callback0(level0: str):<br>    pass  # pragma: nocover</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET request endpoint for logging in at `/login`.<br>- Returns no response (None).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def login():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/")<br>async def root():<br>    return {"message": "Hello Bigger Applications!"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET request endpoint for logging in at `/login`.<br>- Returns no response (None).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def login():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">        @app.get("/", responses={"500": {"model": NonPydanticModel}})<br>        def read_root():<br>            pass  # pragma: nocover</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This endpoint handles POST requests to `/chat/feedback`.<br>- It returns a `FeedbackResponse` object with the provided feedback information.<br>- If the requested message is not found, it raises a `HTTPException` with status code 404 and error message "Message not found".<br>- The login guard checks for an active user session using FastAPI's dependency injection system (`Depends`) and raises a `HTTPException` with status code 401 and error message "Unauthorized" if no session exists.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@callback_router.get(<br>    "{$callback_url}/callback/", responses={400: {"model": CustomModel}}<br>)<br>def callback_route():<br>    pass  # pragma: no cover</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This endpoint handles POST requests to `/chat/feedback`.<br>- It returns a `FeedbackResponse` object with the provided feedback information.<br>- If the requested message is not found, it raises a `HTTPException` with status code 404 and error message "Message not found".<br>- The login guard checks for an active user session using FastAPI's dependency injection system (`Depends`) and raises a `HTTPException` with status code 401 and error message "Unauthorized" if no session exists.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/", response_model=Job, status_code=201)<br>async def create_task(message: str):<br>    job = await redis.pool.enqueue_job("test_task", message)<br>    return {"id": job.job_id}</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This endpoint handles POST requests to `/chat/feedback`.<br>- It returns a `FeedbackResponse` object with the provided feedback information.<br>- If the requested message is not found, it raises a `HTTPException` with status code 404 and error message "Message not found".<br>- The login guard checks for an active user session using FastAPI's dependency injection system (`Depends`) and raises a `HTTPException` with status code 401 and error message "Unauthorized" if no session exists.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/login/", response_model=Token)<br>async def login(<br>    data: OAuth2PasswordRequestForm = Depends(),<br>    session: AsyncSession = Depends(get_session),<br>):<br>    user = await authenticate(session, email=data.username, password=data.password)<br>    if user is None:<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br>    if not user.is_active:<br>        raise HTTPException(status_code=400, detail="Inactive user")<br>    return {"access_token": create_access_token(user), "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This endpoint handles POST requests to `/chat/feedback`.<br>- It returns a `FeedbackResponse` object with the provided feedback information.<br>- If the requested message is not found, it raises a `HTTPException` with status code 404 and error message "Message not found".<br>- The login guard checks for an active user session using FastAPI's dependency injection system (`Depends`) and raises a `HTTPException` with status code 401 and error message "Unauthorized" if no session exists.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def get_graphql_response(<br>    *,<br>    settings: Settings,<br>    query: str,<br>    after: Union[str, None] = None,<br>    category_id: Union[str, None] = None,<br>    discussion_number: Union[int, None] = None,<br>    discussion_id: Union[str, None] = None,<br>    comment_id: Union[str, None] = None,<br>    body: Union[str, None] = None,<br>) -> Dict[str, Any]:<br>    headers = {"Authorization": f"token {settings.input_token.get_secret_value()}"}<br>    # some fields are only used by one query, but GraphQL allows unused variables, so<br>    # keep them here for simplicity<br>    variables = {<br>        "after": after,<br>        "category_id": category_id,<br>        "discussion_number": discussion_number,<br>        "discussion_id": discussion_id,<br>        "comment_id": comment_id,<br>        "body": body,<br>    }<br>    response = httpx.post(<br>        github_graphql_url,<br>        headers=headers,<br>        timeout=settings.httpx_timeout,<br>        json={"query": query, "variables": variables, "operationName": "Q"},<br>    )<br>    if response.status_code != 200:<br>        logging.error(<br>            f"Response was not 200, after: {after}, category_id: {category_id}"<br>        )<br>        logging.error(response.text)<br>        raise RuntimeError(response.text)<br>    data = response.json()<br>    if "errors" in data:<br>        logging.error(f"Errors in response, after: {after}, category_id: {category_id}")<br>        logging.error(response.text)<br>        raise RuntimeError(response.text)<br>    return cast(Dict[str, Any], data)</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This endpoint handles POST requests to `/chat/feedback`.<br>- It returns a `FeedbackResponse` object with the provided feedback information.<br>- If the requested message is not found, it raises a `HTTPException` with status code 404 and error message "Message not found".<br>- The login guard checks for an active user session using FastAPI's dependency injection system (`Depends`) and raises a `HTTPException` with status code 401 and error message "Unauthorized" if no session exists.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.put("/{user_id}/", response_model=UserOut, dependencies=[Depends(on_superuser)])<br>async def update_user(<br>    user_id: int, user_in: UserUpdate, session: AsyncSession = Depends(get_session)<br>):<br>    user = await crud_user.get(session, id=user_id)<br>    if user is None:<br>        raise HTTPException(<br>            status_code=404,<br>            detail="The user with this username does not exist in the system",<br>        )<br>    try:<br>        user = await crud_user.update(<br>            session,<br>            db_obj=user,<br>            obj_in={<br>                **user_in.dict(exclude={"password"}, exclude_none=True),<br>                "hashed_password": get_password_hash(user_in.password),<br>            },<br>        )<br>    except IntegrityError:<br>        raise HTTPException(<br>            status_code=409, detail="User with this username already exits"<br>        )<br>    return user</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This endpoint handles POST requests to `/chat/feedback`.<br>- It returns a `FeedbackResponse` object with the provided feedback information.<br>- If the requested message is not found, it raises a `HTTPException` with status code 404 and error message "Message not found".<br>- The login guard checks for an active user session using FastAPI's dependency injection system (`Depends`) and raises a `HTTPException` with status code 401 and error message "Unauthorized" if no session exists.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def app(request: Request) -> Response:<br>        try:<br>            body: Any = None<br>            if body_field:<br>                if is_body_form:<br>                    body = await request.form()<br>                    stack = request.scope.get("fastapi_astack")<br>                    assert isinstance(stack, AsyncExitStack)<br>                    stack.push_async_callback(body.close)<br>                else:<br>                    body_bytes = await request.body()<br>                    if body_bytes:<br>                        json_body: Any = Undefined<br>                        content_type_value = request.headers.get("content-type")<br>                        if not content_type_value:<br>                            json_body = await request.json()<br>                        else:<br>                            message = email.message.Message()<br>                            message["content-type"] = content_type_value<br>                            if message.get_content_maintype() == "application":<br>                                subtype = message.get_content_subtype()<br>                                if subtype == "json" or subtype.endswith("+json"):<br>                                    json_body = await request.json()<br>                        if json_body != Undefined:<br>                            body = json_body<br>                        else:<br>                            body = body_bytes<br>        except json.JSONDecodeError as e:<br>            raise RequestValidationError(<br>                [<br>                    {<br>                        "type": "json_invalid",<br>                        "loc": ("body", e.pos),<br>                        "msg": "JSON decode error",<br>                        "input": {},<br>                        "ctx": {"error": e.msg},<br>                    }<br>                ],<br>                body=e.doc,<br>            ) from e<br>        except HTTPException:<br>            raise<br>        except Exception as e:<br>            raise HTTPException(<br>                status_code=400, detail="There was an error pa</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This endpoint handles POST requests to `/chat/feedback`.<br>- It returns a `FeedbackResponse` object with the provided feedback information.<br>- If the requested message is not found, it raises a `HTTPException` with status code 404 and error message "Message not found".<br>- The login guard checks for an active user session using FastAPI's dependency injection system (`Depends`) and raises a `HTTPException` with status code 401 and error message "Unauthorized" if no session exists.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/register", response_model=UserResponse)<br>async def register_new_user(<br>    new_user: UserCreateRequest,<br>    session: AsyncSession = Depends(deps.get_session),<br>):<br>    """Create new user"""<br>    result = await session.execute(select(User).where(User.email == new_user.email))<br>    if result.scalars().first() is not None:<br>        raise HTTPException(status_code=400, detail="Cannot use this email address")<br>    user = User(<br>        email=new_user.email,<br>        hashed_password=get_password_hash(new_user.password),<br>    )<br>    session.add(user)<br>    await session.commit()<br>    return user</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This endpoint handles POST requests to `/chat/feedback`.<br>- It returns a `FeedbackResponse` object with the provided feedback information.<br>- If the requested message is not found, it raises a `HTTPException` with status code 404 and error message "Message not found".<br>- The login guard checks for an active user session using FastAPI's dependency injection system (`Depends`) and raises a `HTTPException` with status code 401 and error message "Unauthorized" if no session exists.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def login(form_data: OAuth2PasswordRequestForm = Depends()):<br>    """<br>    OAuth2 compatible token login, get an access token for future requests.<br>    """<br>    bucket = get_default_bucket()<br>    user = crud.user.authenticate(<br>        bucket, username=form_data.username, password=form_data.password<br>    )<br>    if not user:<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br>    elif not crud.user.is_active(user):<br>        raise HTTPException(status_code=400, detail="Inactive user")<br>    access_token_expires = timedelta(minutes=config.ACCESS_TOKEN_EXPIRE_MINUTES)<br>    return {<br>        "access_token": create_access_token(<br>            data={"username": user.username}, expires_delta=access_token_expires<br>        ),<br>        "token_type": "bearer",<br>    }</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This endpoint handles POST requests to `/chat/feedback`.<br>- It returns a `FeedbackResponse` object with the provided feedback information.<br>- If the requested message is not found, it raises a `HTTPException` with status code 404 and error message "Message not found".<br>- The login guard checks for an active user session using FastAPI's dependency injection system (`Depends`) and raises a `HTTPException` with status code 401 and error message "Unauthorized" if no session exists.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/{id}", response_model=Item)<br>def read_item(id: str, current_user: UserInDB = Depends(get_current_active_user)):<br>    """<br>    Get item by ID.<br>    """<br>    bucket = get_default_bucket()<br>    doc = crud.item.get(bucket=bucket, id=id)<br>    if not doc:<br>        raise HTTPException(status_code=404, detail="Item not found")<br>    if not crud.user.is_superuser(current_user) and (<br>        doc.owner_username != current_user.username<br>    ):<br>        raise HTTPException(status_code=400, detail="Not enough permissions")<br>    return doc</code></pre></div></td>
    </tr>
    <tr>
      <td>get_commutes</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Endpoint to retrieve a list of all commutes from the database using Pydantic's `response_model`.<br>- Uses Stream API to efficiently fetch all documents from the "commutes" collection and converts them into dictionary format using `to_dict()`.<br>- Returns the list of dictionaries as JSON response.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/", response_model=list[CommuteEntity])<br>async def get_commutes() -> list[CommuteEntity]:<br>    """<br>    Get all the commutes (not user specific yet)<br>    """<br><br>    # Get all the commutes<br>    commutes = db.collection("commutes").stream()<br><br>    # Return the commutes<br>    return [commute.to_dict() for commute in commutes]</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/notes/", response_model=List[Note])<br>async def read_notes():<br>    query = notes.select()<br>    return await database.fetch_all(query)</code></pre></div></td>
    </tr>
    <tr>
      <td>get_commutes</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Endpoint to retrieve a list of all commutes from the database using Pydantic's `response_model`.<br>- Uses Stream API to efficiently fetch all documents from the "commutes" collection and converts them into dictionary format using `to_dict()`.<br>- Returns the list of dictionaries as JSON response.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/", response_model=list[CommuteEntity])<br>async def get_commutes() -> list[CommuteEntity]:<br>    """<br>    Get all the commutes (not user specific yet)<br>    """<br><br>    # Get all the commutes<br>    commutes = db.collection("commutes").stream()<br><br>    # Return the commutes<br>    return [commute.to_dict() for commute in commutes]</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/items/", response_model=list[Item])<br>async def get_items():<br>    return [<br>        {"name": "Plumbus", "price": 3},<br>        {"name": "Portal Gun", "price": 9001},<br>    ]</code></pre></div></td>
    </tr>
    <tr>
      <td>get_commutes</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Endpoint to retrieve a list of all commutes from the database using Pydantic's `response_model`.<br>- Uses Stream API to efficiently fetch all documents from the "commutes" collection and converts them into dictionary format using `to_dict()`.<br>- Returns the list of dictionaries as JSON response.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/", response_model=list[CommuteEntity])<br>async def get_commutes() -> list[CommuteEntity]:<br>    """<br>    Get all the commutes (not user specific yet)<br>    """<br><br>    # Get all the commutes<br>    commutes = db.collection("commutes").stream()<br><br>    # Return the commutes<br>    return [commute.to_dict() for commute in commutes]</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/pets/", response_model=List[PetOut])<br>async def read_pets():<br>    user = UserDB(<br>        email="johndoe@example.com",<br>        hashed_password="secrethashed",<br>    )<br>    pet1 = PetDB(name="Nibbler", owner=user)<br>    pet2 = PetDB(name="Zoidberg", owner=user)<br>    return [pet1, pet2]</code></pre></div></td>
    </tr>
    <tr>
      <td>get_commutes</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Endpoint to retrieve a list of all commutes from the database using Pydantic's `response_model`.<br>- Uses Stream API to efficiently fetch all documents from the "commutes" collection and converts them into dictionary format using `to_dict()`.<br>- Returns the list of dictionaries as JSON response.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/", response_model=list[CommuteEntity])<br>async def get_commutes() -> list[CommuteEntity]:<br>    """<br>    Get all the commutes (not user specific yet)<br>    """<br><br>    # Get all the commutes<br>    commutes = db.collection("commutes").stream()<br><br>    # Return the commutes<br>    return [commute.to_dict() for commute in commutes]</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users")<br>async def read_users2():<br>    return ["Bean", "Elfo"]</code></pre></div></td>
    </tr>
    <tr>
      <td>get_commutes</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Endpoint to retrieve a list of all commutes from the database using Pydantic's `response_model`.<br>- Uses Stream API to efficiently fetch all documents from the "commutes" collection and converts them into dictionary format using `to_dict()`.<br>- Returns the list of dictionaries as JSON response.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/", response_model=list[CommuteEntity])<br>async def get_commutes() -> list[CommuteEntity]:<br>    """<br>    Get all the commutes (not user specific yet)<br>    """<br><br>    # Get all the commutes<br>    commutes = db.collection("commutes").stream()<br><br>    # Return the commutes<br>    return [commute.to_dict() for commute in commutes]</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users")<br>async def read_users():<br>    return ["Rick", "Morty"]</code></pre></div></td>
    </tr>
    <tr>
      <td>get_commutes</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Endpoint to retrieve a list of all commutes from the database using Pydantic's `response_model`.<br>- Uses Stream API to efficiently fetch all documents from the "commutes" collection and converts them into dictionary format using `to_dict()`.<br>- Returns the list of dictionaries as JSON response.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/", response_model=list[CommuteEntity])<br>async def get_commutes() -> list[CommuteEntity]:<br>    """<br>    Get all the commutes (not user specific yet)<br>    """<br><br>    # Get all the commutes<br>    commutes = db.collection("commutes").stream()<br><br>    # Return the commutes<br>    return [commute.to_dict() for commute in commutes]</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users/")<br>async def read_users():<br>    return [{"username": "Rick"}, {"username": "Morty"}]</code></pre></div></td>
    </tr>
    <tr>
      <td>get_commutes</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Endpoint to retrieve a list of all commutes from the database using Pydantic's `response_model`.<br>- Uses Stream API to efficiently fetch all documents from the "commutes" collection and converts them into dictionary format using `to_dict()`.<br>- Returns the list of dictionaries as JSON response.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/", response_model=list[CommuteEntity])<br>async def get_commutes() -> list[CommuteEntity]:<br>    """<br>    Get all the commutes (not user specific yet)<br>    """<br><br>    # Get all the commutes<br>    commutes = db.collection("commutes").stream()<br><br>    # Return the commutes<br>    return [commute.to_dict() for commute in commutes]</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/pets/", response_model=List[PetOut])<br>async def read_pets():<br>    user = UserDB(<br>        email="johndoe@example.com",<br>        hashed_password="secrethashed",<br>    )<br>    pet1 = PetDB(name="Nibbler", owner=user)<br>    pet2 = PetDB(name="Zoidberg", owner=user)<br>    return [pet1, pet2]</code></pre></div></td>
    </tr>
    <tr>
      <td>get_commutes</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Endpoint to retrieve a list of all commutes from the database using Pydantic's `response_model`.<br>- Uses Stream API to efficiently fetch all documents from the "commutes" collection and converts them into dictionary format using `to_dict()`.<br>- Returns the list of dictionaries as JSON response.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/", response_model=list[CommuteEntity])<br>async def get_commutes() -> list[CommuteEntity]:<br>    """<br>    Get all the commutes (not user specific yet)<br>    """<br><br>    # Get all the commutes<br>    commutes = db.collection("commutes").stream()<br><br>    # Return the commutes<br>    return [commute.to_dict() for commute in commutes]</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/teams/", response_model=List[TeamRead])<br>def read_teams(<br>    *,<br>    session: Session = Depends(get_session),<br>    offset: int = 0,<br>    limit: int = Query(default=100, le=100),<br>):<br>    teams = session.exec(select(Team).offset(offset).limit(limit)).all()<br>    return teams</code></pre></div></td>
    </tr>
    <tr>
      <td>get_commutes</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Endpoint to retrieve a list of all commutes from the database using Pydantic's `response_model`.<br>- Uses Stream API to efficiently fetch all documents from the "commutes" collection and converts them into dictionary format using `to_dict()`.<br>- Returns the list of dictionaries as JSON response.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/", response_model=list[CommuteEntity])<br>async def get_commutes() -> list[CommuteEntity]:<br>    """<br>    Get all the commutes (not user specific yet)<br>    """<br><br>    # Get all the commutes<br>    commutes = db.collection("commutes").stream()<br><br>    # Return the commutes<br>    return [commute.to_dict() for commute in commutes]</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/items/objectlist", response_model=List[Item])<br>def get_objectlist():<br>    return [<br>        Item(name="foo", date=datetime(2021, 7, 26)),<br>        Item(name="bar", date=datetime(2021, 7, 26), price=1.0),<br>        Item(name="baz", date=datetime(2021, 7, 26), price=2.0, owner_ids=[1, 2, 3]),<br>    ]</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET endpoint at `/health` for performing a health check on the application<br>- Returns a JSON response with a status of 'ok' and an optional description in the HTTP response metadata (as specified by the `responses` dictionary)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/", status_code=204)<br>async def health(session: AsyncSession = Depends(get_session)):<br>    try:<br>        await asyncio.wait_for(session.execute("SELECT 1"), timeout=1)<br>    except (asyncio.TimeoutError, socket.gaierror):<br>        return Response(status_code=503)<br>    return Response(status_code=204)</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET endpoint at `/health` for performing a health check on the application<br>- Returns a JSON response with a status of 'ok' and an optional description in the HTTP response metadata (as specified by the `responses` dictionary)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/healthcheck", include_in_schema=False)<br>async def healthcheck() -> dict[str, str]:<br>    return {"status": "ok"}</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET endpoint at `/health` for performing a health check on the application<br>- Returns a JSON response with a status of 'ok' and an optional description in the HTTP response metadata (as specified by the `responses` dictionary)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def healthcheck() -> dict[str, str]:<br>    return {"status": "ok"}</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET endpoint at `/health` for performing a health check on the application<br>- Returns a JSON response with a status of 'ok' and an optional description in the HTTP response metadata (as specified by the `responses` dictionary)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("")<br>def get_empty():<br>    return ["OK"]</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET endpoint at `/health` for performing a health check on the application<br>- Returns a JSON response with a status of 'ok' and an optional description in the HTTP response metadata (as specified by the `responses` dictionary)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_openapi():<br>    response = client.get("/openapi.json")<br>    assert response.status_code == 200<br>    assert response.json() == {<br>        "openapi": "3.1.0",<br>        "info": {"title": "FastAPI", "version": "0.1.0"},<br>        "paths": {<br>            "/app": {<br>                "get": {<br>                    "summary": "Read Main",<br>                    "operationId": "read_main_app_get",<br>                    "responses": {<br>                        "200": {<br>                            "description": "Successful Response",<br>                            "content": {"application/json": {"schema": {}}},<br>                        }<br>                    },<br>                }<br>            }<br>        },<br>        "servers": [{"url": "/api/v1"}],<br>    }</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET endpoint at `/health` for performing a health check on the application<br>- Returns a JSON response with a status of 'ok' and an optional description in the HTTP response metadata (as specified by the `responses` dictionary)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_openapi_schema():<br>    response = client.get("/openapi.json")<br>    assert response.status_code == 200, response.text<br>    assert response.json() == {<br>        "openapi": "3.1.0",<br>        "info": {"title": "FastAPI", "version": "0.1.0"},<br>        "paths": {<br>            "/": {<br>                "get": {<br>                    "summary": "Main",<br>                    "operationId": "main__get",<br>                    "responses": {<br>                        "200": {<br>                            "description": "Successful Response",<br>                            "content": {"text/plain": {"schema": {"type": "string"}}},<br>                        }<br>                    },<br>                }<br>            }<br>        },<br>    }</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET endpoint at `/health` for performing a health check on the application<br>- Returns a JSON response with a status of 'ok' and an optional description in the HTTP response metadata (as specified by the `responses` dictionary)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/healthcheck", include_in_schema=False)<br>async def healthcheck() -> dict[str, str]:<br>    return {"status": "ok"}</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET endpoint at `/health` for performing a health check on the application<br>- Returns a JSON response with a status of 'ok' and an optional description in the HTTP response metadata (as specified by the `responses` dictionary)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def healthcheck() -> dict[str, str]:<br>    return {"status": "ok"}</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a GET endpoint at `/health` for performing a health check on the application<br>- Returns a JSON response with a status of 'ok' and an optional description in the HTTP response metadata (as specified by the `responses` dictionary)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/healthz", description="Health Check", tags=["Health Check"])<br>def ping():<br>    """Health check."""<br>    return {"ping": "pong!"}</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves a specific room with ID `room_id` using FastAPI's dependency injection to access the database and current user session.<br>- Converts the retrieved model object into a schema for serialization and returns it as JSON response.<br>- Includes relevant information such as start time, end time, number of RSVPs, and whether the authenticated user has already RSVP'd.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/{user_id}",<br>    response_model=schemas.User,<br>    dependencies=[Depends(deps.get_current_active_superuser)],<br>)<br>def read_user_by_id(user: models.User = Depends(get_user)):<br>    """Get a specific user by id."""<br>    return user</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves a specific room with ID `room_id` using FastAPI's dependency injection to access the database and current user session.<br>- Converts the retrieved model object into a schema for serialization and returns it as JSON response.<br>- Includes relevant information such as start time, end time, number of RSVPs, and whether the authenticated user has already RSVP'd.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/{id}", response_model=schemas.Item)<br>def read_item(<br>    *,<br>    item: models.Item = Depends(get_item),<br>    user: models.User = Depends(deps.get_current_active_user),<br>):<br>    """Get item by id."""<br>    if not crud.user.is_superuser(user) and (item.owner_id != user.id):<br>        raise HTTPException(status_code=400, detail="Not enough permissions.")<br>    return item</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves a specific room with ID `room_id` using FastAPI's dependency injection to access the database and current user session.<br>- Converts the retrieved model object into a schema for serialization and returns it as JSON response.<br>- Includes relevant information such as start time, end time, number of RSVPs, and whether the authenticated user has already RSVP'd.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@user_router.get("/{user_id}")<br>def get_user(user_id: str):<br>    return {"user_id": user_id}</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves a specific room with ID `room_id` using FastAPI's dependency injection to access the database and current user session.<br>- Converts the retrieved model object into a schema for serialization and returns it as JSON response.<br>- Includes relevant information such as start time, end time, number of RSVPs, and whether the authenticated user has already RSVP'd.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def test_schema_list(app: FastAPI, async_client: AsyncClient, fake_users, models):<br>    class UserList(BaseModel):<br>        id: int<br>        username: str<br><br>    class UserCrud(SqlalchemyCrud):<br>        router_prefix = "/user"<br>        schema_list = UserList<br><br>    ins = UserCrud(models.User, db.engine).register_crud()<br><br>    app.include_router(ins.router)<br><br>    # test schemas<br>    openapi = app.openapi()<br>    schemas = openapi["components"]["schemas"]<br>    assert "password" not in schemas["UserList"]["properties"]<br>    assert "username" in schemas["UserList"]["properties"]<br><br>    # test api<br>    res = await async_client.post("/user/list", json={"id": 1})<br>    items = res.json()["data"]["items"]<br>    assert items[0]["id"] == 1<br>    assert "username" in items[0]<br>    assert "password" not in items[0]</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves a specific room with ID `room_id` using FastAPI's dependency injection to access the database and current user session.<br>- Converts the retrieved model object into a schema for serialization and returns it as JSON response.<br>- Includes relevant information such as start time, end time, number of RSVPs, and whether the authenticated user has already RSVP'd.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def test_list_filter(app: FastAPI, async_client: AsyncClient, fake_users, models):<br>    class UserCrud(SqlalchemyCrud):<br>        router_prefix = "/user"<br>        list_filter = [models.User.id, models.User.username]<br><br>    ins = UserCrud(models.User, db.engine).register_crud()<br><br>    app.include_router(ins.router)<br><br>    assert "username" in model_fields(ins.schema_filter)<br>    assert "password" not in model_fields(ins.schema_filter)<br><br>    # test schemas<br>    openapi = app.openapi()<br>    schemas = openapi["components"]["schemas"]<br>    assert "username" in schemas["UserCrudFilter"]["properties"]<br>    assert "password" not in schemas["UserCrudFilter"]["properties"]<br><br>    # test api<br>    res = await async_client.post("/user/list", json={"id": 2})<br>    items = res.json()["data"]["items"]<br>    assert items[0]["id"] == 2<br><br>    res = await async_client.post("/user/list", json={"username": "User_2"})<br>    items = res.json()["data"]["items"]<br>    assert items[0]["username"] == "User_2"<br><br>    res = await async_client.post("/user/list", json={"password": "new_password"})<br>    items = res.json()["data"]["items"]<br>    assert items</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves a specific room with ID `room_id` using FastAPI's dependency injection to access the database and current user session.<br>- Converts the retrieved model object into a schema for serialization and returns it as JSON response.<br>- Includes relevant information such as start time, end time, number of RSVPs, and whether the authenticated user has already RSVP'd.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@needs_pydanticv2<br>def test_settings(monkeypatch: MonkeyPatch):<br>    monkeypatch.setenv("ADMIN_EMAIL", "admin@example.com")<br>    from docs_src.settings.tutorial001 import app<br><br>    client = TestClient(app)<br>    response = client.get("/info")<br>    assert response.status_code == 200, response.text<br>    assert response.json() == {<br>        "app_name": "Awesome API",<br>        "admin_email": "admin@example.com",<br>        "items_per_user": 50,<br>    }</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves a specific room with ID `room_id` using FastAPI's dependency injection to access the database and current user session.<br>- Converts the retrieved model object into a schema for serialization and returns it as JSON response.<br>- Includes relevant information such as start time, end time, number of RSVPs, and whether the authenticated user has already RSVP'd.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users/{user_id}", response_model=schemas.User)<br>def read_user(user_id: int, db: Session = Depends(get_db)):<br>    db_user = crud.get_user(db, user_id=user_id)<br>    if db_user is None:<br>        raise HTTPException(status_code=404, detail="User not found")<br>    return db_user</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves a specific room with ID `room_id` using FastAPI's dependency injection to access the database and current user session.<br>- Converts the retrieved model object into a schema for serialization and returns it as JSON response.<br>- Includes relevant information such as start time, end time, number of RSVPs, and whether the authenticated user has already RSVP'd.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def read_item(id: str, current_user: UserInDB = Depends(get_current_active_user)):<br>    """<br>    Get item by ID.<br>    """<br>    bucket = get_default_bucket()<br>    doc = crud.item.get(bucket=bucket, id=id)<br>    if not doc:<br>        raise HTTPException(status_code=404, detail="Item not found")<br>    if not crud.user.is_superuser(current_user) and (<br>        doc.owner_username != current_user.username<br>    ):<br>        raise HTTPException(status_code=400, detail="Not enough permissions")<br>    return doc</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves a specific room with ID `room_id` using FastAPI's dependency injection to access the database and current user session.<br>- Converts the retrieved model object into a schema for serialization and returns it as JSON response.<br>- Includes relevant information such as start time, end time, number of RSVPs, and whether the authenticated user has already RSVP'd.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/heroes/{hero_id}", response_model=HeroRead)<br>def read_hero(*, session: Session = Depends(get_session), hero_id: int):<br>    hero = session.get(Hero, hero_id)<br>    if not hero:<br>        raise HTTPException(status_code=404, detail="Hero not found")<br>    return hero</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a custom middleware that checks authentication for certain routes<br>- Allows access to non-API routes and OPTIONS requests without requiring authentication<br>- Verifies Firebase ID tokens for authenticated users and sets them as state variables on the request object</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        authorization = request.headers.get("Authorization")<br>        scheme, param = get_authorization_scheme_param(authorization)<br>        if not authorization or scheme.lower() != "bearer":<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_401_UNAUTHORIZED,<br>                    detail="Not authenticated",<br>                    headers={"WWW-Authenticate": "Bearer"},<br>                )<br>            else:<br>                return None  # pragma: nocover<br>        return param</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a custom middleware that checks authentication for certain routes<br>- Allows access to non-API routes and OPTIONS requests without requiring authentication<br>- Verifies Firebase ID tokens for authenticated users and sets them as state variables on the request object</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        authorization = request.headers.get("Authorization")<br>        if not authorization:<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        return authorization</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a custom middleware that checks authentication for certain routes<br>- Allows access to non-API routes and OPTIONS requests without requiring authentication<br>- Verifies Firebase ID tokens for authenticated users and sets them as state variables on the request object</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">        async def custom_route_handler(request: Request) -> Response:<br>            try:<br>                return await original_route_handler(request)<br>            except RequestValidationError as exc:<br>                body = await request.body()<br>                detail = {"errors": exc.errors(), "body": body.decode()}<br>                raise HTTPException(status_code=422, detail=detail)</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a custom middleware that checks authentication for certain routes<br>- Allows access to non-API routes and OPTIONS requests without requiring authentication<br>- Verifies Firebase ID tokens for authenticated users and sets them as state variables on the request object</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/refresh-token", response_model=AccessTokenResponse)<br>async def refresh_token(<br>    input: RefreshTokenRequest,<br>    session: AsyncSession = Depends(deps.get_session),<br>):<br>    """OAuth2 compatible token, get an access token for future requests using refresh token"""<br>    try:<br>        payload = jwt.decode(<br>            input.refresh_token,<br>            config.settings.SECRET_KEY,<br>            algorithms=[security.JWT_ALGORITHM],<br>        )<br>    except (jwt.DecodeError, ValidationError):<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, unknown error",<br>        )<br><br>    # JWT guarantees payload will be unchanged (and thus valid), no errors here<br>    token_data = security.JWTTokenPayload(**payload)<br><br>    if not token_data.refresh:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, cannot use access token",<br>        )<br>    now = int(time.time())<br>    if now < token_data.issued_at or now > token_data.expires_at:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, token expired or not yet valid",<br>        )<br><br>    result = await session.execute(select(User).where(User.id == token_data.sub))<br>    user = result.scalars().first()<br><br>    if user is None:<br>        raise HTTPException(status_code=404, detail="User not found")<br><br>    return security.generate_access_token_response(str(user.id))</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a custom middleware that checks authentication for certain routes<br>- Allows access to non-API routes and OPTIONS requests without requiring authentication<br>- Verifies Firebase ID tokens for authenticated users and sets them as state variables on the request object</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def refresh_token(<br>    input: RefreshTokenRequest,<br>    session: AsyncSession = Depends(deps.get_session),<br>):<br>    """OAuth2 compatible token, get an access token for future requests using refresh token"""<br>    try:<br>        payload = jwt.decode(<br>            input.refresh_token,<br>            config.settings.SECRET_KEY,<br>            algorithms=[security.JWT_ALGORITHM],<br>        )<br>    except (jwt.DecodeError, ValidationError):<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, unknown error",<br>        )<br><br>    # JWT guarantees payload will be unchanged (and thus valid), no errors here<br>    token_data = security.JWTTokenPayload(**payload)<br><br>    if not token_data.refresh:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, cannot use access token",<br>        )<br>    now = int(time.time())<br>    if now < token_data.issued_at or now > token_data.expires_at:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, token expired or not yet valid",<br>        )<br><br>    result = await session.execute(select(User).where(User.id == token_data.sub))<br>    user = result.scalars().first()<br><br>    if user is None:<br>        raise HTTPException(status_code=404, detail="User not found")<br><br>    return security.generate_access_token_response(str(user.id))</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a custom middleware that checks authentication for certain routes<br>- Allows access to non-API routes and OPTIONS requests without requiring authentication<br>- Verifies Firebase ID tokens for authenticated users and sets them as state variables on the request object</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def get_current_user(<br>    session: AsyncSession = Depends(get_session), token: str = Depends(reusable_oauth2)<br>) -> User:<br>    try:<br>        payload = jwt.decode(<br>            token, config.settings.SECRET_KEY, algorithms=[security.JWT_ALGORITHM]<br>        )<br>    except jwt.DecodeError:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials.",<br>        )<br>    # JWT guarantees payload will be unchanged (and thus valid), no errors here<br>    token_data = security.JWTTokenPayload(**payload)<br><br>    if token_data.refresh:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, cannot use refresh token",<br>        )<br>    now = int(time.time())<br>    if now < token_data.issued_at or now > token_data.expires_at:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, token expired or not yet valid",<br>        )<br><br>    result = await session.execute(select(User).where(User.id == token_data.sub))<br>    user = result.scalars().first()<br><br>    if not user:<br>        raise HTTPException(status_code=404, detail="User not found.")<br>    return user</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a custom middleware that checks authentication for certain routes<br>- Allows access to non-API routes and OPTIONS requests without requiring authentication<br>- Verifies Firebase ID tokens for authenticated users and sets them as state variables on the request object</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@needs_py310<br>def test_token_no_sub(client: TestClient):<br>    response = client.get(<br>        "/users/me",<br>        headers={<br>            "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjoiZm9vIn0.9ynBhuYb4e6aW3oJr_K_TBgwcMTDpRToQIE25L57rOE"<br>        },<br>    )<br>    assert response.status_code == 401, response.text<br>    assert response.json() == {"detail": "Could not validate credentials"}<br>    assert response.headers["WWW-Authenticate"] == 'Bearer scope="me"'</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a custom middleware that checks authentication for certain routes<br>- Allows access to non-API routes and OPTIONS requests without requiring authentication<br>- Verifies Firebase ID tokens for authenticated users and sets them as state variables on the request object</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def before_request(<br>    request: Request,<br>):<br>    if request.url.path not in ALLOW_LIST:<br>        try:<br>            authorization = request.headers.get("Authorization", None)<br>            if not authorization:<br>                raise NotAuthorized("Authorization Headers Required")<br>            token = authorization.split(" ")[1]<br>            content = decode_jwt(token)<br>            # staff = await adal.get_or_404(User, json.loads(content["sub"])["user"])<br>            # g.staff = staff<br>        except NotAuthorized as e:<br>            raise e<br>        except NotFound as e:<br>            raise NotAuthorized("no such staff")<br>        except Exception:<br>            # TODO: more specific error<br>            raise NotAuthorized("token not correct")</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a custom middleware that checks authentication for certain routes<br>- Allows access to non-API routes and OPTIONS requests without requiring authentication<br>- Verifies Firebase ID tokens for authenticated users and sets them as state variables on the request object</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@needs_py310<br>def test_token_inexistent_user(client: TestClient):<br>    response = client.get(<br>        "/users/me",<br>        headers={<br>            "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VybmFtZTpib2IifQ.HcfCW67Uda-0gz54ZWTqmtgJnZeNem0Q757eTa9EZuw"<br>        },<br>    )<br>    assert response.status_code == 401, response.text<br>    assert response.json() == {"detail": "Could not validate credentials"}<br>    assert response.headers["WWW-Authenticate"] == 'Bearer scope="me"'</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">1. This function handles the KeyCloak authentication callback after a successful login. It is required for localhost testing because KeyCloak uses `/callback` for localhost URLs.<br>2. The function takes several dependencies including the authorization service and configuration settings from the container.<br>3. It sends an HTTP POST request to the KeyCloak token endpoint with the necessary parameters such as the authorization code, client ID, secret, and redirect URI.<br>4. After receiving the response, it decodes the JWT token using the provided signing key and extracts relevant information like preferred username and email.<br>5. A new session object is created with the extracted information and saved in the authorization service.<br>6. Finally, the user is redirected back to the client application with a cookie containing their unique session identifier.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@callback_router.get(<br>    "{$callback_url}/callback/", responses={400: {"model": CustomModel}}<br>)<br>def callback_route():<br>    pass  # pragma: no cover</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">1. This function handles the KeyCloak authentication callback after a successful login. It is required for localhost testing because KeyCloak uses `/callback` for localhost URLs.<br>2. The function takes several dependencies including the authorization service and configuration settings from the container.<br>3. It sends an HTTP POST request to the KeyCloak token endpoint with the necessary parameters such as the authorization code, client ID, secret, and redirect URI.<br>4. After receiving the response, it decodes the JWT token using the provided signing key and extracts relevant information like preferred username and email.<br>5. A new session object is created with the extracted information and saved in the authorization service.<br>6. Finally, the user is redirected back to the client application with a cookie containing their unique session identifier.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/", callbacks=callback_router.routes)<br>def main_route(callback_url: HttpUrl):<br>    pass  # pragma: no cover</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">1. This function handles the KeyCloak authentication callback after a successful login. It is required for localhost testing because KeyCloak uses `/callback` for localhost URLs.<br>2. The function takes several dependencies including the authorization service and configuration settings from the container.<br>3. It sends an HTTP POST request to the KeyCloak token endpoint with the necessary parameters such as the authorization code, client ID, secret, and redirect URI.<br>4. After receiving the response, it decodes the JWT token using the provided signing key and extracts relevant information like preferred username and email.<br>5. A new session object is created with the extracted information and saved in the authorization service.<br>6. Finally, the user is redirected back to the client application with a cookie containing their unique session identifier.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def callback_route():<br>    pass  # pragma: no cover</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">1. This function handles the KeyCloak authentication callback after a successful login. It is required for localhost testing because KeyCloak uses `/callback` for localhost URLs.<br>2. The function takes several dependencies including the authorization service and configuration settings from the container.<br>3. It sends an HTTP POST request to the KeyCloak token endpoint with the necessary parameters such as the authorization code, client ID, secret, and redirect URI.<br>4. After receiving the response, it decodes the JWT token using the provided signing key and extracts relevant information like preferred username and email.<br>5. A new session object is created with the extracted information and saved in the authorization service.<br>6. Finally, the user is redirected back to the client application with a cookie containing their unique session identifier.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.fastapi.simple_hero_api import tutorial001_py310 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(<br>        mod.sqlite_url, connect_args=mod.connect_args, poolclass=StaticPool<br>    )<br><br>    with TestClient(mod.app) as client:<br>        hero1_data = {"name": "Deadpond", "secret_name": "Dive Wilson"}<br>        hero2_data = {<br>            "name": "Spider-Boy",<br>            "secret_name": "Pedro Parqueador",<br>            "id": 9000,<br>        }<br>        response = client.post("/heroes/", json=hero1_data)<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert data["name"] == hero1_data["name"]<br>        assert data["secret_name"] == hero1_data["secret_name"]<br>        assert data["id"] is not None<br>        assert data["age"] is None<br><br>        response = client.post("/heroes/", json=hero2_data)<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert data["name"] == hero2_data["name"]<br>        assert data["secret_name"] == hero2_data["secret_name"]<br>        assert data["id"] == hero2_data["id"], (<br>            "Up to this point it's still possible to "<br>            "set the ID of the hero in the request"<br>        )<br>        assert data["age"] is None<br><br>        response = client.get("/heroes/")<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert len(data) == 2<br>        assert data[0]["name"] == hero1_data["name"]<br>        assert data[0]["secret_name"] == hero1_data["secret_name"]<br>        assert data[1]["name"] == hero2_data["name"]<br>        assert data[1]["secret_name"] == hero2_data["secret_name"]<br>        assert data[1]["id"] == hero2_data["id"]<br><br>        response = client.get("/openapi.json")<br><br>        assert response.status_code == 200, response.text<br><br>        assert response.json() == {<br>            "openapi": "3.1.0",<br>            "info": {"title": "FastAPI", "version": </code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">1. This function handles the KeyCloak authentication callback after a successful login. It is required for localhost testing because KeyCloak uses `/callback` for localhost URLs.<br>2. The function takes several dependencies including the authorization service and configuration settings from the container.<br>3. It sends an HTTP POST request to the KeyCloak token endpoint with the necessary parameters such as the authorization code, client ID, secret, and redirect URI.<br>4. After receiving the response, it decodes the JWT token using the provided signing key and extracts relevant information like preferred username and email.<br>5. A new session object is created with the extracted information and saved in the authorization service.<br>6. Finally, the user is redirected back to the client application with a cookie containing their unique session identifier.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.fastapi.simple_hero_api import tutorial001 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(<br>        mod.sqlite_url, connect_args=mod.connect_args, poolclass=StaticPool<br>    )<br><br>    with TestClient(mod.app) as client:<br>        hero1_data = {"name": "Deadpond", "secret_name": "Dive Wilson"}<br>        hero2_data = {<br>            "name": "Spider-Boy",<br>            "secret_name": "Pedro Parqueador",<br>            "id": 9000,<br>        }<br>        response = client.post("/heroes/", json=hero1_data)<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert data["name"] == hero1_data["name"]<br>        assert data["secret_name"] == hero1_data["secret_name"]<br>        assert data["id"] is not None<br>        assert data["age"] is None<br><br>        response = client.post("/heroes/", json=hero2_data)<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert data["name"] == hero2_data["name"]<br>        assert data["secret_name"] == hero2_data["secret_name"]<br>        assert data["id"] == hero2_data["id"], (<br>            "Up to this point it's still possible to "<br>            "set the ID of the hero in the request"<br>        )<br>        assert data["age"] is None<br><br>        response = client.get("/heroes/")<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert len(data) == 2<br>        assert data[0]["name"] == hero1_data["name"]<br>        assert data[0]["secret_name"] == hero1_data["secret_name"]<br>        assert data[1]["name"] == hero2_data["name"]<br>        assert data[1]["secret_name"] == hero2_data["secret_name"]<br>        assert data[1]["id"] == hero2_data["id"]<br><br>        response = client.get("/openapi.json")<br><br>        assert response.status_code == 200, response.text<br><br>        assert response.json() == {<br>            "openapi": "3.1.0",<br>            "info": {"title": "FastAPI", "version": "0.1.0</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">1. This function handles the KeyCloak authentication callback after a successful login. It is required for localhost testing because KeyCloak uses `/callback` for localhost URLs.<br>2. The function takes several dependencies including the authorization service and configuration settings from the container.<br>3. It sends an HTTP POST request to the KeyCloak token endpoint with the necessary parameters such as the authorization code, client ID, secret, and redirect URI.<br>4. After receiving the response, it decodes the JWT token using the provided signing key and extracts relevant information like preferred username and email.<br>5. A new session object is created with the extracted information and saved in the authorization service.<br>6. Finally, the user is redirected back to the client application with a cookie containing their unique session identifier.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.fastapi.multiple_models import tutorial002_py310 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(<br>        mod.sqlite_url, connect_args=mod.connect_args, poolclass=StaticPool<br>    )<br><br>    with TestClient(mod.app) as client:<br>        hero1_data = {"name": "Deadpond", "secret_name": "Dive Wilson"}<br>        hero2_data = {<br>            "name": "Spider-Boy",<br>            "secret_name": "Pedro Parqueador",<br>            "id": 9000,<br>        }<br>        response = client.post("/heroes/", json=hero1_data)<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert data["name"] == hero1_data["name"]<br>        assert data["secret_name"] == hero1_data["secret_name"]<br>        assert data["id"] is not None<br>        assert data["age"] is None<br><br>        response = client.post("/heroes/", json=hero2_data)<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert data["name"] == hero2_data["name"]<br>        assert data["secret_name"] == hero2_data["secret_name"]<br>        assert data["id"] != hero2_data["id"], (<br>            "Now it's not possible to predefine the ID from the request, "<br>            "it's now set by the database"<br>        )<br>        assert data["age"] is None<br><br>        response = client.get("/heroes/")<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert len(data) == 2<br>        assert data[0]["name"] == hero1_data["name"]<br>        assert data[0]["secret_name"] == hero1_data["secret_name"]<br>        assert data[1]["name"] == hero2_data["name"]<br>        assert data[1]["secret_name"] == hero2_data["secret_name"]<br>        assert data[1]["id"] != hero2_data["id"]<br><br>        response = client.get("/openapi.json")<br><br>        assert response.status_code == 200, response.text<br><br>        assert response.json() == {<br>            "openapi": "3.1.0",<br>            "info": {"title": "FastAPI", </code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">1. This function handles the KeyCloak authentication callback after a successful login. It is required for localhost testing because KeyCloak uses `/callback` for localhost URLs.<br>2. The function takes several dependencies including the authorization service and configuration settings from the container.<br>3. It sends an HTTP POST request to the KeyCloak token endpoint with the necessary parameters such as the authorization code, client ID, secret, and redirect URI.<br>4. After receiving the response, it decodes the JWT token using the provided signing key and extracts relevant information like preferred username and email.<br>5. A new session object is created with the extracted information and saved in the authorization service.<br>6. Finally, the user is redirected back to the client application with a cookie containing their unique session identifier.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_login(client: TestClient):<br>    response = client.post("/token", data={"username": "johndoe", "password": "secret"})<br>    assert response.status_code == 200, response.text<br>    content = response.json()<br>    assert "access_token" in content<br>    assert content["token_type"] == "bearer"</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">1. This function handles the KeyCloak authentication callback after a successful login. It is required for localhost testing because KeyCloak uses `/callback` for localhost URLs.<br>2. The function takes several dependencies including the authorization service and configuration settings from the container.<br>3. It sends an HTTP POST request to the KeyCloak token endpoint with the necessary parameters such as the authorization code, client ID, secret, and redirect URI.<br>4. After receiving the response, it decodes the JWT token using the provided signing key and extracts relevant information like preferred username and email.<br>5. A new session object is created with the extracted information and saved in the authorization service.<br>6. Finally, the user is redirected back to the client application with a cookie containing their unique session identifier.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def login_access_token(<br>    *,<br>    req: sys_user_schema.UserPhoneAuth,<br>) -> Any:<br>    """<br>    简单实现登录<br>    :param req:<br>    :return:<br>    """<br><br>    # 验证用户 简短的业务可以写在这里<br>    # user = User.single_by_phone(phone=req.username)<br>    # if not user:<br>    #     return resp.fail(resp.DataNotFound.set_msg("账号或密码错误"))<br>    #<br>    # if not security.verify_password(req.password, user.password):<br>    #     return resp.fail(resp.DataNotFound.set_msg("账号或密码错误"))<br>    #<br>    # access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)<br>    #<br>    # # 登录token 存储了user.id<br>    # return resp.ok(data={<br>    #     "token": security.create_access_token(user.id, expires_delta=access_token_expires),<br>    # })<br><br>    # 复杂的业务逻辑建议 抽离到 logic文件夹下<br>    token = UserLogic().user_login_logic(req.username, req.password)<br>    return resp.ok(data={"token": token})</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">1. This function handles the KeyCloak authentication callback after a successful login. It is required for localhost testing because KeyCloak uses `/callback` for localhost URLs.<br>2. The function takes several dependencies including the authorization service and configuration settings from the container.<br>3. It sends an HTTP POST request to the KeyCloak token endpoint with the necessary parameters such as the authorization code, client ID, secret, and redirect URI.<br>4. After receiving the response, it decodes the JWT token using the provided signing key and extracts relevant information like preferred username and email.<br>5. A new session object is created with the extracted information and saved in the authorization service.<br>6. Finally, the user is redirected back to the client application with a cookie containing their unique session identifier.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_login():<br>    response = client.post("/token", data={"username": "johndoe", "password": "secret"})<br>    assert response.status_code == 200, response.text<br>    content = response.json()<br>    assert "access_token" in content<br>    assert content["token_type"] == "bearer"</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a POST request to the `/login` endpoint and returns an access token for authenticated users. - The `OAuth2PasswordRequestForm` dependency parses the username and password fields of the request body into a Python dictionary called `form_data`. - The `Session` dependency retrieves a SQLAlchemy session object that can be used to query the database. - The `user` variable contains the result of executing a SELECT statement with a WHERE clause based on the provided username. If no matching row is found or the password doesn't match, a 401 Unauthorized error is raised with WWW-Authenticate header set to Bearer. - Otherwise, the function simply returns a JSON response containing the username as the access token and "bearer" as the token type.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/token")<br>async def login(form_data: OAuth2PasswordRequestForm = Depends()):<br>    user_dict = fake_users_db.get(form_data.username)<br>    if not user_dict:<br>        raise HTTPException(status_code=400, detail="Incorrect username or password")<br>    user = UserInDB(**user_dict)<br>    hashed_password = fake_hash_password(form_data.password)<br>    if not hashed_password == user.hashed_password:<br>        raise HTTPException(status_code=400, detail="Incorrect username or password")<br><br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a POST request to the `/login` endpoint and returns an access token for authenticated users. - The `OAuth2PasswordRequestForm` dependency parses the username and password fields of the request body into a Python dictionary called `form_data`. - The `Session` dependency retrieves a SQLAlchemy session object that can be used to query the database. - The `user` variable contains the result of executing a SELECT statement with a WHERE clause based on the provided username. If no matching row is found or the password doesn't match, a 401 Unauthorized error is raised with WWW-Authenticate header set to Bearer. - Otherwise, the function simply returns a JSON response containing the username as the access token and "bearer" as the token type.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/token", response_model=Token)<br>async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):<br>    user = authenticate_user(fake_users_db, form_data.username, form_data.password)<br>    if not user:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Incorrect username or password",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)<br>    access_token = create_access_token(<br>        data={"sub": user.username}, expires_delta=access_token_expires<br>    )<br>    return {"access_token": access_token, "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a POST request to the `/login` endpoint and returns an access token for authenticated users. - The `OAuth2PasswordRequestForm` dependency parses the username and password fields of the request body into a Python dictionary called `form_data`. - The `Session` dependency retrieves a SQLAlchemy session object that can be used to query the database. - The `user` variable contains the result of executing a SELECT statement with a WHERE clause based on the provided username. If no matching row is found or the password doesn't match, a 401 Unauthorized error is raised with WWW-Authenticate header set to Bearer. - Otherwise, the function simply returns a JSON response containing the username as the access token and "bearer" as the token type.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/token", response_model=Token)<br>async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):<br>    user = authenticate_user(fake_users_db, form_data.username, form_data.password)<br>    if not user:<br>        raise HTTPException(status_code=400, detail="Incorrect username or password")<br>    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)<br>    access_token = create_access_token(<br>        data={"sub": user.username, "scopes": form_data.scopes},<br>        expires_delta=access_token_expires,<br>    )<br>    return {"access_token": access_token, "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a POST request to the `/login` endpoint and returns an access token for authenticated users. - The `OAuth2PasswordRequestForm` dependency parses the username and password fields of the request body into a Python dictionary called `form_data`. - The `Session` dependency retrieves a SQLAlchemy session object that can be used to query the database. - The `user` variable contains the result of executing a SELECT statement with a WHERE clause based on the provided username. If no matching row is found or the password doesn't match, a 401 Unauthorized error is raised with WWW-Authenticate header set to Bearer. - Otherwise, the function simply returns a JSON response containing the username as the access token and "bearer" as the token type.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def login(<br>    data: OAuth2PasswordRequestForm = Depends(),<br>    session: AsyncSession = Depends(get_session),<br>):<br>    user = await authenticate(session, email=data.username, password=data.password)<br>    if user is None:<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br>    if not user.is_active:<br>        raise HTTPException(status_code=400, detail="Inactive user")<br>    return {"access_token": create_access_token(user), "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a POST request to the `/login` endpoint and returns an access token for authenticated users. - The `OAuth2PasswordRequestForm` dependency parses the username and password fields of the request body into a Python dictionary called `form_data`. - The `Session` dependency retrieves a SQLAlchemy session object that can be used to query the database. - The `user` variable contains the result of executing a SELECT statement with a WHERE clause based on the provided username. If no matching row is found or the password doesn't match, a 401 Unauthorized error is raised with WWW-Authenticate header set to Bearer. - Otherwise, the function simply returns a JSON response containing the username as the access token and "bearer" as the token type.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def login_access_token(<br>    db: Session = Depends(deps.get_db), form_data: OAuth2PasswordRequestForm = Depends()<br>):<br>    """OAuth2 compatible token login, get an access token for future requests."""<br>    user = crud.user.authenticate(<br>        db, email=form_data.username, password=form_data.password<br>    )<br>    if not user:<br>        raise HTTPException(<br>            status_code=status.HTTP_400_BAD_REQUEST,<br>            detail="Incorrect email or password.",<br>        )<br>    elif not crud.user.is_active(user):<br>        raise HTTPException(<br>            status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user."<br>        )<br>    return {<br>        "access_token": security.create_access_token(str(user.id)),<br>        "token_type": "bearer",<br>    }</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a POST request to the `/login` endpoint and returns an access token for authenticated users. - The `OAuth2PasswordRequestForm` dependency parses the username and password fields of the request body into a Python dictionary called `form_data`. - The `Session` dependency retrieves a SQLAlchemy session object that can be used to query the database. - The `user` variable contains the result of executing a SELECT statement with a WHERE clause based on the provided username. If no matching row is found or the password doesn't match, a 401 Unauthorized error is raised with WWW-Authenticate header set to Bearer. - Otherwise, the function simply returns a JSON response containing the username as the access token and "bearer" as the token type.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/access-token", response_model=AccessTokenResponse)<br>async def login_access_token(<br>    session: AsyncSession = Depends(deps.get_session),<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>):<br>    """OAuth2 compatible token, get an access token for future requests using username and password"""<br><br>    result = await session.execute(select(User).where(User.email == form_data.username))<br>    user = result.scalars().first()<br><br>    if user is None:<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br><br>    if not security.verify_password(form_data.password, user.hashed_password):<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br><br>    return security.generate_access_token_response(str(user.id))</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a POST request to the `/login` endpoint and returns an access token for authenticated users. - The `OAuth2PasswordRequestForm` dependency parses the username and password fields of the request body into a Python dictionary called `form_data`. - The `Session` dependency retrieves a SQLAlchemy session object that can be used to query the database. - The `user` variable contains the result of executing a SELECT statement with a WHERE clause based on the provided username. If no matching row is found or the password doesn't match, a 401 Unauthorized error is raised with WWW-Authenticate header set to Bearer. - Otherwise, the function simply returns a JSON response containing the username as the access token and "bearer" as the token type.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/login/", response_model=Token)<br>async def login(<br>    data: OAuth2PasswordRequestForm = Depends(),<br>    session: AsyncSession = Depends(get_session),<br>):<br>    user = await authenticate(session, email=data.username, password=data.password)<br>    if user is None:<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br>    if not user.is_active:<br>        raise HTTPException(status_code=400, detail="Inactive user")<br>    return {"access_token": create_access_token(user), "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a POST request to the `/login` endpoint and returns an access token for authenticated users. - The `OAuth2PasswordRequestForm` dependency parses the username and password fields of the request body into a Python dictionary called `form_data`. - The `Session` dependency retrieves a SQLAlchemy session object that can be used to query the database. - The `user` variable contains the result of executing a SELECT statement with a WHERE clause based on the provided username. If no matching row is found or the password doesn't match, a 401 Unauthorized error is raised with WWW-Authenticate header set to Bearer. - Otherwise, the function simply returns a JSON response containing the username as the access token and "bearer" as the token type.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/token", response_model=Token)<br>async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):<br>    user = authenticate_user(fake_users_db, form_data.username, form_data.password)<br>    if not user:<br>        raise HTTPException(status_code=400, detail="Incorrect username or password")<br>    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)<br>    access_token = create_access_token(<br>        data={"sub": user.username, "scopes": form_data.scopes},<br>        expires_delta=access_token_expires,<br>    )<br>    return {"access_token": access_token, "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function handles a POST request to the `/login` endpoint and returns an access token for authenticated users. - The `OAuth2PasswordRequestForm` dependency parses the username and password fields of the request body into a Python dictionary called `form_data`. - The `Session` dependency retrieves a SQLAlchemy session object that can be used to query the database. - The `user` variable contains the result of executing a SELECT statement with a WHERE clause based on the provided username. If no matching row is found or the password doesn't match, a 401 Unauthorized error is raised with WWW-Authenticate header set to Bearer. - Otherwise, the function simply returns a JSON response containing the username as the access token and "bearer" as the token type.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/login/access-token", response_model=Token)<br>def login(form_data: OAuth2PasswordRequestForm = Depends()):<br>    """<br>    OAuth2 compatible token login, get an access token for future requests.<br>    """<br>    bucket = get_default_bucket()<br>    user = crud.user.authenticate(<br>        bucket, username=form_data.username, password=form_data.password<br>    )<br>    if not user:<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br>    elif not crud.user.is_active(user):<br>        raise HTTPException(status_code=400, detail="Inactive user")<br>    access_token_expires = timedelta(minutes=config.ACCESS_TOKEN_EXPIRE_MINUTES)<br>    return {<br>        "access_token": create_access_token(<br>            data={"username": user.username}, expires_delta=access_token_expires<br>        ),<br>        "token_type": "bearer",<br>    }</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a Flask application called `app` in the module `fluento.main`.<br>- Runs the app using Uvicorn web server with specific configuration options such as running on port 5001, enabling automatic reloading of changes to the app's codebase, limiting worker processes to one (for development purposes), and setting a keep alive time for idle connections to 30 seconds.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def start_tifa():<br>    uvicorn.run(<br>        "tifa.app:create_app",<br>        factory=True,<br>        reload=True,<br>        host="0.0.0.0",<br>        port=8000,<br>        log_level="info",<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a Flask application called `app` in the module `fluento.main`.<br>- Runs the app using Uvicorn web server with specific configuration options such as running on port 5001, enabling automatic reloading of changes to the app's codebase, limiting worker processes to one (for development purposes), and setting a keep alive time for idle connections to 30 seconds.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def start_whiteboard():<br>    uvicorn.run(<br>        "tifa.app:create_app",<br>        factory=True,<br>        reload=True,<br>        host="0.0.0.0",<br>        port=8001,<br>        log_level="info",<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a Flask application called `app` in the module `fluento.main`.<br>- Runs the app using Uvicorn web server with specific configuration options such as running on port 5001, enabling automatic reloading of changes to the app's codebase, limiting worker processes to one (for development purposes), and setting a keep alive time for idle connections to 30 seconds.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@group_web.command("start")<br>def start_tifa():<br>    uvicorn.run(<br>        "tifa.app:create_app",<br>        factory=True,<br>        reload=True,<br>        host="0.0.0.0",<br>        port=8000,<br>        log_level="info",<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a Flask application called `app` in the module `fluento.main`.<br>- Runs the app using Uvicorn web server with specific configuration options such as running on port 5001, enabling automatic reloading of changes to the app's codebase, limiting worker processes to one (for development purposes), and setting a keep alive time for idle connections to 30 seconds.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@group_web.command("whiteboard")<br>def start_whiteboard():<br>    uvicorn.run(<br>        "tifa.app:create_app",<br>        factory=True,<br>        reload=True,<br>        host="0.0.0.0",<br>        port=8001,<br>        log_level="info",<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a Flask application called `app` in the module `fluento.main`.<br>- Runs the app using Uvicorn web server with specific configuration options such as running on port 5001, enabling automatic reloading of changes to the app's codebase, limiting worker processes to one (for development purposes), and setting a keep alive time for idle connections to 30 seconds.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@group_web.command("start")<br>def start_tifa():<br>    uvicorn.run(<br>        "tifa.app:create_app",<br>        factory=True,<br>        reload=True,<br>        host="0.0.0.0",<br>        port=8000,<br>        log_level="info",<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a Flask application called `app` in the module `fluento.main`.<br>- Runs the app using Uvicorn web server with specific configuration options such as running on port 5001, enabling automatic reloading of changes to the app's codebase, limiting worker processes to one (for development purposes), and setting a keep alive time for idle connections to 30 seconds.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def start_whiteboard():<br>    uvicorn.run(<br>        "tifa.app:create_app",<br>        factory=True,<br>        reload=True,<br>        host="0.0.0.0",<br>        port=8001,<br>        log_level="info",<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a Flask application called `app` in the module `fluento.main`.<br>- Runs the app using Uvicorn web server with specific configuration options such as running on port 5001, enabling automatic reloading of changes to the app's codebase, limiting worker processes to one (for development purposes), and setting a keep alive time for idle connections to 30 seconds.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def start_tifa():<br>    uvicorn.run(<br>        "tifa.app:create_app",<br>        factory=True,<br>        reload=True,<br>        host="0.0.0.0",<br>        port=8000,<br>        log_level="info",<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a Flask application called `app` in the module `fluento.main`.<br>- Runs the app using Uvicorn web server with specific configuration options such as running on port 5001, enabling automatic reloading of changes to the app's codebase, limiting worker processes to one (for development purposes), and setting a keep alive time for idle connections to 30 seconds.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@group_web.command("start")<br>def start_tifa():<br>    uvicorn.run(<br>        "tifa.app:create_app",<br>        factory=True,<br>        reload=True,<br>        host="0.0.0.0",<br>        port=8000,<br>        log_level="info",<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Initializes a Flask application called `app` in the module `fluento.main`.<br>- Runs the app using Uvicorn web server with specific configuration options such as running on port 5001, enabling automatic reloading of changes to the app's codebase, limiting worker processes to one (for development purposes), and setting a keep alive time for idle connections to 30 seconds.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@group_web.command("whiteboard")<br>def start_whiteboard():<br>    uvicorn.run(<br>        "tifa.app:create_app",<br>        factory=True,<br>        reload=True,<br>        host="0.0.0.0",<br>        port=8001,<br>        log_level="info",<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function implements a middleware that adds authentication functionality to FastAPI endpoints using the `async def __call__()` method provided by Starlette's Middleware API. - It retrieves an authorization header from the incoming request and checks whether it exists or not. If missing, it raises a custom HTTP exception with status code 400 and error message "Missing auth token". - The middleware then attempts to verify the token in the authorization header and retrieve the associated user information. If verification fails or the token is invalid, another custom HTTP exception with status code 400 and error message "Invalid auth token" is raised. - Finally, the original request is passed through to the next handler (i.e., the endpoint being protected).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        authorization = request.headers.get("Authorization")<br>        if not authorization:<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        return authorization</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function implements a middleware that adds authentication functionality to FastAPI endpoints using the `async def __call__()` method provided by Starlette's Middleware API. - It retrieves an authorization header from the incoming request and checks whether it exists or not. If missing, it raises a custom HTTP exception with status code 400 and error message "Missing auth token". - The middleware then attempts to verify the token in the authorization header and retrieve the associated user information. If verification fails or the token is invalid, another custom HTTP exception with status code 400 and error message "Invalid auth token" is raised. - Finally, the original request is passed through to the next handler (i.e., the endpoint being protected).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        authorization = request.headers.get("Authorization")<br>        scheme, param = get_authorization_scheme_param(authorization)<br>        if not authorization or scheme.lower() != "bearer":<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_401_UNAUTHORIZED,<br>                    detail="Not authenticated",<br>                    headers={"WWW-Authenticate": "Bearer"},<br>                )<br>            else:<br>                return None  # pragma: nocover<br>        return param</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function implements a middleware that adds authentication functionality to FastAPI endpoints using the `async def __call__()` method provided by Starlette's Middleware API. - It retrieves an authorization header from the incoming request and checks whether it exists or not. If missing, it raises a custom HTTP exception with status code 400 and error message "Missing auth token". - The middleware then attempts to verify the token in the authorization header and retrieve the associated user information. If verification fails or the token is invalid, another custom HTTP exception with status code 400 and error message "Invalid auth token" is raised. - Finally, the original request is passed through to the next handler (i.e., the endpoint being protected).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        authorization = request.headers.get("Authorization")<br>        scheme, param = get_authorization_scheme_param(authorization)<br>        if not authorization or scheme.lower() != "bearer":<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_401_UNAUTHORIZED,<br>                    detail="Not authenticated",<br>                    headers={"WWW-Authenticate": "Bearer"},<br>                )<br>            else:<br>                return None<br>        return param</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function implements a middleware that adds authentication functionality to FastAPI endpoints using the `async def __call__()` method provided by Starlette's Middleware API. - It retrieves an authorization header from the incoming request and checks whether it exists or not. If missing, it raises a custom HTTP exception with status code 400 and error message "Missing auth token". - The middleware then attempts to verify the token in the authorization header and retrieve the associated user information. If verification fails or the token is invalid, another custom HTTP exception with status code 400 and error message "Invalid auth token" is raised. - Finally, the original request is passed through to the next handler (i.e., the endpoint being protected).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/refresh-token", response_model=AccessTokenResponse)<br>async def refresh_token(<br>    input: RefreshTokenRequest,<br>    session: AsyncSession = Depends(deps.get_session),<br>):<br>    """OAuth2 compatible token, get an access token for future requests using refresh token"""<br>    try:<br>        payload = jwt.decode(<br>            input.refresh_token,<br>            config.settings.SECRET_KEY,<br>            algorithms=[security.JWT_ALGORITHM],<br>        )<br>    except (jwt.DecodeError, ValidationError):<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, unknown error",<br>        )<br><br>    # JWT guarantees payload will be unchanged (and thus valid), no errors here<br>    token_data = security.JWTTokenPayload(**payload)<br><br>    if not token_data.refresh:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, cannot use access token",<br>        )<br>    now = int(time.time())<br>    if now < token_data.issued_at or now > token_data.expires_at:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, token expired or not yet valid",<br>        )<br><br>    result = await session.execute(select(User).where(User.id == token_data.sub))<br>    user = result.scalars().first()<br><br>    if user is None:<br>        raise HTTPException(status_code=404, detail="User not found")<br><br>    return security.generate_access_token_response(str(user.id))</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function implements a middleware that adds authentication functionality to FastAPI endpoints using the `async def __call__()` method provided by Starlette's Middleware API. - It retrieves an authorization header from the incoming request and checks whether it exists or not. If missing, it raises a custom HTTP exception with status code 400 and error message "Missing auth token". - The middleware then attempts to verify the token in the authorization header and retrieve the associated user information. If verification fails or the token is invalid, another custom HTTP exception with status code 400 and error message "Invalid auth token" is raised. - Finally, the original request is passed through to the next handler (i.e., the endpoint being protected).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, scope: "Scope", receive: "Receive", send: "Send") -> None:<br>        """<br>        Load request ID from headers if present. Generate one otherwise.<br>        """<br>        if scope["type"] not in ("http", "websocket"):<br>            await self.app(scope, receive, send)<br>            return<br><br>        # Try to load request ID from the request headers<br>        headers = MutableHeaders(scope=scope)<br>        header_value = headers.get(self.header_name.lower())<br><br>        validation_failed = False<br>        if not header_value:<br>            # Generate request ID if none was found<br>            id_value = self.generator()<br>        elif self.validator and not self.validator(header_value):<br>            # Also generate a request ID if one was found, but it was deemed invalid<br>            validation_failed = True<br>            id_value = self.generator()<br>        else:<br>            # Otherwise, use the found request ID<br>            id_value = header_value<br><br>        # Clean/change the ID if needed<br>        if self.transformer:<br>            id_value = self.transformer(id_value)<br><br>        if validation_failed is True:<br>            logger.warning(FAILED_VALIDATION_MESSAGE, id_value)<br><br>        # Update the request headers if needed<br>        if id_value != header_value and self.update_request_header is True:<br>            headers[self.header_name] = id_value<br><br>        correlation_id.set(id_value)<br>        self.sentry_extension(id_value)<br><br>        async def handle_outgoing_request(message: "Message") -> None:<br>            if message["type"] == "http.response.start" and correlation_id.get():<br>                headers = MutableHeaders(scope=message)<br>                headers.append(self.header_name, correlation_id.get())<br><br>            await send(message)<br><br>        await self.app(scope, receive, handle_outgoing_request)<br>        return</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function implements a middleware that adds authentication functionality to FastAPI endpoints using the `async def __call__()` method provided by Starlette's Middleware API. - It retrieves an authorization header from the incoming request and checks whether it exists or not. If missing, it raises a custom HTTP exception with status code 400 and error message "Missing auth token". - The middleware then attempts to verify the token in the authorization header and retrieve the associated user information. If verification fails or the token is invalid, another custom HTTP exception with status code 400 and error message "Invalid auth token" is raised. - Finally, the original request is passed through to the next handler (i.e., the endpoint being protected).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@dataclass<br>class CorrelationIdMiddleware:<br>    app: "ASGIApp"<br>    header_name: str = "X-Request-ID"<br>    update_request_header: bool = True<br><br>    # ID-generating callable<br>    generator: Callable[[], str] = field(default=lambda: uuid4().hex)<br><br>    # ID validator<br>    validator: Optional[Callable[[str], bool]] = field(default=is_valid_uuid4)<br><br>    # ID transformer - can be used to clean/mutate IDs<br>    transformer: Optional[Callable[[str], str]] = field(default=lambda a: a)<br><br>    async def __call__(self, scope: "Scope", receive: "Receive", send: "Send") -> None:<br>        """<br>        Load request ID from headers if present. Generate one otherwise.<br>        """<br>        if scope["type"] not in ("http", "websocket"):<br>            await self.app(scope, receive, send)<br>            return<br><br>        # Try to load request ID from the request headers<br>        headers = MutableHeaders(scope=scope)<br>        header_value = headers.get(self.header_name.lower())<br><br>        validation_failed = False<br>        if not header_value:<br>            # Generate request ID if none was found<br>            id_value = self.generator()<br>        elif self.validator and not self.validator(header_value):<br>            # Also generate a request ID if one was found, but it was deemed invalid<br>            validation_failed = True<br>            id_value = self.generator()<br>        else:<br>            # Otherwise, use the found request ID<br>            id_value = header_value<br><br>        # Clean/change the ID if needed<br>        if self.transformer:<br>            id_value = self.transformer(id_value)<br><br>        if validation_failed is True:<br>            logger.warning(FAILED_VALIDATION_MESSAGE, id_value)<br><br>        # Update the request headers if needed<br>        if id_value != header_value and self.update_request_header is True:<br>            headers[self.header_name] = id_value<br><br>        correlation_id.set(id_value)<br>        self.sentry_extension(id_value)<br><br>        async def handle_outgoing_request(message: "Message") -> None:<br>            if message["t</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function implements a middleware that adds authentication functionality to FastAPI endpoints using the `async def __call__()` method provided by Starlette's Middleware API. - It retrieves an authorization header from the incoming request and checks whether it exists or not. If missing, it raises a custom HTTP exception with status code 400 and error message "Missing auth token". - The middleware then attempts to verify the token in the authorization header and retrieve the associated user information. If verification fails or the token is invalid, another custom HTTP exception with status code 400 and error message "Invalid auth token" is raised. - Finally, the original request is passed through to the next handler (i.e., the endpoint being protected).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def verify_token(x_token: str = Header()):<br>    if x_token != "fake-super-secret-token":<br>        raise HTTPException(status_code=400, detail="X-Token header invalid")</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function implements a middleware that adds authentication functionality to FastAPI endpoints using the `async def __call__()` method provided by Starlette's Middleware API. - It retrieves an authorization header from the incoming request and checks whether it exists or not. If missing, it raises a custom HTTP exception with status code 400 and error message "Missing auth token". - The middleware then attempts to verify the token in the authorization header and retrieve the associated user information. If verification fails or the token is invalid, another custom HTTP exception with status code 400 and error message "Invalid auth token" is raised. - Finally, the original request is passed through to the next handler (i.e., the endpoint being protected).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def verify_token(x_token: Annotated[str, Header()]):<br>    if x_token != "fake-super-secret-token":<br>        raise HTTPException(status_code=400, detail="X-Token header invalid")</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function implements a middleware that adds authentication functionality to FastAPI endpoints using the `async def __call__()` method provided by Starlette's Middleware API. - It retrieves an authorization header from the incoming request and checks whether it exists or not. If missing, it raises a custom HTTP exception with status code 400 and error message "Missing auth token". - The middleware then attempts to verify the token in the authorization header and retrieve the associated user information. If verification fails or the token is invalid, another custom HTTP exception with status code 400 and error message "Invalid auth token" is raised. - Finally, the original request is passed through to the next handler (i.e., the endpoint being protected).</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def get_token_header(x_token: Annotated[str, Header()]):<br>    if x_token != "fake-super-secret-token":<br>        raise HTTPException(status_code=400, detail="X-Token header invalid")</code></pre></div></td>
    </tr>
    <tr>
      <td>shopping_item</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `update_shopping_item_status` that takes three arguments: `item_id`, `update_item`, and `session`. The first two are required parameters passed by the client, while the third is an optional database connection object provided by FastAPI's dependency injection system. - Uses SQLAlchemy to retrieve the shopping list item with the given ID from the database using the `select` method of the `Session` class. If the item is not found, raises a `HTTPException` with status code 404 (Not Found). - Updates the `is_purchased` and `purchased_by` attributes of the retrieved item based on the values in the `update_item` parameter. Adds the updated item back into the session for tracking changes. - Commits the transaction and refreshes the item object to ensure any new relationships or attribute updates are loaded. Returns the updated item data serialized using Pydantic's `ModelDump` method. - Handles exceptions during the execution of the function by rolling back the transaction and raising a `HTTPException` with status code 500 (Internal Server Error), passing along the exception message as the error detail.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def update_shopping_item_status(<br>    item_id: int, update_item: schemas.UpdateItem, session: Session<br>):<br>    try:<br>        item = session.exec(<br>            select(ShoppingList).where(ShoppingList.id == item_id)<br>        ).first()<br>        if not item:<br>            raise HTTPException(<br>                status_code=status.HTTP_404_NOT_FOUND, detail="Item not found"<br>            )<br>        item.is_purchased = update_item.is_purchased<br>        item.purchased_by = update_item.purchased_by<br>        session.add(item)<br>        session.commit()<br>        session.refresh(item)<br>        return item.model_dump()<br>    except Exception as e:<br>        session.rollback()<br>        raise HTTPException(<br>            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e)<br>        )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def update_item(<br>    *,<br>    item_id: int,<br>    item: Item = Body(<br>        examples=[<br>            {<br>                "name": "Foo",<br>                "description": "A very nice Item",<br>                "price": 35.4,<br>                "tax": 3.2,<br>            },<br>            {<br>                "name": "Bar",<br>                "price": "35.4",<br>            },<br>            {<br>                "name": "Baz",<br>                "price": "thirty five point four",<br>            },<br>        ],<br>    ),<br>):<br>    results = {"item_id": item_id, "item": item}<br>    return results</code></pre></div></td>
    </tr>
    <tr>
      <td>shopping_item</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `update_shopping_item_status` that takes three arguments: `item_id`, `update_item`, and `session`. The first two are required parameters passed by the client, while the third is an optional database connection object provided by FastAPI's dependency injection system. - Uses SQLAlchemy to retrieve the shopping list item with the given ID from the database using the `select` method of the `Session` class. If the item is not found, raises a `HTTPException` with status code 404 (Not Found). - Updates the `is_purchased` and `purchased_by` attributes of the retrieved item based on the values in the `update_item` parameter. Adds the updated item back into the session for tracking changes. - Commits the transaction and refreshes the item object to ensure any new relationships or attribute updates are loaded. Returns the updated item data serialized using Pydantic's `ModelDump` method. - Handles exceptions during the execution of the function by rolling back the transaction and raising a `HTTPException` with status code 500 (Internal Server Error), passing along the exception message as the error detail.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def update_shopping_item_status(<br>    item_id: int, update_item: schemas.UpdateItem, session: Session<br>):<br>    try:<br>        item = session.exec(<br>            select(ShoppingList).where(ShoppingList.id == item_id)<br>        ).first()<br>        if not item:<br>            raise HTTPException(<br>                status_code=status.HTTP_404_NOT_FOUND, detail="Item not found"<br>            )<br>        item.is_purchased = update_item.is_purchased<br>        item.purchased_by = update_item.purchased_by<br>        session.add(item)<br>        session.commit()<br>        session.refresh(item)<br>        return item.model_dump()<br>    except Exception as e:<br>        session.rollback()<br>        raise HTTPException(<br>            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e)<br>        )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def update_item(item_id: int, item: Item):<br>    results = {"item_id": item_id, "item": item}<br>    return results</code></pre></div></td>
    </tr>
    <tr>
      <td>shopping_item</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `update_shopping_item_status` that takes three arguments: `item_id`, `update_item`, and `session`. The first two are required parameters passed by the client, while the third is an optional database connection object provided by FastAPI's dependency injection system. - Uses SQLAlchemy to retrieve the shopping list item with the given ID from the database using the `select` method of the `Session` class. If the item is not found, raises a `HTTPException` with status code 404 (Not Found). - Updates the `is_purchased` and `purchased_by` attributes of the retrieved item based on the values in the `update_item` parameter. Adds the updated item back into the session for tracking changes. - Commits the transaction and refreshes the item object to ensure any new relationships or attribute updates are loaded. Returns the updated item data serialized using Pydantic's `ModelDump` method. - Handles exceptions during the execution of the function by rolling back the transaction and raising a `HTTPException` with status code 500 (Internal Server Error), passing along the exception message as the error detail.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def update_shopping_item_status(<br>    item_id: int, update_item: schemas.UpdateItem, session: Session<br>):<br>    try:<br>        item = session.exec(<br>            select(ShoppingList).where(ShoppingList.id == item_id)<br>        ).first()<br>        if not item:<br>            raise HTTPException(<br>                status_code=status.HTTP_404_NOT_FOUND, detail="Item not found"<br>            )<br>        item.is_purchased = update_item.is_purchased<br>        item.purchased_by = update_item.purchased_by<br>        session.add(item)<br>        session.commit()<br>        session.refresh(item)<br>        return item.model_dump()<br>    except Exception as e:<br>        session.rollback()<br>        raise HTTPException(<br>            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e)<br>        )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def update_item(<br>    item_id: int,<br>    item: Item = Body(<br>        examples=[<br>            {<br>                "name": "Foo",<br>                "description": "A very nice Item",<br>                "price": 35.4,<br>                "tax": 3.2,<br>            }<br>        ],<br>    ),<br>):<br>    results = {"item_id": item_id, "item": item}<br>    return results</code></pre></div></td>
    </tr>
    <tr>
      <td>shopping_item</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `update_shopping_item_status` that takes three arguments: `item_id`, `update_item`, and `session`. The first two are required parameters passed by the client, while the third is an optional database connection object provided by FastAPI's dependency injection system. - Uses SQLAlchemy to retrieve the shopping list item with the given ID from the database using the `select` method of the `Session` class. If the item is not found, raises a `HTTPException` with status code 404 (Not Found). - Updates the `is_purchased` and `purchased_by` attributes of the retrieved item based on the values in the `update_item` parameter. Adds the updated item back into the session for tracking changes. - Commits the transaction and refreshes the item object to ensure any new relationships or attribute updates are loaded. Returns the updated item data serialized using Pydantic's `ModelDump` method. - Handles exceptions during the execution of the function by rolling back the transaction and raising a `HTTPException` with status code 500 (Internal Server Error), passing along the exception message as the error detail.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def update_shopping_item_status(<br>    item_id: int, update_item: schemas.UpdateItem, session: Session<br>):<br>    try:<br>        item = session.exec(<br>            select(ShoppingList).where(ShoppingList.id == item_id)<br>        ).first()<br>        if not item:<br>            raise HTTPException(<br>                status_code=status.HTTP_404_NOT_FOUND, detail="Item not found"<br>            )<br>        item.is_purchased = update_item.is_purchased<br>        item.purchased_by = update_item.purchased_by<br>        session.add(item)<br>        session.commit()<br>        session.refresh(item)<br>        return item.model_dump()<br>    except Exception as e:<br>        session.rollback()<br>        raise HTTPException(<br>            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e)<br>        )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def test_schema_update_relationship(<br>    app: FastAPI, async_client: AsyncClient, fake_articles, async_session, models<br>):<br>    content_schema = TableModelParser.get_table_model_schema(models.ArticleContent)<br><br>    class ArticleUpdate(BaseModel):<br>        title: str = None<br>        description: str = None<br>        content: Optional[content_schema] = None  # Relationship<br><br>    class ArticleCrud(SqlalchemyCrud):<br>        router_prefix = "/article"<br>        update_exclude = {"content": {"id"}}<br>        schema_update = ArticleUpdate<br><br>    ins = ArticleCrud(models.Article, db.engine).register_crud()<br><br>    app.include_router(ins.router)<br><br>    # test schemas<br>    openapi = app.openapi()<br>    schemas = openapi["components"]["schemas"]<br><br>    assert "content" in schemas["ArticleUpdate"]["properties"]<br>    # assert schemas["ArticleUpdate"]["properties"]["content"]["$ref"] == "#/components/schemas/" + content_schema.__name__<br><br>    # test api<br>    res = await async_client.put("/article/item/1", json={"title": "new_title"})<br>    assert res.json()["data"] == 1<br>    article = await async_session.get(models.Article, 1, with_for_update=True)<br>    await async_session.refresh(article)<br>    assert article.title == "new_title"<br><br>    res = await async_client.put(<br>        "/article/item/1",<br>        json={<br>            "content": {"id": 2, "content": "new_content"}<br>        },  # will be ignored by `update_exclude`<br>    )<br>    assert res.json()["data"] == 1<br>    content = await async_session.get(models.ArticleContent, 1, with_for_update=True)<br>    await async_session.refresh(content)<br>    assert content.content == "new_content"</code></pre></div></td>
    </tr>
    <tr>
      <td>shopping_item</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `update_shopping_item_status` that takes three arguments: `item_id`, `update_item`, and `session`. The first two are required parameters passed by the client, while the third is an optional database connection object provided by FastAPI's dependency injection system. - Uses SQLAlchemy to retrieve the shopping list item with the given ID from the database using the `select` method of the `Session` class. If the item is not found, raises a `HTTPException` with status code 404 (Not Found). - Updates the `is_purchased` and `purchased_by` attributes of the retrieved item based on the values in the `update_item` parameter. Adds the updated item back into the session for tracking changes. - Commits the transaction and refreshes the item object to ensure any new relationships or attribute updates are loaded. Returns the updated item data serialized using Pydantic's `ModelDump` method. - Handles exceptions during the execution of the function by rolling back the transaction and raising a `HTTPException` with status code 500 (Internal Server Error), passing along the exception message as the error detail.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def update_shopping_item_status(<br>    item_id: int, update_item: schemas.UpdateItem, session: Session<br>):<br>    try:<br>        item = session.exec(<br>            select(ShoppingList).where(ShoppingList.id == item_id)<br>        ).first()<br>        if not item:<br>            raise HTTPException(<br>                status_code=status.HTTP_404_NOT_FOUND, detail="Item not found"<br>            )<br>        item.is_purchased = update_item.is_purchased<br>        item.purchased_by = update_item.purchased_by<br>        session.add(item)<br>        session.commit()<br>        session.refresh(item)<br>        return item.model_dump()<br>    except Exception as e:<br>        session.rollback()<br>        raise HTTPException(<br>            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e)<br>        )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.put("/{user_id}/", response_model=UserOut, dependencies=[Depends(on_superuser)])<br>async def update_user(<br>    user_id: int, user_in: UserUpdate, session: AsyncSession = Depends(get_session)<br>):<br>    user = await crud_user.get(session, id=user_id)<br>    if user is None:<br>        raise HTTPException(<br>            status_code=404,<br>            detail="The user with this username does not exist in the system",<br>        )<br>    try:<br>        user = await crud_user.update(<br>            session,<br>            db_obj=user,<br>            obj_in={<br>                **user_in.dict(exclude={"password"}, exclude_none=True),<br>                "hashed_password": get_password_hash(user_in.password),<br>            },<br>        )<br>    except IntegrityError:<br>        raise HTTPException(<br>            status_code=409, detail="User with this username already exits"<br>        )<br>    return user</code></pre></div></td>
    </tr>
    <tr>
      <td>shopping_item</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `update_shopping_item_status` that takes three arguments: `item_id`, `update_item`, and `session`. The first two are required parameters passed by the client, while the third is an optional database connection object provided by FastAPI's dependency injection system. - Uses SQLAlchemy to retrieve the shopping list item with the given ID from the database using the `select` method of the `Session` class. If the item is not found, raises a `HTTPException` with status code 404 (Not Found). - Updates the `is_purchased` and `purchased_by` attributes of the retrieved item based on the values in the `update_item` parameter. Adds the updated item back into the session for tracking changes. - Commits the transaction and refreshes the item object to ensure any new relationships or attribute updates are loaded. Returns the updated item data serialized using Pydantic's `ModelDump` method. - Handles exceptions during the execution of the function by rolling back the transaction and raising a `HTTPException` with status code 500 (Internal Server Error), passing along the exception message as the error detail.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def update_shopping_item_status(<br>    item_id: int, update_item: schemas.UpdateItem, session: Session<br>):<br>    try:<br>        item = session.exec(<br>            select(ShoppingList).where(ShoppingList.id == item_id)<br>        ).first()<br>        if not item:<br>            raise HTTPException(<br>                status_code=status.HTTP_404_NOT_FOUND, detail="Item not found"<br>            )<br>        item.is_purchased = update_item.is_purchased<br>        item.purchased_by = update_item.purchased_by<br>        session.add(item)<br>        session.commit()<br>        session.refresh(item)<br>        return item.model_dump()<br>    except Exception as e:<br>        session.rollback()<br>        raise HTTPException(<br>            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e)<br>        )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def test_update_fields_relationship(<br>    app: FastAPI, async_client: AsyncClient, fake_articles, async_session, models<br>):<br>    class ArticleCrud(SqlalchemyCrud):<br>        router_prefix = "/article"<br>        update_exclude = {"content": {"id"}}<br>        update_fields = [<br>            models.Article.description,<br>            PropertyField(<br>                name="content", type_=ArticleContentSchema<br>            ),  # Relationship attribute<br>        ]<br>        read_fields = [<br>            models.Article.title,<br>            models.Article.description,<br>            PropertyField(<br>                name="content", type_=ArticleContentSchema<br>            ),  # Relationship attribute<br>        ]<br><br>    ins = ArticleCrud(models.Article, db.engine).register_crud()<br><br>    app.include_router(ins.router)<br><br>    # test schemas<br>    assert "id" not in model_fields(ins.schema_update)<br>    assert "title" not in model_fields(ins.schema_update)<br>    assert "description" in model_fields(ins.schema_update)<br>    assert "content" in model_fields(ins.schema_update)<br><br>    # test api<br>    res = await async_client.put(<br>        "/article/item/1",<br>        json={<br>            "title": "new_title",<br>            "description": "new_description",<br>            "content": {<br>                "id": 22,  # will be ignored by `update_exclude`<br>                "content": "new_content",<br>            },<br>        },<br>    )<br>    assert res.json()["data"] == 1<br><br>    article = await async_session.get(models.Article, 1)<br>    await async_session.refresh(article)<br><br>    assert article.title != "new_title"<br>    assert article.description == "new_description"<br><br>    content = await async_session.get(models.ArticleContent, 1)<br>    await async_session.refresh(content)<br>    assert content.content == "new_content"</code></pre></div></td>
    </tr>
    <tr>
      <td>shopping_item</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `update_shopping_item_status` that takes three arguments: `item_id`, `update_item`, and `session`. The first two are required parameters passed by the client, while the third is an optional database connection object provided by FastAPI's dependency injection system. - Uses SQLAlchemy to retrieve the shopping list item with the given ID from the database using the `select` method of the `Session` class. If the item is not found, raises a `HTTPException` with status code 404 (Not Found). - Updates the `is_purchased` and `purchased_by` attributes of the retrieved item based on the values in the `update_item` parameter. Adds the updated item back into the session for tracking changes. - Commits the transaction and refreshes the item object to ensure any new relationships or attribute updates are loaded. Returns the updated item data serialized using Pydantic's `ModelDump` method. - Handles exceptions during the execution of the function by rolling back the transaction and raising a `HTTPException` with status code 500 (Internal Server Error), passing along the exception message as the error detail.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def update_shopping_item_status(<br>    item_id: int, update_item: schemas.UpdateItem, session: Session<br>):<br>    try:<br>        item = session.exec(<br>            select(ShoppingList).where(ShoppingList.id == item_id)<br>        ).first()<br>        if not item:<br>            raise HTTPException(<br>                status_code=status.HTTP_404_NOT_FOUND, detail="Item not found"<br>            )<br>        item.is_purchased = update_item.is_purchased<br>        item.purchased_by = update_item.purchased_by<br>        session.add(item)<br>        session.commit()<br>        session.refresh(item)<br>        return item.model_dump()<br>    except Exception as e:<br>        session.rollback()<br>        raise HTTPException(<br>            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e)<br>        )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def update_item(<br>    *,<br>    item_id: int,<br>    item: Item = Body(<br>        openapi_examples={<br>            "normal": {<br>                "summary": "A normal example",<br>                "description": "A **normal** item works correctly.",<br>                "value": {<br>                    "name": "Foo",<br>                    "description": "A very nice Item",<br>                    "price": 35.4,<br>                    "tax": 3.2,<br>                },<br>            },<br>            "converted": {<br>                "summary": "An example with converted data",<br>                "description": "FastAPI can convert price `strings` to actual `numbers` automatically",<br>                "value": {<br>                    "name": "Bar",<br>                    "price": "35.4",<br>                },<br>            },<br>            "invalid": {<br>                "summary": "Invalid data is rejected with an error",<br>                "value": {<br>                    "name": "Baz",<br>                    "price": "thirty five point four",<br>                },<br>            },<br>        },<br>    ),<br>):<br>    results = {"item_id": item_id, "item": item}<br>    return results</code></pre></div></td>
    </tr>
    <tr>
      <td>shopping_item</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `update_shopping_item_status` that takes three arguments: `item_id`, `update_item`, and `session`. The first two are required parameters passed by the client, while the third is an optional database connection object provided by FastAPI's dependency injection system. - Uses SQLAlchemy to retrieve the shopping list item with the given ID from the database using the `select` method of the `Session` class. If the item is not found, raises a `HTTPException` with status code 404 (Not Found). - Updates the `is_purchased` and `purchased_by` attributes of the retrieved item based on the values in the `update_item` parameter. Adds the updated item back into the session for tracking changes. - Commits the transaction and refreshes the item object to ensure any new relationships or attribute updates are loaded. Returns the updated item data serialized using Pydantic's `ModelDump` method. - Handles exceptions during the execution of the function by rolling back the transaction and raising a `HTTPException` with status code 500 (Internal Server Error), passing along the exception message as the error detail.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def update_shopping_item_status(<br>    item_id: int, update_item: schemas.UpdateItem, session: Session<br>):<br>    try:<br>        item = session.exec(<br>            select(ShoppingList).where(ShoppingList.id == item_id)<br>        ).first()<br>        if not item:<br>            raise HTTPException(<br>                status_code=status.HTTP_404_NOT_FOUND, detail="Item not found"<br>            )<br>        item.is_purchased = update_item.is_purchased<br>        item.purchased_by = update_item.purchased_by<br>        session.add(item)<br>        session.commit()<br>        session.refresh(item)<br>        return item.model_dump()<br>    except Exception as e:<br>        session.rollback()<br>        raise HTTPException(<br>            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e)<br>        )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def update_item(<br>    *,<br>    item_id: int,<br>    item: Annotated[<br>        Item,<br>        Body(<br>            examples=[<br>                {<br>                    "name": "Foo",<br>                    "description": "A very nice Item",<br>                    "price": 35.4,<br>                    "tax": 3.2,<br>                },<br>                {<br>                    "name": "Bar",<br>                    "price": "35.4",<br>                },<br>                {<br>                    "name": "Baz",<br>                    "price": "thirty five point four",<br>                },<br>            ],<br>        ),<br>    ],<br>):<br>    results = {"item_id": item_id, "item": item}<br>    return results</code></pre></div></td>
    </tr>
    <tr>
      <td>shopping_item</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Defines a function `update_shopping_item_status` that takes three arguments: `item_id`, `update_item`, and `session`. The first two are required parameters passed by the client, while the third is an optional database connection object provided by FastAPI's dependency injection system. - Uses SQLAlchemy to retrieve the shopping list item with the given ID from the database using the `select` method of the `Session` class. If the item is not found, raises a `HTTPException` with status code 404 (Not Found). - Updates the `is_purchased` and `purchased_by` attributes of the retrieved item based on the values in the `update_item` parameter. Adds the updated item back into the session for tracking changes. - Commits the transaction and refreshes the item object to ensure any new relationships or attribute updates are loaded. Returns the updated item data serialized using Pydantic's `ModelDump` method. - Handles exceptions during the execution of the function by rolling back the transaction and raising a `HTTPException` with status code 500 (Internal Server Error), passing along the exception message as the error detail.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def update_shopping_item_status(<br>    item_id: int, update_item: schemas.UpdateItem, session: Session<br>):<br>    try:<br>        item = session.exec(<br>            select(ShoppingList).where(ShoppingList.id == item_id)<br>        ).first()<br>        if not item:<br>            raise HTTPException(<br>                status_code=status.HTTP_404_NOT_FOUND, detail="Item not found"<br>            )<br>        item.is_purchased = update_item.is_purchased<br>        item.purchased_by = update_item.purchased_by<br>        session.add(item)<br>        session.commit()<br>        session.refresh(item)<br>        return item.model_dump()<br>    except Exception as e:<br>        session.rollback()<br>        raise HTTPException(<br>            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e)<br>        )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def update_item(<br>    item_id: int,<br>    item: Item = Body(<br>        examples=[<br>            {<br>                "name": "Foo",<br>                "description": "A very nice Item",<br>                "price": 35.4,<br>                "tax": 3.2,<br>            }<br>        ],<br>    ),<br>):<br>    results = {"item_id": item_id, "item": item}<br>    return results</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Takes a command line argument (output file path) and sets it as `output_file`.<br>- Loops through Flask's routes and checks if they are of type `APIRoute`. If so, sets their `operation_ID` to their name and adds their module name to the tags list.<br>- Generates an OpenAPI schema using Flask's built-in method `openapi()`.<br>- Writes the generated JSON schema to the specified output file.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@needs_py39<br>def test_openapi_schema():<br>    from docs_src.header_params.tutorial002_an_py39 import app<br><br>    client = TestClient(app)<br>    response = client.get("/openapi.json")<br>    assert response.status_code == 200<br>    assert response.json() == {<br>        "openapi": "3.1.0",<br>        "info": {"title": "FastAPI", "version": "0.1.0"},<br>        "paths": {<br>            "/items/": {<br>                "get": {<br>                    "responses": {<br>                        "200": {<br>                            "description": "Successful Response",<br>                            "content": {"application/json": {"schema": {}}},<br>                        },<br>                        "422": {<br>                            "description": "Validation Error",<br>                            "content": {<br>                                "application/json": {<br>                                    "schema": {<br>                                        "$ref": "#/components/schemas/HTTPValidationError"<br>                                    }<br>                                }<br>                            },<br>                        },<br>                    },<br>                    "summary": "Read Items",<br>                    "operationId": "read_items_items__get",<br>                    "parameters": [<br>                        {<br>                            "required": False,<br>                            "schema": IsDict(<br>                                {<br>                                    "anyOf": [{"type": "string"}, {"type": "null"}],<br>                                    "title": "Strange Header",<br>                                }<br>                            )<br>                            | IsDict(<br>                                # TODO: remove when deprecating Pydantic v1<br>                                {"title": "Strange Header", "type": "string"}<br>                            ),<br>                            "name": "strange_header",<br>                            "in": "header",<br>                        }<br>                    ],<br>  </code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Takes a command line argument (output file path) and sets it as `output_file`.<br>- Loops through Flask's routes and checks if they are of type `APIRoute`. If so, sets their `operation_ID` to their name and adds their module name to the tags list.<br>- Generates an OpenAPI schema using Flask's built-in method `openapi()`.<br>- Writes the generated JSON schema to the specified output file.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@needs_py310<br>def test_openapi_schema():<br>    from docs_src.header_params.tutorial002_py310 import app<br><br>    client = TestClient(app)<br>    response = client.get("/openapi.json")<br>    assert response.status_code == 200<br>    assert response.json() == {<br>        "openapi": "3.1.0",<br>        "info": {"title": "FastAPI", "version": "0.1.0"},<br>        "paths": {<br>            "/items/": {<br>                "get": {<br>                    "responses": {<br>                        "200": {<br>                            "description": "Successful Response",<br>                            "content": {"application/json": {"schema": {}}},<br>                        },<br>                        "422": {<br>                            "description": "Validation Error",<br>                            "content": {<br>                                "application/json": {<br>                                    "schema": {<br>                                        "$ref": "#/components/schemas/HTTPValidationError"<br>                                    }<br>                                }<br>                            },<br>                        },<br>                    },<br>                    "summary": "Read Items",<br>                    "operationId": "read_items_items__get",<br>                    "parameters": [<br>                        {<br>                            "required": False,<br>                            "schema": IsDict(<br>                                {<br>                                    "anyOf": [{"type": "string"}, {"type": "null"}],<br>                                    "title": "Strange Header",<br>                                }<br>                            )<br>                            | IsDict(<br>                                # TODO: remove when deprecating Pydantic v1<br>                                {"title": "Strange Header", "type": "string"}<br>                            ),<br>                            "name": "strange_header",<br>                            "in": "header",<br>                        }<br>                    ],<br>   </code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Takes a command line argument (output file path) and sets it as `output_file`.<br>- Loops through Flask's routes and checks if they are of type `APIRoute`. If so, sets their `operation_ID` to their name and adds their module name to the tags list.<br>- Generates an OpenAPI schema using Flask's built-in method `openapi()`.<br>- Writes the generated JSON schema to the specified output file.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@needs_py39<br>def test_openapi_schema():<br>    from docs_src.cookie_params.tutorial001_an_py39 import app<br><br>    client = TestClient(app)<br>    response = client.get("/openapi.json")<br>    assert response.status_code == 200<br>    assert response.json() == {<br>        "openapi": "3.1.0",<br>        "info": {"title": "FastAPI", "version": "0.1.0"},<br>        "paths": {<br>            "/items/": {<br>                "get": {<br>                    "responses": {<br>                        "200": {<br>                            "description": "Successful Response",<br>                            "content": {"application/json": {"schema": {}}},<br>                        },<br>                        "422": {<br>                            "description": "Validation Error",<br>                            "content": {<br>                                "application/json": {<br>                                    "schema": {<br>                                        "$ref": "#/components/schemas/HTTPValidationError"<br>                                    }<br>                                }<br>                            },<br>                        },<br>                    },<br>                    "summary": "Read Items",<br>                    "operationId": "read_items_items__get",<br>                    "parameters": [<br>                        {<br>                            "required": False,<br>                            "schema": IsDict(<br>                                {<br>                                    "anyOf": [{"type": "string"}, {"type": "null"}],<br>                                    "title": "Ads Id",<br>                                }<br>                            )<br>                            | IsDict(<br>                                # TODO: remove when deprecating Pydantic v1<br>                                {"title": "Ads Id", "type": "string"}<br>                            ),<br>                            "name": "ads_id",<br>                            "in": "cookie",<br>                        }<br>                    ],<br>                }<br>        </code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Takes a command line argument (output file path) and sets it as `output_file`.<br>- Loops through Flask's routes and checks if they are of type `APIRoute`. If so, sets their `operation_ID` to their name and adds their module name to the tags list.<br>- Generates an OpenAPI schema using Flask's built-in method `openapi()`.<br>- Writes the generated JSON schema to the specified output file.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    def openapi(self) -> Dict[str, Any]:<br>        """<br>        Generate the OpenAPI schema of the application. This is called by FastAPI<br>        internally.<br><br>        The first time it is called it stores the result in the attribute<br>        `app.openapi_schema`, and next times it is called, it just returns that same<br>        result. To avoid the cost of generating the schema every time.<br><br>        If you need to modify the generated OpenAPI schema, you could modify it.<br><br>        Read more in the<br>        [FastAPI docs for OpenAPI](https://fastapi.tiangolo.com/how-to/extending-openapi/).<br>        """<br>        if not self.openapi_schema:<br>            self.openapi_schema = get_openapi(<br>                title=self.title,<br>                version=self.version,<br>                openapi_version=self.openapi_version,<br>                summary=self.summary,<br>                description=self.description,<br>                terms_of_service=self.terms_of_service,<br>                contact=self.contact,<br>                license_info=self.license_info,<br>                routes=self.routes,<br>                webhooks=self.webhooks.routes,<br>                tags=self.openapi_tags,<br>                servers=self.servers,<br>                separate_input_output_schemas=self.separate_input_output_schemas,<br>            )<br>        return self.openapi_schema</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Takes a command line argument (output file path) and sets it as `output_file`.<br>- Loops through Flask's routes and checks if they are of type `APIRoute`. If so, sets their `operation_ID` to their name and adds their module name to the tags list.<br>- Generates an OpenAPI schema using Flask's built-in method `openapi()`.<br>- Writes the generated JSON schema to the specified output file.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_openapi():<br>    response = client.get("/openapi.json")<br>    assert response.status_code == 200<br>    assert response.json() == {<br>        "openapi": "3.1.0",<br>        "info": {"title": "FastAPI", "version": "0.1.0"},<br>        "paths": {<br>            "/app": {<br>                "get": {<br>                    "summary": "Read Main",<br>                    "operationId": "read_main_app_get",<br>                    "responses": {<br>                        "200": {<br>                            "description": "Successful Response",<br>                            "content": {"application/json": {"schema": {}}},<br>                        }<br>                    },<br>                }<br>            }<br>        },<br>        "servers": [{"url": "/api/v1"}],<br>    }</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Takes a command line argument (output file path) and sets it as `output_file`.<br>- Loops through Flask's routes and checks if they are of type `APIRoute`. If so, sets their `operation_ID` to their name and adds their module name to the tags list.<br>- Generates an OpenAPI schema using Flask's built-in method `openapi()`.<br>- Writes the generated JSON schema to the specified output file.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def custom_openapi():<br>    if app.openapi_schema:<br>        return app.openapi_schema<br>    openapi_schema = get_openapi(<br>        title="Custom title",<br>        version="2.5.0",<br>        summary="This is a very custom OpenAPI schema",<br>        description="Here's a longer description of the custom **OpenAPI** schema",<br>        routes=app.routes,<br>    )<br>    openapi_schema["info"]["x-logo"] = {<br>        "url": "https://fastapi.tiangolo.com/-img/logo-margin/logo-teal.png"<br>    }<br>    app.openapi_schema = openapi_schema<br>    return app.openapi_schema</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Takes a command line argument (output file path) and sets it as `output_file`.<br>- Loops through Flask's routes and checks if they are of type `APIRoute`. If so, sets their `operation_ID` to their name and adds their module name to the tags list.<br>- Generates an OpenAPI schema using Flask's built-in method `openapi()`.<br>- Writes the generated JSON schema to the specified output file.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_openapi_schema(client: TestClient):<br>    response = client.get("/openapi.json")<br>    assert response.status_code == 200, response.text<br>    assert response.json() == {<br>        "openapi": "3.1.0",<br>        "info": {"title": "FastAPI", "version": "0.1.0"},<br>        "paths": {<br>            "/items/": {<br>                "post": {<br>                    "summary": "Create Item",<br>                    "operationId": "create_item_items__post",<br>                    "requestBody": {<br>                        "content": {<br>                            "application/x-yaml": {<br>                                "schema": {<br>                                    "title": "Item",<br>                                    "required": ["name", "tags"],<br>                                    "type": "object",<br>                                    "properties": {<br>                                        "name": {"title": "Name", "type": "string"},<br>                                        "tags": {<br>                                            "title": "Tags",<br>                                            "type": "array",<br>                                            "items": {"type": "string"},<br>                                        },<br>                                    },<br>                                }<br>                            }<br>                        },<br>                        "required": True,<br>                    },<br>                    "responses": {<br>                        "200": {<br>                            "description": "Successful Response",<br>                            "content": {"application/json": {"schema": {}}},<br>                        }<br>                    },<br>                }<br>            }<br>        },<br>    }</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Takes a command line argument (output file path) and sets it as `output_file`.<br>- Loops through Flask's routes and checks if they are of type `APIRoute`. If so, sets their `operation_ID` to their name and adds their module name to the tags list.<br>- Generates an OpenAPI schema using Flask's built-in method `openapi()`.<br>- Writes the generated JSON schema to the specified output file.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@needs_py310<br>def test_openapi_schema(client: TestClient):<br>    response = client.get("/openapi.json")<br>    assert response.status_code == 200, response.text<br>    assert response.json() == {<br>        "openapi": "3.1.0",<br>        "info": {"title": "FastAPI", "version": "0.1.0"},<br>        "paths": {<br>            "/items/": {<br>                "get": {<br>                    "responses": {<br>                        "200": {<br>                            "description": "Successful Response",<br>                            "content": {"application/json": {"schema": {}}},<br>                        },<br>                        "422": {<br>                            "description": "Validation Error",<br>                            "content": {<br>                                "application/json": {<br>                                    "schema": {<br>                                        "$ref": "#/components/schemas/HTTPValidationError"<br>                                    }<br>                                }<br>                            },<br>                        },<br>                    },<br>                    "summary": "Read Items",<br>                    "operationId": "read_items_items__get",<br>                    "parameters": [<br>                        {<br>                            "required": False,<br>                            "schema": IsDict(<br>                                {<br>                                    "anyOf": [{"type": "string"}, {"type": "null"}],<br>                                    "title": "Q",<br>                                }<br>                            )<br>                            | IsDict(<br>                                # TODO: remove when deprecating Pydantic v1<br>                                {"title": "Q", "type": "string"}<br>                            ),<br>                            "name": "q",<br>                            "in": "query",<br>                        },<br>                        {<br>                            "required": False,<br>                            "schema": {<br>                                "title": "Skip",<br>                                "type": "integer",<br>                                "default": 0,<br>                            },<br>                            "name": "skip",<br>                            "in": "query",<br>                        },<br>                        {<br>                            "required": False,<br>                            "schema": {<br>                                "title": "Limit",<br>                                "type": "integer",<br>                                "default": 100,<br>                            },<br>                            "name": "limit",<br>                            "in": "query",<br>                        },<br>                    ],<br>                }<br>            }<br>        },<br>        "components": {<br>            "schemas": {<br>                "ValidationError": {<br>                    "title": "ValidationError",<br>                    "required": ["loc", "msg", "type"],<br>                    "type": "object",<br>                    "properties": {<br>                        "loc": {<br>                            "title": "Location",<br>                            "type": "array",<br>                            "items": {<br>                                "anyOf": [{"type": "string"}, {"type": "integer"}]<br>                            },<br>                        },<br>                        "msg": {"title": "Message", "type": "string"},<br>                        "type": {"title": "Error Type", "type": "string"},<br>                    },<br>                },<br>                "HTTPValidationError": {<br>                    "title": "HTTPValidationError",<br>                    "type": "object",<br>                    "properties": {<br>                        "detail": {<br>                            "title": "Detail",<br>                            "type": "array",<br>                            "items": {"$ref": "#/components/schemas/ValidationError"},<br>                        }<br>                    },<br>                },<br>            }<br>        },<br>    }</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Takes a command line argument (output file path) and sets it as `output_file`.<br>- Loops through Flask's routes and checks if they are of type `APIRoute`. If so, sets their `operation_ID` to their name and adds their module name to the tags list.<br>- Generates an OpenAPI schema using Flask's built-in method `openapi()`.<br>- Writes the generated JSON schema to the specified output file.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@needs_py39<br>def test_openapi_schema(client: TestClient):<br>    response = client.get("/openapi.json")<br>    assert response.status_code == 200, response.text<br>    assert response.json() == {<br>        "openapi": "3.1.0",<br>        "info": {"title": "FastAPI", "version": "0.1.0"},<br>        "paths": {<br>            "/items/": {<br>                "get": {<br>                    "responses": {<br>                        "200": {<br>                            "description": "Successful Response",<br>                            "content": {"application/json": {"schema": {}}},<br>                        },<br>                        "422": {<br>                            "description": "Validation Error",<br>                            "content": {<br>                                "application/json": {<br>                                    "schema": {<br>                                        "$ref": "#/components/schemas/HTTPValidationError"<br>                                    }<br>                                }<br>                            },<br>                        },<br>                    },<br>                    "summary": "Read Items",<br>                    "operationId": "read_items_items__get",<br>                    "parameters": [<br>                        {<br>                            "required": False,<br>                            "schema": IsDict(<br>                                {<br>                                    "anyOf": [{"type": "string"}, {"type": "null"}],<br>                                    "title": "Q",<br>                                }<br>                            )<br>                            | IsDict(<br>                                # TODO: remove when deprecating Pydantic v1<br>                                {"title": "Q", "type": "string"}<br>                            ),<br>                            "name": "q",<br>                            "in": "query",<br>                        },<br>                        {<br>                            "required": False,<br>                            "schema": {<br>                                "title": "Skip",<br>                                "type": "integer",<br>                                "default": 0,<br>                            },<br>                            "name": "skip",<br>                            "in": "query",<br>                        },<br>                        {<br>                            "required": False,<br>                            "schema": {<br>                                "title": "Limit",<br>                                "type": "integer",<br>                                "default": 100,<br>                            },<br>                            "name": "limit",<br>                            "in": "query",<br>                        },<br>                    ],<br>                }<br>            }<br>        },<br>        "components": {<br>            "schemas": {<br>                "ValidationError": {<br>                    "title": "ValidationError",<br>                    "required": ["loc", "msg", "type"],<br>                    "type": "object",<br>                    "properties": {<br>                        "loc": {<br>                            "title": "Location",<br>                            "type": "array",<br>                            "items": {<br>                                "anyOf": [{"type": "string"}, {"type": "integer"}]<br>                            },<br>                        },<br>                        "msg": {"title": "Message", "type": "string"},<br>                        "type": {"title": "Error Type", "type": "string"},<br>                    },<br>                },<br>                "HTTPValidationError": {<br>                    "title": "HTTPValidationError",<br>                    "type": "object",<br>                    "properties": {<br>                        "detail": {<br>                            "title": "Detail",<br>                            "type": "array",<br>                            "items": {"$ref": "#/components/schemas/ValidationError"},<br>                        }<br>                    },<br>                },<br>            }<br>        },<br>    }</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves user information (username and session expiration time) from the current authenticated session using FastAPI's `Depends()` decorator to pass it as a parameter to the function. - Returns a custom response object called `WhoamiResponse`, which contains the retrieved user data. - If authentication fails or the session has expired, returns a HTTP status code of 401 Unauthorized with an error description provided by the `responses` dictionary.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users/me")<br>def read_current_user(credentials: Annotated[HTTPBasicCredentials, Depends(security)]):<br>    return {"username": credentials.username, "password": credentials.password}</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves user information (username and session expiration time) from the current authenticated session using FastAPI's `Depends()` decorator to pass it as a parameter to the function. - Returns a custom response object called `WhoamiResponse`, which contains the retrieved user data. - If authentication fails or the session has expired, returns a HTTP status code of 401 Unauthorized with an error description provided by the `responses` dictionary.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users/me")<br>def read_current_user(username: Annotated[str, Depends(get_current_username)]):<br>    return {"username": username}</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves user information (username and session expiration time) from the current authenticated session using FastAPI's `Depends()` decorator to pass it as a parameter to the function. - Returns a custom response object called `WhoamiResponse`, which contains the retrieved user data. - If authentication fails or the session has expired, returns a HTTP status code of 401 Unauthorized with an error description provided by the `responses` dictionary.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users/me")<br>def read_current_user(credentials: HTTPBasicCredentials = Depends(security)):<br>    return {"username": credentials.username, "password": credentials.password}</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves user information (username and session expiration time) from the current authenticated session using FastAPI's `Depends()` decorator to pass it as a parameter to the function. - Returns a custom response object called `WhoamiResponse`, which contains the retrieved user data. - If authentication fails or the session has expired, returns a HTTP status code of 401 Unauthorized with an error description provided by the `responses` dictionary.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_token_no_username():<br>    response = client.get(<br>        "/users/me",<br>        headers={<br>            "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJmb28ifQ.NnExK_dlNAYyzACrXtXDrcWOgGY2JuPbI4eDaHdfK5Y"<br>        },<br>    )<br>    assert response.status_code == 401, response.text<br>    assert response.json() == {"detail": "Could not validate credentials"}<br>    assert response.headers["WWW-Authenticate"] == 'Bearer scope="me"'</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves user information (username and session expiration time) from the current authenticated session using FastAPI's `Depends()` decorator to pass it as a parameter to the function. - Returns a custom response object called `WhoamiResponse`, which contains the retrieved user data. - If authentication fails or the session has expired, returns a HTTP status code of 401 Unauthorized with an error description provided by the `responses` dictionary.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_token_inexistent_user(client: TestClient):<br>    response = client.get(<br>        "/users/me",<br>        headers={<br>            "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VybmFtZTpib2IifQ.HcfCW67Uda-0gz54ZWTqmtgJnZeNem0Q757eTa9EZuw"<br>        },<br>    )<br>    assert response.status_code == 401, response.text<br>    assert response.json() == {"detail": "Could not validate credentials"}<br>    assert response.headers["WWW-Authenticate"] == 'Bearer scope="me"'</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves user information (username and session expiration time) from the current authenticated session using FastAPI's `Depends()` decorator to pass it as a parameter to the function. - Returns a custom response object called `WhoamiResponse`, which contains the retrieved user data. - If authentication fails or the session has expired, returns a HTTP status code of 401 Unauthorized with an error description provided by the `responses` dictionary.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):<br>    user = fake_decode_token(token)<br>    if not user:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid authentication credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return user</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves user information (username and session expiration time) from the current authenticated session using FastAPI's `Depends()` decorator to pass it as a parameter to the function. - Returns a custom response object called `WhoamiResponse`, which contains the retrieved user data. - If authentication fails or the session has expired, returns a HTTP status code of 401 Unauthorized with an error description provided by the `responses` dictionary.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users/me")<br>async def read_users_me(<br>    current_user: Annotated[User, Depends(get_current_active_user)]<br>):<br>    return current_user</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves user information (username and session expiration time) from the current authenticated session using FastAPI's `Depends()` decorator to pass it as a parameter to the function. - Returns a custom response object called `WhoamiResponse`, which contains the retrieved user data. - If authentication fails or the session has expired, returns a HTTP status code of 401 Unauthorized with an error description provided by the `responses` dictionary.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users/me")<br>async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):<br>    return current_user</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- Retrieves user information (username and session expiration time) from the current authenticated session using FastAPI's `Depends()` decorator to pass it as a parameter to the function. - Returns a custom response object called `WhoamiResponse`, which contains the retrieved user data. - If authentication fails or the session has expired, returns a HTTP status code of 401 Unauthorized with an error description provided by the `responses` dictionary.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users/me")<br>def read_current_user(username: Annotated[str, Depends(get_current_username)]):<br>    return {"username": username}</code></pre></div></td>
    </tr>
    <tr>
      <td>add_commutes</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function adds a new commute using FastAPI's `@router.post` decorator.<br>- The input parameter is a `CommuteEntity`, which represents the data needed to create a new commute.<br>- A new document reference is created with an automatically generated ID using Pydantic's `DocumentReference` class from Google Cloud Firestore SDK for Python.<br>- The commute data is saved into the new document using the `set()` method provided by Firestore.<br>- There is a TODO comment that suggests adding functionality to call a scheduler and save its output to the database. This step is not implemented yet.<br>- Finally, the function returns a dictionary containing the ID of the newly created document and a success message.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/")<br>async def add_commute(commute: CommuteEntity):<br>    """<br>    Add a new commute (not user specific yet)<br>    """<br><br>    # Create a new document reference with an auto-generated ID<br>    doc_ref = db.collection("commutes").document()<br><br>    # Save the commute data<br>    doc_ref.set(commute.model_dump())<br><br>    # TODO: Call the scheduler to schedule the commute and store it in the database (@william)<br>    # We can either store it in the same document or create a new collection for scheduled commutes and reference the commute ID<br><br>    # Return the ID of the newly created document<br>    return {"id": doc_ref.id, "message": "Commute added successfully!"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/", response_model=Job, status_code=201)<br>async def create_task(message: str):<br>    job = await redis.pool.enqueue_job("test_task", message)<br>    return {"id": job.job_id}</code></pre></div></td>
    </tr>
    <tr>
      <td>add_commutes</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function adds a new commute using FastAPI's `@router.post` decorator.<br>- The input parameter is a `CommuteEntity`, which represents the data needed to create a new commute.<br>- A new document reference is created with an automatically generated ID using Pydantic's `DocumentReference` class from Google Cloud Firestore SDK for Python.<br>- The commute data is saved into the new document using the `set()` method provided by Firestore.<br>- There is a TODO comment that suggests adding functionality to call a scheduler and save its output to the database. This step is not implemented yet.<br>- Finally, the function returns a dictionary containing the ID of the newly created document and a success message.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/")<br>async def add_commute(commute: CommuteEntity):<br>    """<br>    Add a new commute (not user specific yet)<br>    """<br><br>    # Create a new document reference with an auto-generated ID<br>    doc_ref = db.collection("commutes").document()<br><br>    # Save the commute data<br>    doc_ref.set(commute.model_dump())<br><br>    # TODO: Call the scheduler to schedule the commute and store it in the database (@william)<br>    # We can either store it in the same document or create a new collection for scheduled commutes and reference the commute ID<br><br>    # Return the ID of the newly created document<br>    return {"id": doc_ref.id, "message": "Commute added successfully!"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/heroes/")<br>def create_hero(hero: Hero):<br>    with Session(engine) as session:<br>        session.add(hero)<br>        session.commit()<br>        session.refresh(hero)<br>        return hero</code></pre></div></td>
    </tr>
    <tr>
      <td>add_commutes</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function adds a new commute using FastAPI's `@router.post` decorator.<br>- The input parameter is a `CommuteEntity`, which represents the data needed to create a new commute.<br>- A new document reference is created with an automatically generated ID using Pydantic's `DocumentReference` class from Google Cloud Firestore SDK for Python.<br>- The commute data is saved into the new document using the `set()` method provided by Firestore.<br>- There is a TODO comment that suggests adding functionality to call a scheduler and save its output to the database. This step is not implemented yet.<br>- Finally, the function returns a dictionary containing the ID of the newly created document and a success message.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/")<br>async def add_commute(commute: CommuteEntity):<br>    """<br>    Add a new commute (not user specific yet)<br>    """<br><br>    # Create a new document reference with an auto-generated ID<br>    doc_ref = db.collection("commutes").document()<br><br>    # Save the commute data<br>    doc_ref.set(commute.model_dump())<br><br>    # TODO: Call the scheduler to schedule the commute and store it in the database (@william)<br>    # We can either store it in the same document or create a new collection for scheduled commutes and reference the commute ID<br><br>    # Return the ID of the newly created document<br>    return {"id": doc_ref.id, "message": "Commute added successfully!"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/offers/")<br>async def create_offer(offer: Offer):<br>    return offer</code></pre></div></td>
    </tr>
    <tr>
      <td>add_commutes</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function adds a new commute using FastAPI's `@router.post` decorator.<br>- The input parameter is a `CommuteEntity`, which represents the data needed to create a new commute.<br>- A new document reference is created with an automatically generated ID using Pydantic's `DocumentReference` class from Google Cloud Firestore SDK for Python.<br>- The commute data is saved into the new document using the `set()` method provided by Firestore.<br>- There is a TODO comment that suggests adding functionality to call a scheduler and save its output to the database. This step is not implemented yet.<br>- Finally, the function returns a dictionary containing the ID of the newly created document and a success message.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/")<br>async def add_commute(commute: CommuteEntity):<br>    """<br>    Add a new commute (not user specific yet)<br>    """<br><br>    # Create a new document reference with an auto-generated ID<br>    doc_ref = db.collection("commutes").document()<br><br>    # Save the commute data<br>    doc_ref.set(commute.model_dump())<br><br>    # TODO: Call the scheduler to schedule the commute and store it in the database (@william)<br>    # We can either store it in the same document or create a new collection for scheduled commutes and reference the commute ID<br><br>    # Return the ID of the newly created document<br>    return {"id": doc_ref.id, "message": "Commute added successfully!"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@dataclass<br>class CorrelationIdMiddleware:<br>    app: "ASGIApp"<br>    header_name: str = "X-Request-ID"<br>    update_request_header: bool = True<br><br>    # ID-generating callable<br>    generator: Callable[[], str] = field(default=lambda: uuid4().hex)<br><br>    # ID validator<br>    validator: Optional[Callable[[str], bool]] = field(default=is_valid_uuid4)<br><br>    # ID transformer - can be used to clean/mutate IDs<br>    transformer: Optional[Callable[[str], str]] = field(default=lambda a: a)<br><br>    async def __call__(self, scope: "Scope", receive: "Receive", send: "Send") -> None:<br>        """<br>        Load request ID from headers if present. Generate one otherwise.<br>        """<br>        if scope["type"] not in ("http", "websocket"):<br>            await self.app(scope, receive, send)<br>            return<br><br>        # Try to load request ID from the request headers<br>        headers = MutableHeaders(scope=scope)<br>        header_value = headers.get(self.header_name.lower())<br><br>        validation_failed = False<br>        if not header_value:<br>            # Generate request ID if none was found<br>            id_value = self.generator()<br>        elif self.validator and not self.validator(header_value):<br>            # Also generate a request ID if one was found, but it was deemed invalid<br>            validation_failed = True<br>            id_value = self.generator()<br>        else:<br>            # Otherwise, use the found request ID<br>            id_value = header_value<br><br>        # Clean/change the ID if needed<br>        if self.transformer:<br>            id_value = self.transformer(id_value)<br><br>        if validation_failed is True:<br>            logger.warning(FAILED_VALIDATION_MESSAGE, id_value)<br><br>        # Update the request headers if needed<br>        if id_value != header_value and self.update_request_header is True:<br>            headers[self.header_name] = id_value<br><br>        correlation_id.set(id_value)<br>        self.sentry_extension(id_value)<br><br>        async def handle_outgoing_request(message: "Message") -> None:<br>            if message["t</code></pre></div></td>
    </tr>
    <tr>
      <td>add_commutes</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function adds a new commute using FastAPI's `@router.post` decorator.<br>- The input parameter is a `CommuteEntity`, which represents the data needed to create a new commute.<br>- A new document reference is created with an automatically generated ID using Pydantic's `DocumentReference` class from Google Cloud Firestore SDK for Python.<br>- The commute data is saved into the new document using the `set()` method provided by Firestore.<br>- There is a TODO comment that suggests adding functionality to call a scheduler and save its output to the database. This step is not implemented yet.<br>- Finally, the function returns a dictionary containing the ID of the newly created document and a success message.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/")<br>async def add_commute(commute: CommuteEntity):<br>    """<br>    Add a new commute (not user specific yet)<br>    """<br><br>    # Create a new document reference with an auto-generated ID<br>    doc_ref = db.collection("commutes").document()<br><br>    # Save the commute data<br>    doc_ref.set(commute.model_dump())<br><br>    # TODO: Call the scheduler to schedule the commute and store it in the database (@william)<br>    # We can either store it in the same document or create a new collection for scheduled commutes and reference the commute ID<br><br>    # Return the ID of the newly created document<br>    return {"id": doc_ref.id, "message": "Commute added successfully!"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@cached(cache=TTLCache(maxsize=4, ttl=1800))<br>async def get_category(category):<br>    """<br>    Retrieves the data for the provided category. The data is cached for 30 minutes locally, 1 hour via shared Redis.<br><br>    :returns: The data for category.<br>    :rtype: dict<br>    """<br><br>    # Adhere to category naming standard.<br>    category = category.lower()<br>    data_id = f"jhu.{category}"<br><br>    # check shared cache<br>    cache_results = await check_cache(data_id)<br>    if cache_results:<br>        LOGGER.info(f"{data_id} using shared cache results")<br>        results = cache_results<br>    else:<br>        LOGGER.info(f"{data_id} shared cache empty")<br>        # URL to request data from.<br>        url = BASE_URL + "time_series_covid19_%s_global.csv" % category<br><br>        # Request the data<br>        LOGGER.info(f"{data_id} Requesting data...")<br>        async with httputils.CLIENT_SESSION.get(url) as response:<br>            text = await response.text()<br><br>        LOGGER.debug(f"{data_id} Data received")<br><br>        # Parse the CSV.<br>        data = list(csv.DictReader(text.splitlines()))<br>        LOGGER.debug(f"{data_id} CSV parsed")<br><br>        # The normalized locations.<br>        locations = []<br><br>        for item in data:<br>            # Filter out all the dates.<br>            dates = dict(<br>                filter(lambda element: date_util.is_date(element[0]), item.items())<br>            )<br><br>            # Make location history from dates.<br>            history = {date: int(float(amount or 0)) for date, amount in dates.items()}<br><br>            # Latest data insert value.<br>            latest = list(history.values())[-1]<br><br>            # Country for this location.<br>            country = item["Country/Region"]<br><br>            # Normalize the item and append to locations.<br>            locations.append(<br>                {<br>                    "country": country,<br>                    "country_code": countries.country_code(country),<br>                    "province": item["Province/State"],<br>                    "coordinates": {<br>                        "lat</code></pre></div></td>
    </tr>
    <tr>
      <td>add_commutes</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function adds a new commute using FastAPI's `@router.post` decorator.<br>- The input parameter is a `CommuteEntity`, which represents the data needed to create a new commute.<br>- A new document reference is created with an automatically generated ID using Pydantic's `DocumentReference` class from Google Cloud Firestore SDK for Python.<br>- The commute data is saved into the new document using the `set()` method provided by Firestore.<br>- There is a TODO comment that suggests adding functionality to call a scheduler and save its output to the database. This step is not implemented yet.<br>- Finally, the function returns a dictionary containing the ID of the newly created document and a success message.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/")<br>async def add_commute(commute: CommuteEntity):<br>    """<br>    Add a new commute (not user specific yet)<br>    """<br><br>    # Create a new document reference with an auto-generated ID<br>    doc_ref = db.collection("commutes").document()<br><br>    # Save the commute data<br>    doc_ref.set(commute.model_dump())<br><br>    # TODO: Call the scheduler to schedule the commute and store it in the database (@william)<br>    # We can either store it in the same document or create a new collection for scheduled commutes and reference the commute ID<br><br>    # Return the ID of the newly created document<br>    return {"id": doc_ref.id, "message": "Commute added successfully!"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def get_category(category):<br>    """<br>    Retrieves the data for the provided category. The data is cached for 30 minutes locally, 1 hour via shared Redis.<br><br>    :returns: The data for category.<br>    :rtype: dict<br>    """<br><br>    # Adhere to category naming standard.<br>    category = category.lower()<br>    data_id = f"jhu.{category}"<br><br>    # check shared cache<br>    cache_results = await check_cache(data_id)<br>    if cache_results:<br>        LOGGER.info(f"{data_id} using shared cache results")<br>        results = cache_results<br>    else:<br>        LOGGER.info(f"{data_id} shared cache empty")<br>        # URL to request data from.<br>        url = BASE_URL + "time_series_covid19_%s_global.csv" % category<br><br>        # Request the data<br>        LOGGER.info(f"{data_id} Requesting data...")<br>        async with httputils.CLIENT_SESSION.get(url) as response:<br>            text = await response.text()<br><br>        LOGGER.debug(f"{data_id} Data received")<br><br>        # Parse the CSV.<br>        data = list(csv.DictReader(text.splitlines()))<br>        LOGGER.debug(f"{data_id} CSV parsed")<br><br>        # The normalized locations.<br>        locations = []<br><br>        for item in data:<br>            # Filter out all the dates.<br>            dates = dict(<br>                filter(lambda element: date_util.is_date(element[0]), item.items())<br>            )<br><br>            # Make location history from dates.<br>            history = {date: int(float(amount or 0)) for date, amount in dates.items()}<br><br>            # Latest data insert value.<br>            latest = list(history.values())[-1]<br><br>            # Country for this location.<br>            country = item["Country/Region"]<br><br>            # Normalize the item and append to locations.<br>            locations.append(<br>                {<br>                    "country": country,<br>                    "country_code": countries.country_code(country),<br>                    "province": item["Province/State"],<br>                    "coordinates": {<br>                        "lat": item["Lat"],<br>                        "long</code></pre></div></td>
    </tr>
    <tr>
      <td>add_commutes</td>
      <td>openai_text</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function adds a new commute using FastAPI's `@router.post` decorator.<br>- The input parameter is a `CommuteEntity`, which represents the data needed to create a new commute.<br>- A new document reference is created with an automatically generated ID using Pydantic's `DocumentReference` class from Google Cloud Firestore SDK for Python.<br>- The commute data is saved into the new document using the `set()` method provided by Firestore.<br>- There is a TODO comment that suggests adding functionality to call a scheduler and save its output to the database. This step is not implemented yet.<br>- Finally, the function returns a dictionary containing the ID of the newly created document and a success message.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/")<br>async def add_commute(commute: CommuteEntity):<br>    """<br>    Add a new commute (not user specific yet)<br>    """<br><br>    # Create a new document reference with an auto-generated ID<br>    doc_ref = db.collection("commutes").document()<br><br>    # Save the commute data<br>    doc_ref.set(commute.model_dump())<br><br>    # TODO: Call the scheduler to schedule the commute and store it in the database (@william)<br>    # We can either store it in the same document or create a new collection for scheduled commutes and reference the commute ID<br><br>    # Return the ID of the newly created document<br>    return {"id": doc_ref.id, "message": "Commute added successfully!"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/", response_model=Job, status_code=201)<br>async def create_task(message: str):<br>    job = await redis.pool.enqueue_job("test_task", message)<br>    return {"id": job.job_id}</code></pre></div></td>
    </tr>
    <tr>
      <td>add_commutes</td>
      <td>openai_text</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function adds a new commute using FastAPI's `@router.post` decorator.<br>- The input parameter is a `CommuteEntity`, which represents the data needed to create a new commute.<br>- A new document reference is created with an automatically generated ID using Pydantic's `DocumentReference` class from Google Cloud Firestore SDK for Python.<br>- The commute data is saved into the new document using the `set()` method provided by Firestore.<br>- There is a TODO comment that suggests adding functionality to call a scheduler and save its output to the database. This step is not implemented yet.<br>- Finally, the function returns a dictionary containing the ID of the newly created document and a success message.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/")<br>async def add_commute(commute: CommuteEntity):<br>    """<br>    Add a new commute (not user specific yet)<br>    """<br><br>    # Create a new document reference with an auto-generated ID<br>    doc_ref = db.collection("commutes").document()<br><br>    # Save the commute data<br>    doc_ref.set(commute.model_dump())<br><br>    # TODO: Call the scheduler to schedule the commute and store it in the database (@william)<br>    # We can either store it in the same document or create a new collection for scheduled commutes and reference the commute ID<br><br>    # Return the ID of the newly created document<br>    return {"id": doc_ref.id, "message": "Commute added successfully!"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/heroes/", response_model=HeroRead)<br>def create_hero(hero: HeroCreate):<br>    with Session(engine) as session:<br>        db_hero = Hero.model_validate(hero)<br>        session.add(db_hero)<br>        session.commit()<br>        session.refresh(db_hero)<br>        return db_hero</code></pre></div></td>
    </tr>
    <tr>
      <td>add_commutes</td>
      <td>openai_text</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">- This function adds a new commute using FastAPI's `@router.post` decorator.<br>- The input parameter is a `CommuteEntity`, which represents the data needed to create a new commute.<br>- A new document reference is created with an automatically generated ID using Pydantic's `DocumentReference` class from Google Cloud Firestore SDK for Python.<br>- The commute data is saved into the new document using the `set()` method provided by Firestore.<br>- There is a TODO comment that suggests adding functionality to call a scheduler and save its output to the database. This step is not implemented yet.<br>- Finally, the function returns a dictionary containing the ID of the newly created document and a success message.</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/")<br>async def add_commute(commute: CommuteEntity):<br>    """<br>    Add a new commute (not user specific yet)<br>    """<br><br>    # Create a new document reference with an auto-generated ID<br>    doc_ref = db.collection("commutes").document()<br><br>    # Save the commute data<br>    doc_ref.set(commute.model_dump())<br><br>    # TODO: Call the scheduler to schedule the commute and store it in the database (@william)<br>    # We can either store it in the same document or create a new collection for scheduled commutes and reference the commute ID<br><br>    # Return the ID of the newly created document<br>    return {"id": doc_ref.id, "message": "Commute added successfully!"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    def route_create(self) -> Callable:<br>        async def route(<br>            request: Request,<br>            data: Annotated[Union[List[self.schema_create], self.schema_create], Body()],  # type: ignore<br>        ) -> BaseApiOut[Union[int, self.schema_model]]:  # type: ignore<br>            if not await self.has_create_permission(request, data):<br>                return self.error_no_router_permission(request)<br>            if not isinstance(data, list):<br>                data = [data]<br>            try:<br>                items = await self.create_items(request, data)<br>            except Exception as error:<br>                await self.db.async_rollback()<br>                return self.error_execute_sql(request=request, error=error)<br>            result = len(items)<br>            if result == 1:  # if only one item, return the first item<br>                result = await self.db.async_run_sync(<br>                    lambda _: parse_obj_to_schema(<br>                        items[0], self.schema_model, refresh=True<br>                    )<br>                )<br>            return BaseApiOut(data=result)<br><br>        return route</code></pre></div></td>
    </tr>
  </tbody>
</table>