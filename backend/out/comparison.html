<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>filename</th>
      <th>model_name</th>
      <th>index</th>
      <th>query</th>
      <th>found_snippet</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>translation_api</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_create_item_list():<br>    client = get_app_client()<br>    client_no = get_app_client(separate_input_output_schemas=False)<br>    data = [<br>        {"name": "Plumbus"},<br>        {<br>            "name": "Portal Gun",<br>            "description": "Device to travel through the multi-rick-verse",<br>        },<br>    ]<br>    response = client.post("/items-list/", json=data)<br>    response2 = client_no.post("/items-list/", json=data)<br>    assert response.status_code == response2.status_code == 200, response.text<br>    assert (<br>        response.json()<br>        == response2.json()<br>        == [<br>            {"name": "Plumbus", "description": None, "sub": None},<br>            {<br>                "name": "Portal Gun",<br>                "description": "Device to travel through the multi-rick-verse",<br>                "sub": None,<br>            },<br>        ]<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.where import tutorial009_py310 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(mod.sqlite_url)<br>    calls = []<br><br>    new_print = get_testing_print_function(calls)<br><br>    with patch("builtins.print", new=new_print):<br>        mod.main()<br>    assert calls == [<br>        [{"name": "Tarantula", "secret_name": "Natalia Roman-on", "age": 32, "id": 4}],<br>        [{"name": "Black Lion", "secret_name": "Trevor Challa", "age": 35, "id": 5}],<br>        [<br>            {<br>                "name": "Captain North America",<br>                "secret_name": "Esteban Rogelios",<br>                "age": 93,<br>                "id": 7,<br>            }<br>        ],<br>    ]</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_api():<br>    client = TestClient(app)<br><br>    text = """But Google is starting from behind. The company made a late push<br>    into hardware, and Apple's Siri, available on iPhones, and Amazon's Alexa<br>    software, which runs on its Echo and Dot devices, have clear leads in<br>    consumer adoption."""<br><br>    request_data = {<br>        "values": [{"recordId": "a1", "data": {"text": text, "language": "en"}}]<br>    }<br><br>    response = client.post("/spacy_entities", json=request_data)<br>    assert response.status_code == 200<br><br>    first_record = response.json()["values"][0]<br>    assert first_record["recordId"] == "a1"<br>    assert first_record["errors"] == None<br>    assert first_record["warnings"] == None<br><br>    assert first_record["data"]["entities"] == [<br>        "Alexa",<br>        "Amazon",<br>        "Apple",<br>        "Echo and Dot",<br>        "Google",<br>        "iPhones",<br>        "Siri",<br>    ]</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">        async def route(request: Request, data: self.schema):  # type:ignore<br>            return await self.handle(request, data)  # type:ignore</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    def route_submit(self):<br>        async def route(request: Request, data: self.schema):  # type:ignore<br>            return await self.handle(request, data)  # type:ignore<br><br>        return route</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">        async def route(<br>            request: Request,<br>            data: Annotated[Union[List[self.schema_create], self.schema_create], Body()],  # type: ignore<br>        ) -> BaseApiOut[Union[int, self.schema_model]]:  # type: ignore<br>            if not await self.has_create_permission(request, data):<br>                return self.error_no_router_permission(request)<br>            if not isinstance(data, list):<br>                data = [data]<br>            try:<br>                items = await self.create_items(request, data)<br>            except Exception as error:<br>                await self.db.async_rollback()<br>                return self.error_execute_sql(request=request, error=error)<br>            result = len(items)<br>            if result == 1:  # if only one item, return the first item<br>                result = await self.db.async_run_sync(<br>                    lambda _: parse_obj_to_schema(<br>                        items[0], self.schema_model, refresh=True<br>                    )<br>                )<br>            return BaseApiOut(data=result)</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>reacc</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    def register_routes(self):<br>        """Register TMS endpoint routes."""<br><br>        @self.router.get(<br>            r"/tileMatrixSets",<br>            response_model=TileMatrixSetList,<br>            response_model_exclude_none=True,<br>            summary="Retrieve the list of available tiling schemes (tile matrix sets).",<br>            operation_id="getTileMatrixSetsList",<br>        )<br>        async def TileMatrixSet_list(request: Request):<br>            """<br>            OGC Specification: http://docs.opengeospatial.org/per/19-069.html#_tilematrixsets<br>            """<br>            return {<br>                "tileMatrixSets": [<br>                    {<br>                        "id": tms,<br>                        "title": tms,<br>                        "links": [<br>                            {<br>                                "href": self.url_for(<br>                                    request,<br>                                    "TileMatrixSet_info",<br>                                    TileMatrixSetId=tms,<br>                                ),<br>                                "rel": "item",<br>                                "type": "application/json",<br>                            }<br>                        ],<br>                    }<br>                    for tms in self.supported_tms.list()<br>                ]<br>            }<br><br>        @self.router.get(<br>            r"/tileMatrixSets/{TileMatrixSetId}",<br>            response_model=TileMatrixSet,<br>            response_model_exclude_none=True,<br>            summary="Retrieve the definition of the specified tiling scheme (tile matrix set).",<br>            operation_id="getTileMatrixSet",<br>        )<br>        async def TileMatrixSet_info(<br>            TileMatrixSetId: Literal[tuple(self.supported_tms.list())] = Path(<br>                ..., description="TileMatrixSet Name."<br>            )<br>        ):<br>            """<br>            OGC Specification: http://docs.opengeospatial.org/per/19-069.html#_tilematrixset<br>            """<br>            return self.supported_tms.get(TileMatrixSetId)</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>reacc</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">        @self.router.post(<br>            self.file_path, response_model=BaseApiOut[self.UploadOutSchema]<br>        )<br>        async def file_upload(file: UploadFile = File(...)):<br>            filename = self.get_filename(file)<br>            file_path = Path(self.file_directory) / filename<br>            os.makedirs(file_path.parent, exist_ok=True)<br>            try:<br>                res = await file.read()<br>                if self.file_max_size and len(res) > self.file_max_size:<br>                    return BaseApiOut(status=-2, msg="The file size exceeds the limit")<br>                async with aiofiles.open(file_path, "wb") as f:<br>                    await f.write(res)<br>                return BaseApiOut(<br>                    data=self.UploadOutSchema(<br>                        filename=filename, url=f"{self.static_path}/{filename}"<br>                    ),<br>                )<br><br>            except Exception as e:<br>                return BaseApiOut(status=-1, msg=str(e))</code></pre></div></td>
    </tr>
    <tr>
      <td>translation_api</td>
      <td>reacc</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("")<br>def call_translate(<br>    request: Request, data: schemas.TranslationInput<br>) -> schemas.TranslationResult:<br>    # Limit text length to avoid abuse<br>    if len(data.text) > 100:<br>        return {"error": "text too long"}, 400<br><br>    # Get native language<br>    native_language = request.state.user.native_language<br>    try:<br>        native_language_code = langcodes.find(native_language).language<br>    except LookupError:<br>        native_language_code = None<br><br>    # Translate text<br>    response = translation_client.translate_text(<br>        request={<br>            "parent": config.GC_TRANSLATION_LOCATION,<br>            "contents": [data.text],<br>            "mime_type": "text/plain",<br>            "target_language_code": "en-US",<br>            "source_language_code": native_language_code,<br>        }<br>    )<br>    translation = response.translations[0].translated_text<br><br>    # Track in Mixpanel<br>    mixpanel.track_in_request(<br>        "Translate in Video Call",<br>        {<br>            "Text": data.text,<br>            "Translation": translation,<br>            "Native Language": native_language,<br>            "Native Language Code": native_language_code,<br>        },<br>        request=request,<br>    )<br><br>    return schemas.TranslationResult(translation=translation)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, scope: Scope, receive: Receive, send: Send):<br>        """Handle call."""<br>        if scope["type"] == "http":<br>            request = Request(scope)<br><br>            DECODE_FORMAT = "latin-1"<br><br>            query_string = ""<br>            for k, v in request.query_params.multi_items():<br>                query_string += k.lower() + "=" + v + "&"<br><br>            query_string = query_string[:-1]<br>            request.scope["query_string"] = query_string.encode(DECODE_FORMAT)<br><br>        await self.app(scope, receive, send)</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.where import tutorial010 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(mod.sqlite_url)<br>    calls = []<br><br>    new_print = get_testing_print_function(calls)<br><br>    with patch("builtins.print", new=new_print):<br>        mod.main()<br>    assert calls == [<br>        [{"name": "Tarantula", "secret_name": "Natalia Roman-on", "age": 32, "id": 4}],<br>        [{"name": "Black Lion", "secret_name": "Trevor Challa", "age": 35, "id": 5}],<br>        [<br>            {<br>                "name": "Captain North America",<br>                "secret_name": "Esteban Rogelios",<br>                "age": 93,<br>                "id": 7,<br>            }<br>        ],<br>    ]</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.where import tutorial010_py310 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(mod.sqlite_url)<br>    calls = []<br><br>    new_print = get_testing_print_function(calls)<br><br>    with patch("builtins.print", new=new_print):<br>        mod.main()<br>    assert calls == [<br>        [{"name": "Tarantula", "secret_name": "Natalia Roman-on", "age": 32, "id": 4}],<br>        [{"name": "Black Lion", "secret_name": "Trevor Challa", "age": 35, "id": 5}],<br>        [<br>            {<br>                "name": "Captain North America",<br>                "secret_name": "Esteban Rogelios",<br>                "age": 93,<br>                "id": 7,<br>            }<br>        ],<br>    ]</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.where import tutorial009 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(mod.sqlite_url)<br>    calls = []<br><br>    new_print = get_testing_print_function(calls)<br><br>    with patch("builtins.print", new=new_print):<br>        mod.main()<br>    assert calls == [<br>        [{"name": "Tarantula", "secret_name": "Natalia Roman-on", "age": 32, "id": 4}],<br>        [{"name": "Black Lion", "secret_name": "Trevor Challa", "age": 35, "id": 5}],<br>        [<br>            {<br>                "name": "Captain North America",<br>                "secret_name": "Esteban Rogelios",<br>                "age": 93,<br>                "id": 7,<br>            }<br>        ],<br>    ]</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/text")<br>def get_text():<br>    return "Hello World"</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/", response_class=PlainTextResponse)<br>async def main():<br>    return "Hello World"</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def app(request: Request) -> Response:<br>        try:<br>            body: Any = None<br>            if body_field:<br>                if is_body_form:<br>                    body = await request.form()<br>                    stack = request.scope.get("fastapi_astack")<br>                    assert isinstance(stack, AsyncExitStack)<br>                    stack.push_async_callback(body.close)<br>                else:<br>                    body_bytes = await request.body()<br>                    if body_bytes:<br>                        json_body: Any = Undefined<br>                        content_type_value = request.headers.get("content-type")<br>                        if not content_type_value:<br>                            json_body = await request.json()<br>                        else:<br>                            message = email.message.Message()<br>                            message["content-type"] = content_type_value<br>                            if message.get_content_maintype() == "application":<br>                                subtype = message.get_content_subtype()<br>                                if subtype == "json" or subtype.endswith("+json"):<br>                                    json_body = await request.json()<br>                        if json_body != Undefined:<br>                            body = json_body<br>                        else:<br>                            body = body_bytes<br>        except json.JSONDecodeError as e:<br>            raise RequestValidationError(<br>                [<br>                    {<br>                        "type": "json_invalid",<br>                        "loc": ("body", e.pos),<br>                        "msg": "JSON decode error",<br>                        "input": {},<br>                        "ctx": {"error": e.msg},<br>                    }<br>                ],<br>                body=e.doc,<br>            ) from e<br>        except HTTPException:<br>            raise<br>        except Exception as e:<br>            raise HTTPException(<br>                status_code=400, detail="There was an error pa</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>reacc</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    @app.middleware("http")<br>    async def logger_request(request: Request, call_next) -> Response:<br>        # https://stackoverflow.com/questions/60098005/fastapi-starlette-get-client-real-ip<br>        # logger.info(f"访问记录:{request.method} url:{request.url}\nheaders:{request.headers}\nIP:{request.client.host}")<br>        response = await call_next(request)<br>        return response</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>reacc</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">        @app.get("/", responses={"500": {"model": NonPydanticModel}})<br>        def read_root():<br>            pass  # pragma: nocover</code></pre></div></td>
    </tr>
    <tr>
      <td>serve_model_llm</td>
      <td>reacc</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.handler()<br>def handler(context: dict, request: Request) -> Response:<br>    """Handle a request to generate text from a prompt."""<br>    system = "A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions."<br>    prompt = request.json.get("prompt")<br>    prompt_template = (<br>        f"### System:\n{system}\n\n### User:\n{prompt}\n\n### Assistant:\n"<br>    )<br>    temperature = request.json.get("temperature", 0.7)<br>    max_new_tokens = request.json.get("max_new_tokens", 512)<br>    model = context.get("model")<br>    tokenizer = context.get("tokenizer")<br>    input_ids = tokenizer(prompt_template, return_tensors="pt").input_ids.cuda()<br>    output = model.generate(<br>        inputs=input_ids, temperature=temperature, max_new_tokens=max_new_tokens<br>    )<br>    result = tokenizer.decode(output[0])<br>    return Response(json={"outputs": result}, status=200)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    @contextlib.asynccontextmanager<br>    async def ep_middleware(ctx: JsonRpcContext):<br>        ctx.http_response.set_cookie(key="ep_middleware_enter", value="1")<br>        yield<br>        ctx.http_response.set_cookie(key="ep_middleware_exit", value="2")</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def health():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def ping():<br>    """Health check."""<br>    return {"ping": "pong!"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def health():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def ping():<br>    """Health check."""<br>    return {"ping": "pong!"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def health():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_health(app):<br>    """Test /healthz endpoint."""<br>    response = app.get("/healthz")<br>    assert response.status_code == 200<br>    assert response.json() == {"ping": "pong!"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def health():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/", status_code=204)<br>async def health(session: AsyncSession = Depends(get_session)):<br>    try:<br>        await asyncio.wait_for(session.execute("SELECT 1"), timeout=1)<br>    except (asyncio.TimeoutError, socket.gaierror):<br>        return Response(status_code=503)<br>    return Response(status_code=204)</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def health():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/healthcheck", include_in_schema=False)<br>async def healthcheck() -> dict[str, str]:<br>    return {"status": "ok"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def health():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/healthz", description="Health Check", tags=["Health Check"])<br>def ping():<br>    """Health check."""<br>    return {"ping": "pong!"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>reacc</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def health():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/", dependencies=[Depends(get_token_data)])<br>async def home():<br>    return "Hello World!"</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>reacc</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def health():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    @router.get("/hello/")<br>    def hello_page() -> str:<br>        return "Hello, World!"</code></pre></div></td>
    </tr>
    <tr>
      <td>login</td>
      <td>reacc</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/login")<br>def health():<br>    return None</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    @app.get("/route1")<br>    async def route1():<br>        """route1."""<br>        return "yo"</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def get_graphql_response(<br>    *,<br>    settings: Settings,<br>    query: str,<br>    after: Union[str, None] = None,<br>    category_id: Union[str, None] = None,<br>    discussion_number: Union[int, None] = None,<br>    discussion_id: Union[str, None] = None,<br>    comment_id: Union[str, None] = None,<br>    body: Union[str, None] = None,<br>) -> Dict[str, Any]:<br>    headers = {"Authorization": f"token {settings.input_token.get_secret_value()}"}<br>    # some fields are only used by one query, but GraphQL allows unused variables, so<br>    # keep them here for simplicity<br>    variables = {<br>        "after": after,<br>        "category_id": category_id,<br>        "discussion_number": discussion_number,<br>        "discussion_id": discussion_id,<br>        "comment_id": comment_id,<br>        "body": body,<br>    }<br>    response = httpx.post(<br>        github_graphql_url,<br>        headers=headers,<br>        timeout=settings.httpx_timeout,<br>        json={"query": query, "variables": variables, "operationName": "Q"},<br>    )<br>    if response.status_code != 200:<br>        logging.error(<br>            f"Response was not 200, after: {after}, category_id: {category_id}"<br>        )<br>        logging.error(response.text)<br>        raise RuntimeError(response.text)<br>    data = response.json()<br>    if "errors" in data:<br>        logging.error(f"Errors in response, after: {after}, category_id: {category_id}")<br>        logging.error(response.text)<br>        raise RuntimeError(response.text)<br>    return cast(Dict[str, Any], data)</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.put("/{user_id}/", response_model=UserOut, dependencies=[Depends(on_superuser)])<br>async def update_user(<br>    user_id: int, user_in: UserUpdate, session: AsyncSession = Depends(get_session)<br>):<br>    user = await crud_user.get(session, id=user_id)<br>    if user is None:<br>        raise HTTPException(<br>            status_code=404,<br>            detail="The user with this username does not exist in the system",<br>        )<br>    try:<br>        user = await crud_user.update(<br>            session,<br>            db_obj=user,<br>            obj_in={<br>                **user_in.dict(exclude={"password"}, exclude_none=True),<br>                "hashed_password": get_password_hash(user_in.password),<br>            },<br>        )<br>    except IntegrityError:<br>        raise HTTPException(<br>            status_code=409, detail="User with this username already exits"<br>        )<br>    return user</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def app(request: Request) -> Response:<br>        try:<br>            body: Any = None<br>            if body_field:<br>                if is_body_form:<br>                    body = await request.form()<br>                    stack = request.scope.get("fastapi_astack")<br>                    assert isinstance(stack, AsyncExitStack)<br>                    stack.push_async_callback(body.close)<br>                else:<br>                    body_bytes = await request.body()<br>                    if body_bytes:<br>                        json_body: Any = Undefined<br>                        content_type_value = request.headers.get("content-type")<br>                        if not content_type_value:<br>                            json_body = await request.json()<br>                        else:<br>                            message = email.message.Message()<br>                            message["content-type"] = content_type_value<br>                            if message.get_content_maintype() == "application":<br>                                subtype = message.get_content_subtype()<br>                                if subtype == "json" or subtype.endswith("+json"):<br>                                    json_body = await request.json()<br>                        if json_body != Undefined:<br>                            body = json_body<br>                        else:<br>                            body = body_bytes<br>        except json.JSONDecodeError as e:<br>            raise RequestValidationError(<br>                [<br>                    {<br>                        "type": "json_invalid",<br>                        "loc": ("body", e.pos),<br>                        "msg": "JSON decode error",<br>                        "input": {},<br>                        "ctx": {"error": e.msg},<br>                    }<br>                ],<br>                body=e.doc,<br>            ) from e<br>        except HTTPException:<br>            raise<br>        except Exception as e:<br>            raise HTTPException(<br>                status_code=400, detail="There was an error pa</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/login/", response_model=Token)<br>async def login(<br>    data: OAuth2PasswordRequestForm = Depends(),<br>    session: AsyncSession = Depends(get_session),<br>):<br>    user = await authenticate(session, email=data.username, password=data.password)<br>    if user is None:<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br>    if not user.is_active:<br>        raise HTTPException(status_code=400, detail="Inactive user")<br>    return {"access_token": create_access_token(user), "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.put("/{user_id}/", response_model=UserOut, dependencies=[Depends(on_superuser)])<br>async def update_user(<br>    user_id: int, user_in: UserUpdate, session: AsyncSession = Depends(get_session)<br>):<br>    user = await crud_user.get(session, id=user_id)<br>    if user is None:<br>        raise HTTPException(<br>            status_code=404,<br>            detail="The user with this username does not exist in the system",<br>        )<br>    try:<br>        user = await crud_user.update(<br>            session,<br>            db_obj=user,<br>            obj_in={<br>                **user_in.dict(exclude={"password"}, exclude_none=True),<br>                "hashed_password": get_password_hash(user_in.password),<br>            },<br>        )<br>    except IntegrityError:<br>        raise HTTPException(<br>            status_code=409, detail="User with this username already exits"<br>        )<br>    return user</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/users/", response_model=ResponseMessage, tags=["users"])<br>async def create_user(user: User):<br>    return {"message": "User received"}</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>reacc</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/open", response_model=User)<br>def create_user_open(<br>    *,<br>    username: str = Body(...),<br>    password: str = Body(...),<br>    email: EmailStr = Body(None),<br>    full_name: str = Body(None),<br>):<br>    """<br>    Create new user without the need to be logged in.<br>    """<br>    if not config.USERS_OPEN_REGISTRATION:<br>        raise HTTPException(<br>            status_code=403,<br>            detail="Open user resistration is forbidden on this server",<br>        )<br>    bucket = get_default_bucket()<br>    user = crud.user.get(bucket, username=username)<br>    if user:<br>        raise HTTPException(<br>            status_code=400,<br>            detail="The user with this username already exists in the system",<br>        )<br>    user_in = UserCreate(<br>        username=username, password=password, email=email, full_name=full_name<br>    )<br>    user = crud.user.upsert(bucket, user_in=user_in, persist_to=1)<br>    if config.EMAILS_ENABLED and user_in.email:<br>        send_new_account_email(<br>            email_to=user_in.email, username=user_in.username, password=user_in.password<br>        )<br>    return user</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>reacc</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/", response_model=UserOut, dependencies=[Depends(on_superuser)])<br>async def create_user(<br>    user_in: UserCreate, session: AsyncSession = Depends(get_session)<br>):<br>    """<br>    Create new user.<br>    """<br>    user = await crud_user.get(session, email=user_in.email)<br>    if user is not None:<br>        raise HTTPException(<br>            status_code=409,<br>            detail="The user with this username already exists in the system",<br>        )<br>    obj_in = UserInDB(<br>        **user_in.dict(), hashed_password=get_password_hash(user_in.password)<br>    )<br>    return await crud_user.create(session, obj_in)</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection</td>
      <td>reacc</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post(<br>    "/chat/feedback",<br>    response_model=FeedbackResponse,<br>    responses={404: {"description": "Message not found"}},<br>)<br>@inject<br>async def feedback(<br>    feedback_rq: FeedbackRequest,<br>    session: Annotated[Session, Depends(current_user)],<br>    chat_service=Annotated[ChatService, Depends(Provide[Container.chat_service])],<br>):<br>    # Login Guard<br>    if not session:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized"<br>        )<br><br>    try:<br>        await chat_service.feedback(<br>            session.uuid,<br>            feedback_rq.history_id,<br>            feedback_rq.message_id,<br>            feedback_rq.feedback_type,<br>        )<br>    except NotFoundException:<br>        raise HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND, detail="Message not found"<br>        )<br><br>    return FeedbackResponse(<br>        history_id=feedback_rq.history_id,<br>        message_id=feedback_rq.message_id,<br>        feedback_type=feedback_rq.feedback_type,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/users", tags=["Users"], response_model=User)<br>async def create_user(request: UserCreateIn):<br>    new_user: ORMUser = await ORMUser.create(**request.dict())<br>    redis: ArqRedis = await create_pool(settings=redis_settings)<br>    await redis.enqueue_job(<br>        "send_message",<br>        new_user.id,<br>        "Congratulations! Your account has been created!",<br>    )<br>    return User.from_orm(new_user)</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/healthz", description="Health Check", tags=["Health Check"])<br>def ping():<br>    """Health check."""<br>    return {"ping": "pong!"}</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get(<br>    "/healthz",<br>    description="Health Check.",<br>    summary="Health Check.",<br>    operation_id="healthCheck",<br>    tags=["Health Check"],<br>)<br>def ping():<br>    """Health check."""<br>    return {"ping": "pong!"}</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_health(app):<br>    """Test /healthz endpoint."""<br>    response = app.get("/healthz")<br>    assert response.status_code == 200<br>    assert response.json() == {"ping": "pong!"}</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/healthcheck", include_in_schema=False)<br>async def healthcheck() -> dict[str, str]:<br>    return {"status": "ok"}</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/healthz", description="Health Check", tags=["Health Check"])<br>def ping():<br>    """Health check."""<br>    return {"ping": "pong!"}</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get(<br>    "/healthz",<br>    description="Health Check.",<br>    summary="Health Check.",<br>    operation_id="healthCheck",<br>    tags=["Health Check"],<br>)<br>def ping():<br>    """Health check."""<br>    return {"ping": "pong!"}</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>reacc</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/healthcheck", include_in_schema=False)<br>async def healthcheck() -> dict[str, str]:<br>    return {"status": "ok"}</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>reacc</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/a", responses={501: {"description": "Error 1"}})<br>async def a():<br>    return "a"</code></pre></div></td>
    </tr>
    <tr>
      <td>healthcheck</td>
      <td>reacc</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/health", responses={200: {"description": "Health check"}})<br>def health():<br>    return {"status": "ok"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/d",<br>    responses={<br>        "400": {"description": "Error with str"},<br>        "5XX": {"model": ResponseModel},<br>        "default": {"model": ResponseModel},<br>    },<br>)<br>async def d():<br>    return "d"</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@pytest.mark.asyncio<br>@pytest.mark.parametrize(<br>    "query_params",<br>    [<br>        {"source": "csbs"},<br>        {"source": "jhu"},<br>        {"source": "nyt"},<br>        {"timelines": True},<br>        {"timelines": "true"},<br>        {"timelines": 1},<br>        {"source": "jhu", "timelines": True},<br>        {"source": "nyt", "timelines": True},<br>    ],<br>)<br>async def test_latest(async_api_client, query_params, mock_client_session):<br>    response = await async_api_client.get("/v2/latest", query_string=query_params)<br><br>    print(f"GET {response.url}\n{response}")<br><br>    response_json = response.json()<br>    print(f"\tjson:\n{pf(response_json)}")<br><br>    assert response.status_code == 200<br>    assert response_json["latest"]["confirmed"]<br>    assert response_json["latest"]["deaths"]</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def add_interval_job(<br>    seconds: int = Body(120, title="循环间隔时间/秒,默认120s", embed=True),<br>    job_id: str = Body(..., title="任务id", embed=True),<br>    run_time: int = Body(<br>        time.time(), title="第一次运行时间", description="默认立即执行", embed=True<br>    ),<br>):<br>    res = Schedule.get_job(job_id=job_id)<br>    if res:<br>        return resp_fail(msg=f"{job_id} job already exists")<br>    schedule_job = Schedule.add_job(<br>        cron_task,<br>        "interval",<br>        args=(job_id,),<br>        seconds=seconds,  # 循环间隔时间 秒<br>        id=job_id,  # job ID<br>        next_run_time=datetime.fromtimestamp(run_time),  # 立即执行<br>    )<br>    return resp_ok(data={"job_id": schedule_job.id})</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_prediction(test_client) -> None:<br>    model_path = config.DEFAULT_MODEL_PATH<br>    hpp = HousePredictionPayload.parse_obj(<br>        {<br>            "median_income_in_block": 8.3252,<br>            "median_house_age_in_block": 41,<br>            "average_rooms": 6,<br>            "average_bedrooms": 1,<br>            "population_per_block": 322,<br>            "average_house_occupancy": 2.55,<br>            "block_latitude": 37.88,<br>            "block_longitude": -122.23,<br>        }<br>    )<br><br>    hpm = HousePriceModel(model_path)<br>    result = hpm.predict(hpp)<br>    assert isinstance(result, HousePredictionResult)</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users/{user_id}")<br>async def get_user(user_id: str, request: Request):<br>    route: APIRoute = request.scope["route"]<br>    return {"user_id": user_id, "path": route.path}</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@user_router.get("/{user_id}")<br>def get_user(user_id: str):<br>    return {"user_id": user_id}</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/{user_id}/", response_model=UserOut)<br>async def read_user(<br>    user_id: int,<br>    current_user: User = Depends(get_current_user),<br>    session: AsyncSession = Depends(get_session),<br>):<br>    """<br>    Get a specific user by id.<br>    """<br>    if current_user.id == user_id:<br>        return current_user<br><br>    user = await crud_user.get(session, id=user_id)<br>    if not current_user.is_superuser:<br>        raise HTTPException(<br>            status_code=403, detail="The user doesn't have enough privileges"<br>        )<br>    if user is None:<br>        raise HTTPException(status_code=404, detail="User not found")<br>    return user</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>reacc</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/teams/{team_id}", response_model=TeamReadWithHeroes)<br>def read_team(*, team_id: int, session: Session = Depends(get_session)):<br>    team = session.get(Team, team_id)<br>    if not team:<br>        raise HTTPException(status_code=404, detail="Team not found")<br>    return team</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>reacc</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/teams/{team_id}", response_model=TeamReadWithHeroes)<br>def read_team(*, team_id: int, session: Session = Depends(get_session)):<br>    team = session.get(Team, team_id)<br>    if not team:<br>        raise HTTPException(status_code=404, detail="Team not found")<br>    return team</code></pre></div></td>
    </tr>
    <tr>
      <td>get_rooms_api</td>
      <td>reacc</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/rooms/{room_id}")<br>def get_room(request: Request, room_id: str) -> schemas.room:<br>    """Get room info"""<br>    user = request.state.user<br>    room = models.get_room(room_id)<br>    return schemas.Room(<br>        id=room.room_id,<br>        start_time=room.start_time,<br>        end_time=room.get_end_time(),<br>        num_rsvps=len(room.rsvps),<br>        has_user_rsvped=user.id in room.rsvps,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/teams/{team_id}", response_model=TeamReadWithHeroes)<br>def read_team(*, team_id: int, session: Session = Depends(get_session)):<br>    team = session.get(Team, team_id)<br>    if not team:<br>        raise HTTPException(status_code=404, detail="Team not found")<br>    return team</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/refresh-token", response_model=AccessTokenResponse)<br>async def refresh_token(<br>    input: RefreshTokenRequest,<br>    session: AsyncSession = Depends(deps.get_session),<br>):<br>    """OAuth2 compatible token, get an access token for future requests using refresh token"""<br>    try:<br>        payload = jwt.decode(<br>            input.refresh_token,<br>            config.settings.SECRET_KEY,<br>            algorithms=[security.JWT_ALGORITHM],<br>        )<br>    except (jwt.DecodeError, ValidationError):<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, unknown error",<br>        )<br><br>    # JWT guarantees payload will be unchanged (and thus valid), no errors here<br>    token_data = security.JWTTokenPayload(**payload)<br><br>    if not token_data.refresh:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, cannot use access token",<br>        )<br>    now = int(time.time())<br>    if now < token_data.issued_at or now > token_data.expires_at:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, token expired or not yet valid",<br>        )<br><br>    result = await session.execute(select(User).where(User.id == token_data.sub))<br>    user = result.scalars().first()<br><br>    if user is None:<br>        raise HTTPException(status_code=404, detail="User not found")<br><br>    return security.generate_access_token_response(str(user.id))</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def refresh_token(<br>    input: RefreshTokenRequest,<br>    session: AsyncSession = Depends(deps.get_session),<br>):<br>    """OAuth2 compatible token, get an access token for future requests using refresh token"""<br>    try:<br>        payload = jwt.decode(<br>            input.refresh_token,<br>            config.settings.SECRET_KEY,<br>            algorithms=[security.JWT_ALGORITHM],<br>        )<br>    except (jwt.DecodeError, ValidationError):<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, unknown error",<br>        )<br><br>    # JWT guarantees payload will be unchanged (and thus valid), no errors here<br>    token_data = security.JWTTokenPayload(**payload)<br><br>    if not token_data.refresh:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, cannot use access token",<br>        )<br>    now = int(time.time())<br>    if now < token_data.issued_at or now > token_data.expires_at:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, token expired or not yet valid",<br>        )<br><br>    result = await session.execute(select(User).where(User.id == token_data.sub))<br>    user = result.scalars().first()<br><br>    if user is None:<br>        raise HTTPException(status_code=404, detail="User not found")<br><br>    return security.generate_access_token_response(str(user.id))</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def get_current_user(<br>    session: AsyncSession = Depends(get_session), token: str = Depends(reusable_oauth2)<br>) -> User:<br>    try:<br>        payload = jwt.decode(<br>            token, config.settings.SECRET_KEY, algorithms=[security.JWT_ALGORITHM]<br>        )<br>    except jwt.DecodeError:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials.",<br>        )<br>    # JWT guarantees payload will be unchanged (and thus valid), no errors here<br>    token_data = security.JWTTokenPayload(**payload)<br><br>    if token_data.refresh:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, cannot use refresh token",<br>        )<br>    now = int(time.time())<br>    if now < token_data.issued_at or now > token_data.expires_at:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, token expired or not yet valid",<br>        )<br><br>    result = await session.execute(select(User).where(User.id == token_data.sub))<br>    user = result.scalars().first()<br><br>    if not user:<br>        raise HTTPException(status_code=404, detail="User not found.")<br>    return user</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        authorization = request.headers.get("Authorization")<br>        if not authorization:<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        return authorization</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        authorization = request.headers.get("Authorization")<br>        if not authorization:<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        return authorization</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        api_key = request.headers.get(self.model.name)<br>        if not api_key:<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        return api_key</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>reacc</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        api_key = request.headers.get(self.model.name)<br>        if not api_key:<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        return api_key</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>reacc</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        api_key = request.query_params.get(self.model.name)<br>        if not api_key:<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        return api_key</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_implemented</td>
      <td>reacc</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Check if the route is public<br>        if (<br>            not request.url.path.startswith("/api")<br>            or request.method == "OPTIONS"<br>            or any([request.url.path.startswith(r) for r in PUBLIC_ROUTES])<br>        ):<br>            return await call_next(request)<br><br>        # Check if the user is logged in<br>        else:<br>            # Get the authorization header<br>            authorization_header = request.headers.get("Authorization")<br><br>            # Ensure the authorization header is present<br>            if not authorization_header:<br>                raise HTTPException(status_code=400, detail="Missing auth token")<br><br>            # Try to verify the token and get the user<br>            try:<br>                user = firebase_auth.verify_id_token(authorization_header)<br>                request.state.firebase_user = user<br>                request.state.user = models.get_user(user["uid"])<br>            except (<br>                ValueError,<br>                InvalidIdTokenError,<br>                ExpiredIdTokenError,<br>                RevokedIdTokenError,<br>                CertificateFetchError,<br>                UserDisabledError,<br>            ):<br>                raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>            # Run the function<br>            return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        api_key = request.cookies.get(self.model.name)<br>        if not api_key:<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        return api_key</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.fastapi.simple_hero_api import tutorial001_py310 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(<br>        mod.sqlite_url, connect_args=mod.connect_args, poolclass=StaticPool<br>    )<br><br>    with TestClient(mod.app) as client:<br>        hero1_data = {"name": "Deadpond", "secret_name": "Dive Wilson"}<br>        hero2_data = {<br>            "name": "Spider-Boy",<br>            "secret_name": "Pedro Parqueador",<br>            "id": 9000,<br>        }<br>        response = client.post("/heroes/", json=hero1_data)<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert data["name"] == hero1_data["name"]<br>        assert data["secret_name"] == hero1_data["secret_name"]<br>        assert data["id"] is not None<br>        assert data["age"] is None<br><br>        response = client.post("/heroes/", json=hero2_data)<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert data["name"] == hero2_data["name"]<br>        assert data["secret_name"] == hero2_data["secret_name"]<br>        assert data["id"] == hero2_data["id"], (<br>            "Up to this point it's still possible to "<br>            "set the ID of the hero in the request"<br>        )<br>        assert data["age"] is None<br><br>        response = client.get("/heroes/")<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert len(data) == 2<br>        assert data[0]["name"] == hero1_data["name"]<br>        assert data[0]["secret_name"] == hero1_data["secret_name"]<br>        assert data[1]["name"] == hero2_data["name"]<br>        assert data[1]["secret_name"] == hero2_data["secret_name"]<br>        assert data[1]["id"] == hero2_data["id"]<br><br>        response = client.get("/openapi.json")<br><br>        assert response.status_code == 200, response.text<br><br>        assert response.json() == {<br>            "openapi": "3.1.0",<br>            "info": {"title": "FastAPI", "version": </code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.fastapi.simple_hero_api import tutorial001 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(<br>        mod.sqlite_url, connect_args=mod.connect_args, poolclass=StaticPool<br>    )<br><br>    with TestClient(mod.app) as client:<br>        hero1_data = {"name": "Deadpond", "secret_name": "Dive Wilson"}<br>        hero2_data = {<br>            "name": "Spider-Boy",<br>            "secret_name": "Pedro Parqueador",<br>            "id": 9000,<br>        }<br>        response = client.post("/heroes/", json=hero1_data)<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert data["name"] == hero1_data["name"]<br>        assert data["secret_name"] == hero1_data["secret_name"]<br>        assert data["id"] is not None<br>        assert data["age"] is None<br><br>        response = client.post("/heroes/", json=hero2_data)<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert data["name"] == hero2_data["name"]<br>        assert data["secret_name"] == hero2_data["secret_name"]<br>        assert data["id"] == hero2_data["id"], (<br>            "Up to this point it's still possible to "<br>            "set the ID of the hero in the request"<br>        )<br>        assert data["age"] is None<br><br>        response = client.get("/heroes/")<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert len(data) == 2<br>        assert data[0]["name"] == hero1_data["name"]<br>        assert data[0]["secret_name"] == hero1_data["secret_name"]<br>        assert data[1]["name"] == hero2_data["name"]<br>        assert data[1]["secret_name"] == hero2_data["secret_name"]<br>        assert data[1]["id"] == hero2_data["id"]<br><br>        response = client.get("/openapi.json")<br><br>        assert response.status_code == 200, response.text<br><br>        assert response.json() == {<br>            "openapi": "3.1.0",<br>            "info": {"title": "FastAPI", "version": "0.1.0</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_tutorial(clear_sqlmodel):<br>    from docs_src.tutorial.fastapi.multiple_models import tutorial002_py310 as mod<br><br>    mod.sqlite_url = "sqlite://"<br>    mod.engine = create_engine(<br>        mod.sqlite_url, connect_args=mod.connect_args, poolclass=StaticPool<br>    )<br><br>    with TestClient(mod.app) as client:<br>        hero1_data = {"name": "Deadpond", "secret_name": "Dive Wilson"}<br>        hero2_data = {<br>            "name": "Spider-Boy",<br>            "secret_name": "Pedro Parqueador",<br>            "id": 9000,<br>        }<br>        response = client.post("/heroes/", json=hero1_data)<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert data["name"] == hero1_data["name"]<br>        assert data["secret_name"] == hero1_data["secret_name"]<br>        assert data["id"] is not None<br>        assert data["age"] is None<br><br>        response = client.post("/heroes/", json=hero2_data)<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert data["name"] == hero2_data["name"]<br>        assert data["secret_name"] == hero2_data["secret_name"]<br>        assert data["id"] != hero2_data["id"], (<br>            "Now it's not possible to predefine the ID from the request, "<br>            "it's now set by the database"<br>        )<br>        assert data["age"] is None<br><br>        response = client.get("/heroes/")<br>        data = response.json()<br><br>        assert response.status_code == 200, response.text<br>        assert len(data) == 2<br>        assert data[0]["name"] == hero1_data["name"]<br>        assert data[0]["secret_name"] == hero1_data["secret_name"]<br>        assert data[1]["name"] == hero2_data["name"]<br>        assert data[1]["secret_name"] == hero2_data["secret_name"]<br>        assert data[1]["id"] != hero2_data["id"]<br><br>        response = client.get("/openapi.json")<br><br>        assert response.status_code == 200, response.text<br><br>        assert response.json() == {<br>            "openapi": "3.1.0",<br>            "info": {"title": "FastAPI", </code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/login/", response_model=Token)<br>async def login(<br>    data: OAuth2PasswordRequestForm = Depends(),<br>    session: AsyncSession = Depends(get_session),<br>):<br>    user = await authenticate(session, email=data.username, password=data.password)<br>    if user is None:<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br>    if not user.is_active:<br>        raise HTTPException(status_code=400, detail="Inactive user")<br>    return {"access_token": create_access_token(user), "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def login(<br>    data: OAuth2PasswordRequestForm = Depends(),<br>    session: AsyncSession = Depends(get_session),<br>):<br>    user = await authenticate(session, email=data.username, password=data.password)<br>    if user is None:<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br>    if not user.is_active:<br>        raise HTTPException(status_code=400, detail="Inactive user")<br>    return {"access_token": create_access_token(user), "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/token", response_model=Token)<br>async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):<br>    user = authenticate_user(fake_users_db, form_data.username, form_data.password)<br>    if not user:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Incorrect username or password",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)<br>    access_token = create_access_token(<br>        data={"sub": user.username}, expires_delta=access_token_expires<br>    )<br>    return {"access_token": access_token, "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>reacc</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    @callback_router.post(<br>        "/post-callback",<br>        response_model=List[Item],<br>        responses={404: {"model": List[Message]}},<br>        generate_unique_id_function=custom_generate_unique_id3,<br>    )<br>    def post_callback(item1: Item, item2: Item):<br>        return item1, item2  # pragma: nocover</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>reacc</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    @router.get("/future")<br>    def home2():<br>        """Doesn't work and should return the value from env."""<br>        with rasterio.Env(GDAL_DISABLE_READDIR_ON_OPEN="FALSE"):<br>            with futures.ThreadPoolExecutor() as executor:<br>                res = list(executor.map(f, range(1)))[0]<br>        return {"env": res}</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_auth_callback</td>
      <td>reacc</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get(<br>    "/callback"<br>)  # Required for localhost testing since keycloak has /callback for localhost<br>@router.get(<br>    "/auth/callback",<br>    status_code=302,<br>    responses={<br>        307: {"description": "Redirect to Prompto"},<br>        400: {"description": "Bad request"},<br>    },<br>)<br>@inject<br>async def callback(<br>    code: str,<br>    config=Depends(Provide[Container.config]),<br>    auth_service=Depends(Provide[Container.auth_service]),<br>    signing_key=Depends(Provide[Container.signing_key]),<br>):<br>    headers = {"Content-Type": "application/x-www-form-urlencoded"}<br>    body = {<br>        "code": code,<br>        "client_id": config["oidc"]["client_id"],<br>        "client_secret": config["oidc"]["client_secret"],<br>        "redirect_uri": config["oidc"]["redirect_url"],<br>        "grant_type": "authorization_code",<br>    }<br><br>    idp_response = requests.post(<br>        url=config["oidc"]["token_url"],<br>        data=body,<br>        headers=headers,<br>    )<br>    idp_response.raise_for_status()<br><br>    tokens = idp_response.json()<br>    id_token = tokens["id_token"]<br><br>    # TODO add try catch<br>    token_information = decode(<br>        id_token,<br>        signing_key,<br>        algorithms=["RS512"],<br>        audience="prompto",<br>        issuer=config["oidc"]["url"].rstrip("/"),<br>    )<br>    log.info("Successful login for user %s", token_information["preferred_username"])<br>    session = Session(<br>        uuid=uuid.uuid4(),<br>        username=token_information["preferred_username"],<br>        email=token_information["email"],<br>        expires=int(<br>            (datetime.datetime.now() + datetime.timedelta(days=30)).timestamp()<br>        ),<br>    )<br>    await auth_service.save(session)<br>    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie<br>    client_redirect_url = config["oidc"]["client_redirect_url"]<br>    hostname = urlparse(config["app"]["host_url"]).hostname<br>    headers = {"Set-Cookie": f"prompto_id={session.uuid}; domain={hostname}; HttpOnly"}<br>    return RedirectResponse(<br>        f"{client_redirect_url}/?prompto_id={session.uuid}", headers=headers<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@callback_router.get(<br>    "{$callback_url}/callback/", responses={400: {"model": CustomModel}}<br>)<br>def callback_route():<br>    pass  # pragma: no cover</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">async def login(<br>    data: OAuth2PasswordRequestForm = Depends(),<br>    session: AsyncSession = Depends(get_session),<br>):<br>    user = await authenticate(session, email=data.username, password=data.password)<br>    if user is None:<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br>    if not user.is_active:<br>        raise HTTPException(status_code=400, detail="Inactive user")<br>    return {"access_token": create_access_token(user), "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def login_access_token(<br>    db: Session = Depends(deps.get_db), form_data: OAuth2PasswordRequestForm = Depends()<br>):<br>    """OAuth2 compatible token login, get an access token for future requests."""<br>    user = crud.user.authenticate(<br>        db, email=form_data.username, password=form_data.password<br>    )<br>    if not user:<br>        raise HTTPException(<br>            status_code=status.HTTP_400_BAD_REQUEST,<br>            detail="Incorrect email or password.",<br>        )<br>    elif not crud.user.is_active(user):<br>        raise HTTPException(<br>            status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user."<br>        )<br>    return {<br>        "access_token": security.create_access_token(str(user.id)),<br>        "token_type": "bearer",<br>    }</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/access-token", response_model=AccessTokenResponse)<br>async def login_access_token(<br>    session: AsyncSession = Depends(deps.get_session),<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>):<br>    """OAuth2 compatible token, get an access token for future requests using username and password"""<br><br>    result = await session.execute(select(User).where(User.email == form_data.username))<br>    user = result.scalars().first()<br><br>    if user is None:<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br><br>    if not security.verify_password(form_data.password, user.hashed_password):<br>        raise HTTPException(status_code=400, detail="Incorrect email or password")<br><br>    return security.generate_access_token_response(str(user.id))</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/token")<br>async def login(form_data: OAuth2PasswordRequestForm = Depends()):<br>    user_dict = fake_users_db.get(form_data.username)<br>    if not user_dict:<br>        raise HTTPException(status_code=400, detail="Incorrect username or password")<br>    user = UserInDB(**user_dict)<br>    hashed_password = fake_hash_password(form_data.password)<br>    if not hashed_password == user.hashed_password:<br>        raise HTTPException(status_code=400, detail="Incorrect username or password")<br><br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/token")<br>async def login(form_data: OAuth2PasswordRequestForm = Depends()):<br>    user_dict = fake_users_db.get(form_data.username)<br>    if not user_dict:<br>        raise HTTPException(status_code=400, detail="Incorrect username or password")<br>    user = UserInDB(**user_dict)<br>    hashed_password = fake_hash_password(form_data.password)<br>    if not hashed_password == user.hashed_password:<br>        raise HTTPException(status_code=400, detail="Incorrect username or password")<br><br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/token", response_model=Token)<br>async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):<br>    user = authenticate_user(fake_users_db, form_data.username, form_data.password)<br>    if not user:<br>        raise HTTPException(status_code=400, detail="Incorrect username or password")<br>    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)<br>    access_token = create_access_token(<br>        data={"sub": user.username, "scopes": form_data.scopes},<br>        expires_delta=access_token_expires,<br>    )<br>    return {"access_token": access_token, "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>reacc</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/token", response_model=Token)<br>async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):<br>    user = authenticate_user(fake_users_db, form_data.username, form_data.password)<br>    if not user:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Incorrect username or password",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)<br>    access_token = create_access_token(<br>        data={"sub": user.username}, expires_delta=access_token_expires<br>    )<br>    return {"access_token": access_token, "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>reacc</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/token", response_model=Token)<br>async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):<br>    user = authenticate_user(fake_users_db, form_data.username, form_data.password)<br>    if not user:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Incorrect username or password",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)<br>    access_token = create_access_token(<br>        data={"sub": user.username}, expires_delta=access_token_expires<br>    )<br>    return {"access_token": access_token, "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>login_implemented</td>
      <td>reacc</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/login")<br>async def login_for_access_token(<br>    form_data: OAuth2PasswordRequestForm = Depends(),<br>    session: Session = Depends(get_session),<br>):<br>    # Query the user from the database<br>    user = session.exec(select(User).where(User.username == form_data.username)).first()<br><br>    if user is None or user.password != form_data.password:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Invalid credentials",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    return {"access_token": user.username, "token_type": "bearer"}</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.post("/token", response_model=Token)<br>async def login_for_access_token(<br>    form_data: Annotated[OAuth2PasswordRequestForm, Depends()]<br>):<br>    user = authenticate_user(fake_users_db, form_data.username, form_data.password)<br>    if not user:<br>        raise HTTPException(<br>            status_code=status.HTTP_401_UNAUTHORIZED,<br>            detail="Incorrect username or password",<br>            headers={"WWW-Authenticate": "Bearer"},<br>        )<br>    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)<br>    access_token = create_access_token(<br>        data={"sub": user.username}, expires_delta=access_token_expires<br>    )<br>    return {"access_token": access_token, "token_type": "bearer"}</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@group_web.command("whiteboard")<br>def start_whiteboard():<br>    uvicorn.run(<br>        "tifa.app:create_app",<br>        factory=True,<br>        reload=True,<br>        host="0.0.0.0",<br>        port=8001,<br>        log_level="info",<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@group_web.command("start")<br>def start_tifa():<br>    uvicorn.run(<br>        "tifa.app:create_app",<br>        factory=True,<br>        reload=True,<br>        host="0.0.0.0",<br>        port=8000,<br>        log_level="info",<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def start_whiteboard():<br>    uvicorn.run(<br>        "tifa.app:create_app",<br>        factory=True,<br>        reload=True,<br>        host="0.0.0.0",<br>        port=8001,<br>        log_level="info",<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    create_db_and_tables()<br>    create_heroes()</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    create_db_and_tables()<br>    create_heroes()</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    create_db_and_tables()<br>    create_heroes()</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>reacc</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    cookiecutter(<br>        template=str(ROOT_FOLDER),<br>        no_input=True,<br>        extra_context={<br>            "project_name": "minimal_project",<br>        },<br>    )</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>reacc</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main() -> None:<br>    logger.info("Initializing service")<br>    init()<br>    logger.info("Service finished initializing")</code></pre></div></td>
    </tr>
    <tr>
      <td>uvicorn_main</td>
      <td>reacc</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    uvicorn.run(<br>        "fluento.main:app",<br>        port=5001,<br>        reload=True,<br>        workers=1,<br>        timeout_keep_alive=30,<br>    )</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main() -> None:<br>    logger.info("Initializing service")<br>    init()<br>    logger.info("Service finished initializing")</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.post("/refresh-token", response_model=AccessTokenResponse)<br>async def refresh_token(<br>    input: RefreshTokenRequest,<br>    session: AsyncSession = Depends(deps.get_session),<br>):<br>    """OAuth2 compatible token, get an access token for future requests using refresh token"""<br>    try:<br>        payload = jwt.decode(<br>            input.refresh_token,<br>            config.settings.SECRET_KEY,<br>            algorithms=[security.JWT_ALGORITHM],<br>        )<br>    except (jwt.DecodeError, ValidationError):<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, unknown error",<br>        )<br><br>    # JWT guarantees payload will be unchanged (and thus valid), no errors here<br>    token_data = security.JWTTokenPayload(**payload)<br><br>    if not token_data.refresh:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, cannot use access token",<br>        )<br>    now = int(time.time())<br>    if now < token_data.issued_at or now > token_data.expires_at:<br>        raise HTTPException(<br>            status_code=status.HTTP_403_FORBIDDEN,<br>            detail="Could not validate credentials, token expired or not yet valid",<br>        )<br><br>    result = await session.execute(select(User).where(User.id == token_data.sub))<br>    user = result.scalars().first()<br><br>    if user is None:<br>        raise HTTPException(status_code=404, detail="User not found")<br><br>    return security.generate_access_token_response(str(user.id))</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, scope: "Scope", receive: "Receive", send: "Send") -> None:<br>        """<br>        Load request ID from headers if present. Generate one otherwise.<br>        """<br>        if scope["type"] not in ("http", "websocket"):<br>            await self.app(scope, receive, send)<br>            return<br><br>        # Try to load request ID from the request headers<br>        headers = MutableHeaders(scope=scope)<br>        header_value = headers.get(self.header_name.lower())<br><br>        validation_failed = False<br>        if not header_value:<br>            # Generate request ID if none was found<br>            id_value = self.generator()<br>        elif self.validator and not self.validator(header_value):<br>            # Also generate a request ID if one was found, but it was deemed invalid<br>            validation_failed = True<br>            id_value = self.generator()<br>        else:<br>            # Otherwise, use the found request ID<br>            id_value = header_value<br><br>        # Clean/change the ID if needed<br>        if self.transformer:<br>            id_value = self.transformer(id_value)<br><br>        if validation_failed is True:<br>            logger.warning(FAILED_VALIDATION_MESSAGE, id_value)<br><br>        # Update the request headers if needed<br>        if id_value != header_value and self.update_request_header is True:<br>            headers[self.header_name] = id_value<br><br>        correlation_id.set(id_value)<br>        self.sentry_extension(id_value)<br><br>        async def handle_outgoing_request(message: "Message") -> None:<br>            if message["type"] == "http.response.start" and correlation_id.get():<br>                headers = MutableHeaders(scope=message)<br>                headers.append(self.header_name, correlation_id.get())<br><br>            await send(message)<br><br>        await self.app(scope, receive, handle_outgoing_request)<br>        return</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@dataclass<br>class CorrelationIdMiddleware:<br>    app: "ASGIApp"<br>    header_name: str = "X-Request-ID"<br>    update_request_header: bool = True<br><br>    # ID-generating callable<br>    generator: Callable[[], str] = field(default=lambda: uuid4().hex)<br><br>    # ID validator<br>    validator: Optional[Callable[[str], bool]] = field(default=is_valid_uuid4)<br><br>    # ID transformer - can be used to clean/mutate IDs<br>    transformer: Optional[Callable[[str], str]] = field(default=lambda a: a)<br><br>    async def __call__(self, scope: "Scope", receive: "Receive", send: "Send") -> None:<br>        """<br>        Load request ID from headers if present. Generate one otherwise.<br>        """<br>        if scope["type"] not in ("http", "websocket"):<br>            await self.app(scope, receive, send)<br>            return<br><br>        # Try to load request ID from the request headers<br>        headers = MutableHeaders(scope=scope)<br>        header_value = headers.get(self.header_name.lower())<br><br>        validation_failed = False<br>        if not header_value:<br>            # Generate request ID if none was found<br>            id_value = self.generator()<br>        elif self.validator and not self.validator(header_value):<br>            # Also generate a request ID if one was found, but it was deemed invalid<br>            validation_failed = True<br>            id_value = self.generator()<br>        else:<br>            # Otherwise, use the found request ID<br>            id_value = header_value<br><br>        # Clean/change the ID if needed<br>        if self.transformer:<br>            id_value = self.transformer(id_value)<br><br>        if validation_failed is True:<br>            logger.warning(FAILED_VALIDATION_MESSAGE, id_value)<br><br>        # Update the request headers if needed<br>        if id_value != header_value and self.update_request_header is True:<br>            headers[self.header_name] = id_value<br><br>        correlation_id.set(id_value)<br>        self.sentry_extension(id_value)<br><br>        async def handle_outgoing_request(message: "Message") -> None:<br>            if message["t</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        authorization = request.headers.get("Authorization")<br>        if not authorization:<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        return authorization</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        authorization = request.headers.get("Authorization")<br>        if not authorization:<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        return authorization</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        authorization = request.headers.get("Authorization")<br>        scheme, param = get_authorization_scheme_param(authorization)<br>        if not authorization or scheme.lower() != "bearer":<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_401_UNAUTHORIZED,<br>                    detail="Not authenticated",<br>                    headers={"WWW-Authenticate": "Bearer"},<br>                )<br>            else:<br>                return None<br>        return param</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>reacc</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        authorization = request.headers.get("Authorization")<br>        if not authorization:<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        return authorization</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>reacc</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        authorization = request.headers.get("Authorization")<br>        if not authorization:<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_403_FORBIDDEN, detail="Not authenticated"<br>                )<br>            else:<br>                return None<br>        return authorization</code></pre></div></td>
    </tr>
    <tr>
      <td>auth_outline</td>
      <td>reacc</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request, call_next, *args, **kwargs):<br>        # Get the authorization header<br>        authorization_header = request.headers.get("Authorization")<br><br>        # Ensure the authorization header is present<br>        if not authorization_header:<br>            raise HTTPException(status_code=400, detail="Missing auth token")<br><br>        # Try to verify the token and get the user<br>        try:<br>            # Check if we have the token<br>            pass<br>        except ValueError:<br>            raise HTTPException(status_code=400, detail="Invalid auth token")<br><br>        # Run the function<br>        return await call_next(request)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    async def __call__(self, request: Request) -> Optional[str]:<br>        authorization = request.headers.get("Authorization")<br>        scheme, param = get_authorization_scheme_param(authorization)<br>        if not authorization or scheme.lower() != "bearer":<br>            if self.auto_error:<br>                raise HTTPException(<br>                    status_code=HTTP_401_UNAUTHORIZED,<br>                    detail="Not authenticated",<br>                    headers={"WWW-Authenticate": "Bearer"},<br>                )<br>            else:<br>                return None<br>        return param</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    def openapi(self) -> Dict[str, Any]:<br>        """<br>        Generate the OpenAPI schema of the application. This is called by FastAPI<br>        internally.<br><br>        The first time it is called it stores the result in the attribute<br>        `app.openapi_schema`, and next times it is called, it just returns that same<br>        result. To avoid the cost of generating the schema every time.<br><br>        If you need to modify the generated OpenAPI schema, you could modify it.<br><br>        Read more in the<br>        [FastAPI docs for OpenAPI](https://fastapi.tiangolo.com/how-to/extending-openapi/).<br>        """<br>        if not self.openapi_schema:<br>            self.openapi_schema = get_openapi(<br>                title=self.title,<br>                version=self.version,<br>                openapi_version=self.openapi_version,<br>                summary=self.summary,<br>                description=self.description,<br>                terms_of_service=self.terms_of_service,<br>                contact=self.contact,<br>                license_info=self.license_info,<br>                routes=self.routes,<br>                webhooks=self.webhooks.routes,<br>                tags=self.openapi_tags,<br>                servers=self.servers,<br>                separate_input_output_schemas=self.separate_input_output_schemas,<br>            )<br>        return self.openapi_schema</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_openapi():<br>    response = client.get("/openapi.json")<br>    assert response.status_code == 200<br>    assert response.json() == {<br>        "openapi": "3.1.0",<br>        "info": {"title": "FastAPI", "version": "0.1.0"},<br>        "paths": {<br>            "/app": {<br>                "get": {<br>                    "summary": "Read Main",<br>                    "operationId": "read_main_app_get",<br>                    "responses": {<br>                        "200": {<br>                            "description": "Successful Response",<br>                            "content": {"application/json": {"schema": {}}},<br>                        }<br>                    },<br>                }<br>            }<br>        },<br>        "servers": [{"url": "/api/v1"}],<br>    }</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_openapi():<br>    response = client.get("/openapi.json")<br>    assert response.status_code == 200<br>    assert response.json() == {<br>        "openapi": "3.1.0",<br>        "info": {"title": "FastAPI", "version": "0.1.0"},<br>        "paths": {<br>            "/app": {<br>                "get": {<br>                    "summary": "Read Main",<br>                    "operationId": "read_main_app_get",<br>                    "responses": {<br>                        "200": {<br>                            "description": "Successful Response",<br>                            "content": {"application/json": {"schema": {}}},<br>                        }<br>                    },<br>                }<br>            }<br>        },<br>        "servers": [{"url": "/api/v1"}],<br>    }</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    create_db_and_tables()<br>    create_heroes()<br>    update_heroes()</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    create_db_and_tables()<br>    create_heroes()<br>    update_heroes()</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    create_db_and_tables()<br>    create_heroes()<br>    update_heroes()</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>reacc</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    @app.get("/")<br>    def main(algorithm=Depends(algorithms.dependency)):<br>        """endpoint."""<br>        -img = ImageData(arr)<br>        if algorithm:<br>            return algorithm(-img).data.max().tolist()<br><br>        return -img.data.max().tolist()</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>reacc</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    start_at = 0<br>    if start_with:<br>        start_at = [<br>            i for i, env in enumerate((environments)) if env["NAME"] == start_with<br>        ][0]<br>    for i, env in enumerate(environments[start_at:]):<br>        print(f"Processing tag: {env['NAME']}")<br>        process_tag(env=env)</code></pre></div></td>
    </tr>
    <tr>
      <td>generate_openapi</td>
      <td>reacc</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def main():<br>    output_file = sys.argv[1]<br><br>    # Set operation IDs to route names<br>    app = main.app<br>    for route in app.routes:<br>        if isinstance(route, APIRoute):<br>            route.operation_id = route.name<br>            route.tags = route.endpoint.__module__.split(".")[2:]<br><br>    # Generate OpenAPI schema<br>    openapi_def = app.openapi()<br><br>    # Write to file<br>    with open(output_file, "w") as f:<br>        f.write(json.dumps(openapi_def, indent=4))</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">    @app.get("/route1")<br>    async def route1():<br>        """route1."""<br>        return "I am tired"</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>unixcoder</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_token_no_username():<br>    response = client.get(<br>        "/users/me",<br>        headers={<br>            "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJmb28ifQ.NnExK_dlNAYyzACrXtXDrcWOgGY2JuPbI4eDaHdfK5Y"<br>        },<br>    )<br>    assert response.status_code == 401, response.text<br>    assert response.json() == {"detail": "Could not validate credentials"}<br>    assert response.headers["WWW-Authenticate"] == 'Bearer scope="me"'</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>unixcoder</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_token_no_username():<br>    response = client.get(<br>        "/users/me",<br>        headers={<br>            "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJmb28ifQ.NnExK_dlNAYyzACrXtXDrcWOgGY2JuPbI4eDaHdfK5Y"<br>        },<br>    )<br>    assert response.status_code == 401, response.text<br>    assert response.json() == {"detail": "Could not validate credentials"}<br>    assert response.headers["WWW-Authenticate"] == 'Bearer scope="me"'</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>unixcoder</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">def test_token_inexistent_user(client: TestClient):<br>    response = client.get(<br>        "/users/me",<br>        headers={<br>            "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VybmFtZTpib2IifQ.HcfCW67Uda-0gz54ZWTqmtgJnZeNem0Q757eTa9EZuw"<br>        },<br>    )<br>    assert response.status_code == 401, response.text<br>    assert response.json() == {"detail": "Could not validate credentials"}<br>    assert response.headers["WWW-Authenticate"] == 'Bearer scope="me"'</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>openai</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users/me")<br>def read_current_user(username: Annotated[str, Depends(get_current_username)]):<br>    return {"username": username}</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>openai</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@app.get("/users/me")<br>def read_current_user(username: Annotated[str, Depends(get_current_username)]):<br>    return {"username": username}</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>openai</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/", status_code=204)<br>async def health(session: AsyncSession = Depends(get_session)):<br>    try:<br>        await asyncio.wait_for(session.execute("SELECT 1"), timeout=1)<br>    except (asyncio.TimeoutError, socket.gaierror):<br>        return Response(status_code=503)<br>    return Response(status_code=204)</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>reacc</td>
      <td>0</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/users/me", response_model=UserResponse)<br>async def get_my_account(<br>    jwt_data: JWTData = Depends(parse_jwt_user_data),<br>) -> dict[str, str]:<br>    user = await service.get_user_by_id(jwt_data.user_id)<br><br>    return {<br>        "email": user["email"],<br>    }</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>reacc</td>
      <td>1</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/users/{username}", tags=["users"])<br>async def read_user(username: str):<br>    return {"username": username}</code></pre></div></td>
    </tr>
    <tr>
      <td>dependency_injection2_whoami</td>
      <td>reacc</td>
      <td>2</td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/auth/whoami", responses={401: {"description": "Unauthorized"}})<br>def whoami(session: Annotated[Session, Depends(current_user)]) -> WhoamiResponse:<br>    return WhoamiResponse(username=session.username, expires=session.expires)</code></pre></div></td>
      <td><div style="text-align: left; width: 600px; word-wrap: break-word; white-space: normal; overflow: hidden; background-color: #333"><pre><code style="background-color: #333">@router.get("/users/{username}", tags=["users"])<br>async def read_user(username: str):<br>    return {"username": username}</code></pre></div></td>
    </tr>
  </tbody>
</table>