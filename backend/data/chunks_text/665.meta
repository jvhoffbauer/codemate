{"original_code": "def load_correlation_ids(\n    header_key: str = \"CORRELATION_ID\",\n    generator: Callable[[], str] = uuid_hex_generator,\n) -> None:\n    \"\"\"\n    Transfer correlation IDs from a HTTP request to a Celery worker,\n    when spawned from a request.\n\n    This is called as long as Celery is installed.\n    \"\"\"\n    from asgi_correlation_id.context import correlation_id\n\n    sentry_extension = get_sentry_extension()\n\n    @before_task_publish.connect(weak=False)\n    def transfer_correlation_id(headers: Dict[str, str], **kwargs: Any) -> None:\n        \"\"\"\n        Transfer correlation ID from request thread to Celery worker, by adding\n        it as a header.\n\n        This way we're able to correlate work executed by Celery workers, back\n        to the originating request, when there was one.\n        \"\"\"\n        cid = correlation_id.get()\n        if cid:\n            headers[header_key] = cid\n\n    @task_prerun.connect(weak=False)\n    def load_correlation_id(task: \"Task\", **kwargs: Any) -> None:\n        \"\"\"\n        Set correlation ID from header if it exists.\n\n        If it doesn't exist, generate a unique ID for the task anyway.\n        \"\"\"\n        id_value = task.request.get(header_key)\n        if id_value:\n            correlation_id.set(id_value)\n            sentry_extension(id_value)\n        else:\n            generated_correlation_id = generator()\n            correlation_id.set(generated_correlation_id)\n            sentry_extension(generated_correlation_id)\n\n    @task_postrun.connect(weak=False)\n    def cleanup(**kwargs: Any) -> None:\n        \"\"\"\n        Clear context vars, to avoid re-using values in the next task.\n\n        Context vars are cleared automatically in a HTTP request-setting,\n        but must be manually reset for workers.\n        \"\"\"\n        correlation_id.set(None)"}