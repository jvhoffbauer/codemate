{"original_code": "    async def handle_req(\n        self,\n        http_request: Request,\n        background_tasks: BackgroundTasks,\n        sub_response: Response,\n        ctx: JsonRpcContext,\n        dependency_cache: dict = None,\n        shared_dependencies_error: BaseError = None,\n    ):\n        await ctx.enter_middlewares(self.middlewares)\n\n        if shared_dependencies_error:\n            raise shared_dependencies_error\n\n        # dependency_cache - there are shared dependencies, we pass them to each method, since\n        # they are common to all methods in the batch.\n        # But if the methods have their own dependencies, they are resolved separately.\n        dependency_cache = dependency_cache.copy()\n\n        values, errors, background_tasks, _, _ = await solve_dependencies(\n            request=http_request,\n            dependant=self.func_dependant,\n            body=ctx.request.params,\n            background_tasks=background_tasks,\n            response=sub_response,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n            dependency_cache=dependency_cache,\n        )\n\n        if errors:\n            raise invalid_params_from_validation_error(\n                RequestValidationError(_normalize_errors(errors))\n            )\n\n        result = await call_sync_async(self.func, **values)\n\n        response = {\n            \"jsonrpc\": \"2.0\",\n            \"result\": result,\n        }\n\n        # noinspection PyTypeChecker\n        resp = await serialize_response(\n            field=self.secure_cloned_response_field,\n            response_content=response,\n            include=self.response_model_include,\n            exclude=self.response_model_exclude,\n            by_alias=self.response_model_by_alias,\n            exclude_unset=self.response_model_exclude_unset,\n        )\n\n        return resp"}