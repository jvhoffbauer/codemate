{"original_code": "    def __init__(__pydantic_self__, **data: Any) -> None:\n        # Uses something other than `self` the first arg to allow \"self\" as a\n        # settable attribute\n\n        # SQLAlchemy does very dark black magic and modifies the __init__ method in\n        # sqlalchemy.orm.instrumentation._generate_init()\n        # so, to make SQLAlchemy work, it's needed to explicitly call __init__ to\n        # trigger all the SQLAlchemy logic, it doesn't work using cls.__new__, setting\n        # attributes obj.__dict__, etc. The __init__ method has to be called. But\n        # there are cases where calling all the default logic is not ideal, e.g.\n        # when calling Model.model_validate(), as the validation is done outside\n        # of instance creation.\n        # At the same time, __init__ is what users would normally call, by creating\n        # a new instance, which should have validation and all the default logic.\n        # So, to be able to set up the internal SQLAlchemy logic alone without\n        # executing the rest, and support things like Model.model_validate(), we\n        # use a contextvar to know if we should execute everything.\n        if finish_init.get():\n            sqlmodel_init(self=__pydantic_self__, data=data)"}