{"original_code": "    def __new__(\n        cls,\n        name: str,\n        bases: Tuple[Type[Any], ...],\n        class_dict: Dict[str, Any],\n        **kwargs: Any,\n    ) -> Any:\n        relationships: Dict[str, RelationshipInfo] = {}\n        dict_for_pydantic = {}\n        original_annotations = get_annotations(class_dict)\n        pydantic_annotations = {}\n        relationship_annotations = {}\n        for k, v in class_dict.items():\n            if isinstance(v, RelationshipInfo):\n                relationships[k] = v\n            else:\n                dict_for_pydantic[k] = v\n        for k, v in original_annotations.items():\n            if k in relationships:\n                relationship_annotations[k] = v\n            else:\n                pydantic_annotations[k] = v\n        dict_used = {\n            **dict_for_pydantic,\n            \"__weakref__\": None,\n            \"__sqlmodel_relationships__\": relationships,\n            \"__annotations__\": pydantic_annotations,\n        }\n        # Duplicate logic from Pydantic to filter config kwargs because if they are\n        # passed directly including the registry Pydantic will pass them over to the\n        # superclass causing an error\n        allowed_config_kwargs: Set[str] = {\n            key\n            for key in dir(BaseConfig)\n            if not (\n                key.startswith(\"__\") and key.endswith(\"__\")\n            )  # skip dunder methods and attributes\n        }\n        config_kwargs = {\n            key: kwargs[key] for key in kwargs.keys() & allowed_config_kwargs\n        }\n        new_cls = super().__new__(cls, name, bases, dict_used, **config_kwargs)\n        new_cls.__annotations__ = {\n            **relationship_annotations,\n            **pydantic_annotations,\n            **new_cls.__annotations__,\n        }\n\n        def get_config(name: str) -> Any:\n            config_class_value = get_config_value(\n                model=new_cls, parameter=name, default=Undefined\n            )\n            if config_class_value is not Undefined:\n                return config_class_value\n            kwarg_value = kwargs.get(name, Undefined)\n            if kwarg_value is not Undefined:\n                return kwarg_value\n            return Undefined\n\n        config_table = get_config(\"table\")\n        if config_table is True:\n            # If it was passed by kwargs, ensure it's also set in config\n            set_config_value(model=new_cls, parameter=\"table\", value=config_table)\n            for k, v in get_model_fields(new_cls).items():\n                col = get_column_from_field(v)\n                setattr(new_cls, k, col)\n            # Set a config flag to tell FastAPI that this should be read with a field\n            # in orm_mode instead of preemptively converting it to a dict.\n            # This could be done by reading new_cls.model_config['table'] in FastAPI, but\n            # that's very specific about SQLModel, so let's have another config that\n            # other future tools based on Pydantic can use.\n            set_config_value(\n                model=new_cls, parameter=\"read_from_attributes\", value=True\n            )\n            # For compatibility with older versions\n            # TODO: remove this in the future\n            set_config_value(model=new_cls, parameter=\"read_with_orm_mode\", value=True)\n\n        config_registry = get_config(\"registry\")\n        if config_registry is not Undefined:\n            config_registry = cast(registry, config_registry)\n            # If it was passed by kwargs, ensure it's also set in config\n            set_config_value(model=new_cls, parameter=\"registry\", value=config_table)\n            setattr(new_cls, \"_sa_registry\", config_registry)  # noqa: B010\n            setattr(new_cls, \"metadata\", config_registry.metadata)  # noqa: B010\n            setattr(new_cls, \"__abstract__\", True)  # noqa: B010\n        return new_cls"}