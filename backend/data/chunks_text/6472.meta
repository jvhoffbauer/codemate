{"original_code": "    async def handle_body(\n        self,\n        http_request: Request,\n        background_tasks: BackgroundTasks,\n        sub_response: Response,\n        body: Any,\n    ) -> dict:\n        # Shared dependencies for all requests in one json-rpc batch request\n        shared_dependencies_error = None\n        try:\n            dependency_cache = await self.solve_shared_dependencies(\n                http_request,\n                background_tasks,\n                sub_response,\n            )\n        except BaseError as error:\n            shared_dependencies_error = error\n            dependency_cache = None\n\n        scheduler = await self.entrypoint.get_scheduler()\n\n        if isinstance(body, list):\n            req_list = body\n        else:\n            req_list = [body]\n\n        # Run concurrently through scheduler\n        job_list = []\n        for req in req_list:\n            job = await scheduler.spawn(\n                self.handle_req_to_resp(\n                    http_request,\n                    background_tasks,\n                    sub_response,\n                    req,\n                    dependency_cache=dependency_cache,\n                    shared_dependencies_error=shared_dependencies_error,\n                )\n            )\n            job_list.append(job.wait())\n\n        resp_list = []\n\n        for resp in await asyncio.gather(*job_list):\n            # No response for successful notifications\n            has_content = \"error\" in resp or \"id\" in resp\n            if not has_content:\n                continue\n\n            resp_list.append(resp)\n\n        if not resp_list:\n            raise NoContent\n\n        if not isinstance(body, list):\n            content = resp_list[0]\n        else:\n            content = resp_list\n\n        return content"}