{"original_code": "async def contextmanager_in_threadpool(\n    cm: ContextManager[_T],\n) -> AsyncGenerator[_T, None]:\n    # blocking __exit__ from running waiting on a free thread\n    # can create race conditions/deadlocks if the context manager itself\n    # has its own internal pool (e.g. a database connection pool)\n    # to avoid this we let __exit__ run without a capacity limit\n    # since we're creating a new limiter for each call, any non-zero limit\n    # works (1 is arbitrary)\n    exit_limiter = CapacityLimiter(1)\n    try:\n        yield await run_in_threadpool(cm.__enter__)\n    except Exception as e:\n        ok = bool(\n            await anyio.to_thread.run_sync(\n                cm.__exit__, type(e), e, None, limiter=exit_limiter\n            )\n        )\n        if not ok:\n            raise e\n    else:\n        await anyio.to_thread.run_sync(\n            cm.__exit__, None, None, None, limiter=exit_limiter\n        )"}