{"original_code": "        def __get__(self, instance, owner=None):\n            if instance is None:\n                return self\n            if self.attrname is None:\n                raise TypeError(\n                    \"Cannot use cached_property instance without calling __set_name__ on it.\"\n                )\n            try:\n                cache = instance.__dict__\n            except (\n                AttributeError\n            ):  # not all objects have __dict__ (e.g. class defines slots)\n                msg = (\n                    f\"No '__dict__' attribute on {type(instance).__name__!r} \"\n                    f\"instance to cache {self.attrname!r} property.\"\n                )\n                raise TypeError(msg) from None\n            val = cache.get(self.attrname, _NOT_FOUND)\n            if val is _NOT_FOUND:\n                with self.lock:\n                    # check if another thread filled cache while we awaited lock\n                    val = cache.get(self.attrname, _NOT_FOUND)\n                    if val is _NOT_FOUND:\n                        val = self.func(instance)\n                        try:\n                            cache[self.attrname] = val\n                        except TypeError:\n                            msg = (\n                                f\"The '__dict__' attribute on {type(instance).__name__!r} instance \"\n                                f\"does not support item assignment for caching {self.attrname!r} property.\"\n                            )\n                            raise TypeError(msg) from None\n            return val"}