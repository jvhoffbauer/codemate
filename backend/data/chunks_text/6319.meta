{"original_code": "@router.post(\"/refresh-token\", response_model=AccessTokenResponse)\nasync def refresh_token(\n    input: RefreshTokenRequest,\n    session: AsyncSession = Depends(deps.get_session),\n):\n    \"\"\"OAuth2 compatible token, get an access token for future requests using refresh token\"\"\"\n    try:\n        payload = jwt.decode(\n            input.refresh_token,\n            config.settings.SECRET_KEY,\n            algorithms=[security.JWT_ALGORITHM],\n        )\n    except (jwt.DecodeError, ValidationError):\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials, unknown error\",\n        )\n\n    # JWT guarantees payload will be unchanged (and thus valid), no errors here\n    token_data = security.JWTTokenPayload(**payload)\n\n    if not token_data.refresh:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials, cannot use access token\",\n        )\n    now = int(time.time())\n    if now < token_data.issued_at or now > token_data.expires_at:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials, token expired or not yet valid\",\n        )\n\n    result = await session.execute(select(User).where(User.id == token_data.sub))\n    user = result.scalars().first()\n\n    if user is None:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    return security.generate_access_token_response(str(user.id))"}