{"original_code": "    def __init__(\n        cls, classname: str, bases: Tuple[type, ...], dict_: Dict[str, Any], **kw: Any\n    ) -> None:\n        # Only one of the base classes (or the current one) should be a table model\n        # this allows FastAPI cloning a SQLModel for the response_model without\n        # trying to create a new SQLAlchemy, for a new table, with the same name, that\n        # triggers an error\n        base_is_table = any(is_table_model_class(base) for base in bases)\n        if is_table_model_class(cls) and not base_is_table:\n            for rel_name, rel_info in cls.__sqlmodel_relationships__.items():\n                if rel_info.sa_relationship:\n                    # There's a SQLAlchemy relationship declared, that takes precedence\n                    # over anything else, use that and continue with the next attribute\n                    setattr(cls, rel_name, rel_info.sa_relationship)  # Fix #315\n                    continue\n                raw_ann = cls.__annotations__[rel_name]\n                origin = get_origin(raw_ann)\n                if origin is Mapped:\n                    ann = raw_ann.__args__[0]\n                else:\n                    ann = raw_ann\n                    # Plain forward references, for models not yet defined, are not\n                    # handled well by SQLAlchemy without Mapped, so, wrap the\n                    # annotations in Mapped here\n                    cls.__annotations__[rel_name] = Mapped[ann]  # type: ignore[valid-type]\n                relationship_to = get_relationship_to(\n                    name=rel_name, rel_info=rel_info, annotation=ann\n                )\n                rel_kwargs: Dict[str, Any] = {}\n                if rel_info.back_populates:\n                    rel_kwargs[\"back_populates\"] = rel_info.back_populates\n                if rel_info.link_model:\n                    ins = inspect(rel_info.link_model)\n                    local_table = getattr(ins, \"local_table\")  # noqa: B009\n                    if local_table is None:\n                        raise RuntimeError(\n                            \"Couldn't find the secondary table for \"\n                            f\"model {rel_info.link_model}\"\n                        )\n                    rel_kwargs[\"secondary\"] = local_table\n                rel_args: List[Any] = []\n                if rel_info.sa_relationship_args:\n                    rel_args.extend(rel_info.sa_relationship_args)\n                if rel_info.sa_relationship_kwargs:\n                    rel_kwargs.update(rel_info.sa_relationship_kwargs)\n                rel_value = relationship(relationship_to, *rel_args, **rel_kwargs)\n                setattr(cls, rel_name, rel_value)  # Fix #315\n            # SQLAlchemy no longer uses dict_\n            # Ref: https://github.com/sqlalchemy/sqlalchemy/commit/428ea01f00a9cc7f85e435018565eb6da7af1b77\n            # Tag: 1.4.36\n            DeclarativeMeta.__init__(cls, classname, bases, dict_, **kw)\n        else:\n            ModelMetaclass.__init__(cls, classname, bases, dict_, **kw)"}