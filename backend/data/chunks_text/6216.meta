{"original_code": "def fetch_populations(save=False):\n    \"\"\"\n    Returns a dictionary containing the population of each country fetched from the GeoNames.\n    https://www.geonames.org/\n\n    TODO: only skip writing to the filesystem when deployed with gunicorn, or handle concurent access, or use DB.\n\n    :returns: The mapping of populations.\n    :rtype: dict\n    \"\"\"\n    LOGGER.info(\"Fetching populations...\")\n\n    # Mapping of populations\n    mappings = {}\n\n    # Fetch the countries.\n    try:\n        countries = requests.get(\n            GEONAMES_URL, params={\"username\": \"dperic\"}, timeout=1.25\n        ).json()[\"geonames\"]\n        # Go through all the countries and perform the mapping.\n        for country in countries:\n            mappings.update(\n                {country[\"countryCode\"]: int(country[\"population\"]) or None}\n            )\n\n        if mappings and save:\n            LOGGER.info(\n                f\"Saving population data to {app.io.save(GEONAMES_BACKUP_PATH, mappings)}\"\n            )\n    except (json.JSONDecodeError, KeyError, requests.exceptions.Timeout) as err:\n        LOGGER.warning(\n            f\"Error pulling population data. {err.__class__.__name__}: {err}\"\n        )\n        mappings = app.io.load(GEONAMES_BACKUP_PATH)\n        LOGGER.info(f\"Using backup data from {GEONAMES_BACKUP_PATH}\")\n    # Finally, return the mappings.\n    LOGGER.info(\"Fetched populations\")\n    return mappings"}