{"original_code": "    def sqlmodel_validate(\n        cls: Type[_TSQLModel],\n        obj: Any,\n        *,\n        strict: Union[bool, None] = None,\n        from_attributes: Union[bool, None] = None,\n        context: Union[Dict[str, Any], None] = None,\n        update: Union[Dict[str, Any], None] = None,\n    ) -> _TSQLModel:\n        # This was SQLModel's original from_orm() for Pydantic v1\n        # Duplicated from Pydantic\n        if not cls.__config__.orm_mode:  # type: ignore[attr-defined] # noqa\n            raise ConfigError(\n                \"You must have the config attribute orm_mode=True to use from_orm\"\n            )\n        if not isinstance(obj, Mapping):\n            obj = (\n                {ROOT_KEY: obj}\n                if cls.__custom_root_type__  # type: ignore[attr-defined] # noqa\n                else cls._decompose_class(obj)  # type: ignore[attr-defined] # noqa\n            )\n        # SQLModel, support update dict\n        if update is not None:\n            obj = {**obj, **update}\n        # End SQLModel support dict\n        if not getattr(cls.__config__, \"table\", False):  # noqa\n            # If not table, normal Pydantic code\n            m: _TSQLModel = cls.__new__(cls)\n        else:\n            # If table, create the new instance normally to make SQLAlchemy create\n            # the _sa_instance_state attribute\n            m = cls()\n        values, fields_set, validation_error = validate_model(cls, obj)\n        if validation_error:\n            raise validation_error\n        # Updated to trigger SQLAlchemy internal handling\n        if not getattr(cls.__config__, \"table\", False):  # noqa\n            object.__setattr__(m, \"__dict__\", values)\n        else:\n            for key, value in values.items():\n                setattr(m, key, value)\n        # Continue with standard Pydantic logic\n        object.__setattr__(m, \"__fields_set__\", fields_set)\n        m._init_private_attributes()  # type: ignore[attr-defined] # noqa\n        return m"}