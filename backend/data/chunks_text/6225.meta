{"original_code": "@cached(cache=TTLCache(maxsize=1, ttl=1800))\nasync def get_locations():\n    \"\"\"\n    Retrieves the locations from the categories. The locations are cached for 1 hour.\n\n    :returns: The locations.\n    :rtype: List[Location]\n    \"\"\"\n\n    data_id = \"jhu.locations\"\n    LOGGER.info(f\"pid:{PID}: {data_id} Requesting data...\")\n\n    # Get all of the data categories locations.\n    confirmed = await get_category(\"confirmed\")\n    deaths = await get_category(\"deaths\")\n    recovered = await get_category(\"recovered\")\n\n    locations_confirmed = confirmed[\"locations\"]\n    locations_deaths = deaths[\"locations\"]\n    locations_recovered = recovered[\"locations\"]\n\n    # Final locations to return.\n    locations = []\n    # ***************************************************************************\n    # TODO: This iteration approach assumes the indexes remain the same\n    #       and opens us to a CRITICAL ERROR. The removal of a column in the data source\n    #       would break the API or SHIFT all the data confirmed, deaths, recovery producting\n    #       incorrect data to consumers.\n    # ***************************************************************************\n    # Go through locations.\n    for index, location in enumerate(locations_confirmed):\n        # Get the timelines.\n\n        # TEMP: Fix for merging recovery data. See TODO above for more details.\n        key = (location[\"country\"], location[\"province\"])\n\n        timelines = {\n            \"confirmed\": location[\"history\"],\n            \"deaths\": parse_history(key, locations_deaths),\n            \"recovered\": parse_history(key, locations_recovered),\n        }\n\n        # Grab coordinates.\n        coordinates = location[\"coordinates\"]\n\n        # Create location (supporting timelines) and append.\n        locations.append(\n            TimelinedLocation(\n                id=index,\n                country=location[\"country\"],\n                province=location[\"province\"],\n                coordinates=Coordinates(\n                    latitude=coordinates[\"lat\"], longitude=coordinates[\"long\"]\n                ),\n                last_updated=datetime.utcnow().isoformat() + \"Z\",\n                timelines={\n                    \"confirmed\": Timeline(\n                        timeline={\n                            datetime.strptime(date, \"%m/%d/%y\").isoformat()\n                            + \"Z\": amount\n                            for date, amount in timelines[\"confirmed\"].items()\n                        }\n                    ),\n                    \"deaths\": Timeline(\n                        timeline={\n                            datetime.strptime(date, \"%m/%d/%y\").isoformat()\n                            + \"Z\": amount\n                            for date, amount in timelines[\"deaths\"].items()\n                        }\n                    ),\n                    \"recovered\": Timeline(\n                        timeline={\n                            datetime.strptime(date, \"%m/%d/%y\").isoformat()\n                            + \"Z\": amount\n                            for date, amount in timelines[\"recovered\"].items()\n                        }\n                    ),\n                },\n            )\n        )\n\n    LOGGER.info(f\"{data_id} Data normalized\")\n\n    return locations"}