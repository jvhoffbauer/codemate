{"original_code": "async def get_locations(\n    request: Request,\n    source: Sources = \"jhu\",\n    country_code: str = None,\n    province: str = None,\n    county: str = None,\n    timelines: bool = False,\n):\n    \"\"\"\n    Getting the locations.\n    \"\"\"\n    # All query paramameters.\n    params = dict(request.query_params)\n\n    # Remove reserved params.\n    params.pop(\"source\", None)\n    params.pop(\"timelines\", None)\n\n    # Retrieve all the locations.\n    locations = await request.state.source.get_all()\n\n    # Attempt to filter out locations with properties matching the provided query params.\n    for key, value in params.items():\n        # Clean keys for security purposes.\n        key = key.lower()\n        value = value.lower().strip(\"__\")\n\n        # Do filtering.\n        try:\n            locations = [\n                location\n                for location in locations\n                if str(getattr(location, key)).lower() == str(value)\n            ]\n        except AttributeError:\n            pass\n        if not locations:\n            raise HTTPException(\n                404,\n                detail=f\"Source `{source}` does not have the desired location data.\",\n            )\n\n    # Return final serialized data.\n    return {\n        \"latest\": {\n            \"confirmed\": sum(map(lambda location: location.confirmed, locations)),\n            \"deaths\": sum(map(lambda location: location.deaths, locations)),\n            \"recovered\": sum(map(lambda location: location.recovered, locations)),\n        },\n        \"locations\": [location.serialize(timelines) for location in locations],\n    }"}