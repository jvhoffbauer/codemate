{"original_code": "def get_sqlalchemy_type(field: Any) -> Any:\n    if IS_PYDANTIC_V2:\n        field_info = field\n    else:\n        field_info = field.field_info\n    sa_type = getattr(field_info, \"sa_type\", Undefined)  # noqa: B009\n    if sa_type is not Undefined:\n        return sa_type\n\n    type_ = get_type_from_field(field)\n    metadata = get_field_metadata(field)\n\n    # Check enums first as an enum can also be a str, needed by Pydantic/FastAPI\n    if issubclass(type_, Enum):\n        return sa_Enum(type_)\n    if issubclass(type_, str):\n        max_length = getattr(metadata, \"max_length\", None)\n        if max_length:\n            return AutoString(length=max_length)\n        return AutoString\n    if issubclass(type_, float):\n        return Float\n    if issubclass(type_, bool):\n        return Boolean\n    if issubclass(type_, int):\n        return Integer\n    if issubclass(type_, datetime):\n        return DateTime\n    if issubclass(type_, date):\n        return Date\n    if issubclass(type_, timedelta):\n        return Interval\n    if issubclass(type_, time):\n        return Time\n    if issubclass(type_, bytes):\n        return LargeBinary\n    if issubclass(type_, Decimal):\n        return Numeric(\n            precision=getattr(metadata, \"max_digits\", None),\n            scale=getattr(metadata, \"decimal_places\", None),\n        )\n    if issubclass(type_, ipaddress.IPv4Address):\n        return AutoString\n    if issubclass(type_, ipaddress.IPv4Network):\n        return AutoString\n    if issubclass(type_, ipaddress.IPv6Address):\n        return AutoString\n    if issubclass(type_, ipaddress.IPv6Network):\n        return AutoString\n    if issubclass(type_, Path):\n        return AutoString\n    if issubclass(type_, uuid.UUID):\n        return GUID\n    raise ValueError(f\"{type_} has no matching SQLAlchemy type\")"}