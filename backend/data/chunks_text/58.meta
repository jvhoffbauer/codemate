{"original_code": "    def sqlmodel_table_construct(\n        *,\n        self_instance: _TSQLModel,\n        values: Dict[str, Any],\n        _fields_set: Union[Set[str], None] = None,\n    ) -> _TSQLModel:\n        # Copy from Pydantic's BaseModel.construct()\n        # Ref: https://github.com/pydantic/pydantic/blob/v2.5.2/pydantic/main.py#L198\n        # Modified to not include everything, only the model fields, and to\n        # set relationships\n        # SQLModel override to get class SQLAlchemy __dict__ attributes and\n        # set them back in after creating the object\n        # new_obj = cls.__new__(cls)\n        cls = type(self_instance)\n        old_dict = self_instance.__dict__.copy()\n        # End SQLModel override\n\n        fields_values: Dict[str, Any] = {}\n        defaults: Dict[\n            str, Any\n        ] = (\n            {}\n        )  # keeping this separate from `fields_values` helps us compute `_fields_set`\n        for name, field in cls.model_fields.items():\n            if field.alias and field.alias in values:\n                fields_values[name] = values.pop(field.alias)\n            elif name in values:\n                fields_values[name] = values.pop(name)\n            elif not field.is_required():\n                defaults[name] = field.get_default(call_default_factory=True)\n        if _fields_set is None:\n            _fields_set = set(fields_values.keys())\n        fields_values.update(defaults)\n\n        _extra: Union[Dict[str, Any], None] = None\n        if cls.model_config.get(\"extra\") == \"allow\":\n            _extra = {}\n            for k, v in values.items():\n                _extra[k] = v\n        # SQLModel override, do not include everything, only the model fields\n        # else:\n        #     fields_values.update(values)\n        # End SQLModel override\n        # SQLModel override\n        # Do not set __dict__, instead use setattr to trigger SQLAlchemy\n        # object.__setattr__(new_obj, \"__dict__\", fields_values)\n        # instrumentation\n        for key, value in {**old_dict, **fields_values}.items():\n            setattr(self_instance, key, value)\n        # End SQLModel override\n        object.__setattr__(self_instance, \"__pydantic_fields_set__\", _fields_set)\n        if not cls.__pydantic_root_model__:\n            object.__setattr__(self_instance, \"__pydantic_extra__\", _extra)\n\n        if cls.__pydantic_post_init__:\n            self_instance.model_post_init(None)\n        elif not cls.__pydantic_root_model__:\n            # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n            # Since it doesn't, that means that `__pydantic_private__` should be set to None\n            object.__setattr__(self_instance, \"__pydantic_private__\", None)\n        # SQLModel override, set relationships\n        # Get and set any relationship objects\n        for key in self_instance.__sqlmodel_relationships__:\n            value = values.get(key, Undefined)\n            if value is not Undefined:\n                setattr(self_instance, key, value)\n        # End SQLModel override\n        return self_instance"}